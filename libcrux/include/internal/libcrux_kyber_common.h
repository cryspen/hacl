/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: ../../../eurydice/eurydice --config ../../kyber-c.yaml ../libcrux_kyber.llbc --log Phase2.1
  F* version: b5cb71b8
  KaRaMeL version: 1282f04f
 */

#ifndef __internal_libcrux_kyber_common_H
#define __internal_libcrux_kyber_common_H

#if defined(__cplusplus)
extern "C" {
#endif

#include "internal/core.h"
#include "libcrux_digest.h"
#include "core.h"
#include "eurydice_glue.h"
#include "libcrux_hacl_glue.h"

#define LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS ((int32_t)3329)

#define LIBCRUX_KYBER_CONSTANTS_BITS_PER_COEFFICIENT ((size_t)12U)

#define LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT ((size_t)256U)

#define LIBCRUX_KYBER_CONSTANTS_BITS_PER_RING_ELEMENT (LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)12U)

#define LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT (LIBCRUX_KYBER_CONSTANTS_BITS_PER_RING_ELEMENT / (size_t)8U)

#define LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE ((size_t)32U)

#define LIBCRUX_KYBER_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE ((size_t)32U)

#define LIBCRUX_KYBER_CONSTANTS_H_DIGEST_SIZE ((size_t)32U)

#define LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_SHIFT (16U)

static inline uint32_t
libcrux_kyber_arithmetic_get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

#define LIBCRUX_KYBER_ARITHMETIC_BARRETT_SHIFT ((int64_t)26)

#define LIBCRUX_KYBER_ARITHMETIC_BARRETT_R ((int64_t)1 << (uint32_t)LIBCRUX_KYBER_ARITHMETIC_BARRETT_SHIFT)

#define LIBCRUX_KYBER_ARITHMETIC_BARRETT_MULTIPLIER ((int64_t)20159)

static inline int32_t libcrux_kyber_arithmetic_barrett_reduce(int32_t value)
{
  int64_t
  t =
    core_convert_num___core__convert__From_i32__for_i64__59__from(value)
    * LIBCRUX_KYBER_ARITHMETIC_BARRETT_MULTIPLIER
    + (LIBCRUX_KYBER_ARITHMETIC_BARRETT_R >> 1U);
  int32_t quotient = (int32_t)(t >> (uint32_t)LIBCRUX_KYBER_ARITHMETIC_BARRETT_SHIFT);
  return value - quotient * LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS;
}

#define LIBCRUX_KYBER_ARITHMETIC_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R (62209U)

static inline int32_t libcrux_kyber_arithmetic_montgomery_reduce(int32_t value)
{
  uint32_t
  t =
    libcrux_kyber_arithmetic_get_n_least_significant_bits(LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_SHIFT,
      (uint32_t)value)
    * LIBCRUX_KYBER_ARITHMETIC_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R;
  int16_t
  k =
    (int16_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_SHIFT,
      t);
  int32_t k_times_modulus = (int32_t)k * LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS;
  int32_t c = k_times_modulus >> (uint32_t)LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_SHIFT;
  int32_t value_high = value >> (uint32_t)LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_SHIFT;
  return value_high - c;
}

static inline int32_t
libcrux_kyber_arithmetic_montgomery_multiply_fe_by_fer(int32_t fe, int32_t fer)
{
  return libcrux_kyber_arithmetic_montgomery_reduce(fe * fer);
}

#define LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS ((int32_t)1353)

static inline int32_t libcrux_kyber_arithmetic_to_standard_domain(int32_t mfe)
{
  return
    libcrux_kyber_arithmetic_montgomery_reduce(mfe
      * LIBCRUX_KYBER_ARITHMETIC_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS);
}

static inline uint16_t libcrux_kyber_arithmetic_to_unsigned_representative(int32_t fe)
{
  return (uint16_t)(fe + (LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS & fe >> 31U));
}

static const
int32_t
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO[256U] = { 0U };

static inline uint8_t libcrux_kyber_compress_compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

static inline int32_t
libcrux_kyber_compress_compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint64_t compressed = (uint64_t)fe << (uint32_t)coefficient_bits;
  compressed = compressed + 1664ULL;
  compressed = compressed * 10321340ULL;
  compressed = compressed >> 35U;
  return
    (int32_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(coefficient_bits,
      (uint32_t)compressed);
}

static inline int32_t libcrux_kyber_compress_decompress_message_coefficient(int32_t fe)
{
  return -fe & (LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS + (int32_t)1) / (int32_t)2;
}

static inline int32_t
libcrux_kyber_compress_decompress_ciphertext_coefficient(uint8_t coefficient_bits, int32_t fe)
{
  uint32_t decompressed = (uint32_t)fe * (uint32_t)LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS;
  decompressed = (decompressed << 1U) + (1U << (uint32_t)coefficient_bits);
  decompressed = decompressed >> (uint32_t)((uint32_t)coefficient_bits + 1U);
  return (int32_t)decompressed;
}

static inline uint8_t libcrux_kyber_constant_time_ops_is_non_zero(uint8_t value)
{
  uint16_t value0 = (uint16_t)value;
  uint16_t uu____0 = value0;
  uint16_t
  result =
    (((uint32_t)uu____0 | (uint32_t)core_num__u16_7__wrapping_add(~value0, 1U)) & 0xFFFFU)
    >> 8U
    & 1U;
  return (uint8_t)result;
}

static inline void
libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(
  Eurydice_slice lhs,
  Eurydice_slice rhs,
  uint8_t selector,
  uint8_t ret[32U]
)
{
  uint8_t
  mask = core_num__u8_6__wrapping_sub(libcrux_kyber_constant_time_ops_is_non_zero(selector), 1U);
  uint8_t out[32U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = (uint32_t)Eurydice_slice_index(lhs, i0, uint8_t, uint8_t) & (uint32_t)mask;
    uint8_t *uu____1 = &Eurydice_slice_index(rhs, i0, uint8_t, uint8_t);
    out[i0] = (uint32_t)uu____0 | ((uint32_t)uu____1[0U] & (uint32_t)~mask);
  }
  memcpy(ret, out, (size_t)32U * sizeof (uint8_t));
}

static inline void libcrux_kyber_hash_functions_G(Eurydice_slice input, uint8_t ret[64U])
{
  uint8_t ret0[64U];
  libcrux_digest_sha3_512(input, ret0);
  memcpy(ret, ret0, (size_t)64U * sizeof (uint8_t));
}

static inline void libcrux_kyber_hash_functions_H(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_sha3_256(input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static inline void
libcrux_kyber_hash_functions_free_state(
  libcrux_digest_incremental_x4_Shake128StateX4 xof_state
)
{
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__free_memory(xof_state);
}

typedef struct K___uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
}
K___uint8_t_uint8_t_uint8_t;

static inline K___uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_3(uint16_t coefficient1, uint16_t coefficient2)
{
  uint8_t coef1 = (uint8_t)((uint32_t)coefficient1 & 255U);
  uint8_t coef2 = (uint8_t)((uint32_t)coefficient1 >> 8U | ((uint32_t)coefficient2 & 15U) << 4U);
  uint8_t coef3 = (uint8_t)((uint32_t)coefficient2 >> 4U & 255U);
  return ((K___uint8_t_uint8_t_uint8_t){ .fst = coef1, .snd = coef2, .thd = coef3 });
}

static inline void
libcrux_kyber_serialize_serialize_uncompressed_ring_element(
  int32_t re[256U],
  uint8_t ret[384U]
)
{
  uint8_t serialized[384U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
        int32_t,
        size_t)
      / (size_t)2U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    coefficients =
      Eurydice_array_to_subslice((size_t)256U,
        re,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)2U,
            .end = i0 * (size_t)2U + (size_t)2U
          }
        ),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint16_t
    coefficient1 =
      libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
          (size_t)0U,
          int32_t,
          int32_t));
    uint16_t
    coefficient2 =
      libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
          (size_t)1U,
          int32_t,
          int32_t));
    K___uint8_t_uint8_t_uint8_t
    uu____0 = libcrux_kyber_serialize_compress_coefficients_3(coefficient1, coefficient2);
    uint8_t coef1 = uu____0.fst;
    uint8_t coef2 = uu____0.snd;
    uint8_t coef3 = uu____0.thd;
    serialized[(size_t)3U * i0] = coef1;
    serialized[(size_t)3U * i0 + (size_t)1U] = coef2;
    serialized[(size_t)3U * i0 + (size_t)2U] = coef3;
  }
  memcpy(ret, serialized, (size_t)384U * sizeof (uint8_t));
}

typedef struct core_ops_range_Range__uint32_t_s
{
  uint32_t start;
  uint32_t end;
}
core_ops_range_Range__uint32_t;

static inline void
libcrux_kyber_sampling_sample_from_binomial_distribution_2(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)4U;
    i++)
  {
    size_t chunk_number = i;
    Eurydice_slice
    byte_chunk =
      Eurydice_slice_subslice(randomness,
        (
          (core_ops_range_Range__size_t){
            .start = chunk_number * (size_t)4U,
            .end = chunk_number * (size_t)4U + (size_t)4U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint32_t uu____0 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
    uint32_t
    uu____1 =
      uu____0
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
    uint32_t
    uu____2 =
      uu____1
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
    uint32_t
    random_bits_as_u32 =
      uu____2
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)3U, uint8_t, uint8_t) << 24U;
    uint32_t even_bits = random_bits_as_u32 & 1431655765U;
    uint32_t odd_bits = random_bits_as_u32 >> 1U & 1431655765U;
    uint32_t coin_toss_outcomes = even_bits + odd_bits;
    core_ops_range_Range__uint32_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__uint32_t){ .start = 0U, .end = CORE_NUM__U32_8__BITS / 4U }
        ),
        core_ops_range_Range__uint32_t,
        core_ops_range_Range__uint32_t);
    while (true)
    {
      core_option_Option__uint32_t
      uu____3 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          uint32_t,
          core_option_Option__uint32_t);
      if (uu____3.tag == core_option_None)
      {
        break;
      }
      else
      {
        uint32_t outcome_set = uu____3.f0;
        uint32_t outcome_set0 = outcome_set * 4U;
        int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 3U);
        int32_t outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + 2U) & 3U);
        size_t offset = (size_t)(outcome_set0 >> 2U);
        sampled[(size_t)8U * chunk_number + offset] = outcome_1 - outcome_2;
      }
    }
  }
  memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
}

typedef struct core_ops_range_Range__int32_t_s
{
  int32_t start;
  int32_t end;
}
core_ops_range_Range__int32_t;

static inline void
libcrux_kyber_sampling_sample_from_binomial_distribution_3(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)3U;
    i++)
  {
    size_t chunk_number = i;
    Eurydice_slice
    byte_chunk =
      Eurydice_slice_subslice(randomness,
        (
          (core_ops_range_Range__size_t){
            .start = chunk_number * (size_t)3U,
            .end = chunk_number * (size_t)3U + (size_t)3U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint32_t uu____0 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
    uint32_t
    uu____1 =
      uu____0
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
    uint32_t
    random_bits_as_u24 =
      uu____1
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
    uint32_t first_bits = random_bits_as_u24 & 2396745U;
    uint32_t second_bits = random_bits_as_u24 >> 1U & 2396745U;
    uint32_t third_bits = random_bits_as_u24 >> 2U & 2396745U;
    uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
    core_ops_range_Range__int32_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__int32_t){ .start = (int32_t)0, .end = (int32_t)24 / (int32_t)6 }
        ),
        core_ops_range_Range__int32_t,
        core_ops_range_Range__int32_t);
    while (true)
    {
      core_option_Option__int32_t
      uu____2 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          int32_t,
          core_option_Option__int32_t);
      if (uu____2.tag == core_option_None)
      {
        break;
      }
      else
      {
        int32_t outcome_set = uu____2.f0;
        int32_t outcome_set0 = outcome_set * (int32_t)6;
        int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 7U);
        int32_t
        outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + (int32_t)3) & 7U);
        size_t offset = (size_t)(outcome_set0 / (int32_t)6);
        sampled[(size_t)4U * chunk_number + offset] = outcome_1 - outcome_2;
      }
    }
  }
  memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
}

static const
int32_t
libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[128U] =
  {
    (int32_t)-1044, (int32_t)-758, (int32_t)-359, (int32_t)-1517, (int32_t)1493, (int32_t)1422,
    (int32_t)287, (int32_t)202, (int32_t)-171, (int32_t)622, (int32_t)1577, (int32_t)182,
    (int32_t)962, (int32_t)-1202, (int32_t)-1474, (int32_t)1468, (int32_t)573, (int32_t)-1325,
    (int32_t)264, (int32_t)383, (int32_t)-829, (int32_t)1458, (int32_t)-1602, (int32_t)-130,
    (int32_t)-681, (int32_t)1017, (int32_t)732, (int32_t)608, (int32_t)-1542, (int32_t)411,
    (int32_t)-205, (int32_t)-1571, (int32_t)1223, (int32_t)652, (int32_t)-552, (int32_t)1015,
    (int32_t)-1293, (int32_t)1491, (int32_t)-282, (int32_t)-1544, (int32_t)516, (int32_t)-8,
    (int32_t)-320, (int32_t)-666, (int32_t)-1618, (int32_t)-1162, (int32_t)126, (int32_t)1469,
    (int32_t)-853, (int32_t)-90, (int32_t)-271, (int32_t)830, (int32_t)107, (int32_t)-1421,
    (int32_t)-247, (int32_t)-951, (int32_t)-398, (int32_t)961, (int32_t)-1508, (int32_t)-725,
    (int32_t)448, (int32_t)-1065, (int32_t)677, (int32_t)-1275, (int32_t)-1103, (int32_t)430,
    (int32_t)555, (int32_t)843, (int32_t)-1251, (int32_t)871, (int32_t)1550, (int32_t)105,
    (int32_t)422, (int32_t)587, (int32_t)177, (int32_t)-235, (int32_t)-291, (int32_t)-460,
    (int32_t)1574, (int32_t)1653, (int32_t)-246, (int32_t)778, (int32_t)1159, (int32_t)-147,
    (int32_t)-777, (int32_t)1483, (int32_t)-602, (int32_t)1119, (int32_t)-1590, (int32_t)644,
    (int32_t)-872, (int32_t)349, (int32_t)418, (int32_t)329, (int32_t)-156, (int32_t)-75,
    (int32_t)817, (int32_t)1097, (int32_t)603, (int32_t)610, (int32_t)1322, (int32_t)-1285,
    (int32_t)-1465, (int32_t)384, (int32_t)-1215, (int32_t)-136, (int32_t)1218, (int32_t)-1335,
    (int32_t)-874, (int32_t)220, (int32_t)-1187, (int32_t)-1659, (int32_t)-1185, (int32_t)-1530,
    (int32_t)-1278, (int32_t)794, (int32_t)-1510, (int32_t)-854, (int32_t)-870, (int32_t)478,
    (int32_t)-108, (int32_t)-308, (int32_t)996, (int32_t)991, (int32_t)958, (int32_t)-1460,
    (int32_t)1522, (int32_t)1628
  };

static inline void
libcrux_kyber_ntt_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  size_t _initial_coefficient_bound,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  for (size_t i = (size_t)0U; i < (size_t)128U >> (uint32_t)layer; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
    size_t offset = round * step * (size_t)2U;
    core_ops_range_Range__size_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__size_t){ .start = offset, .end = offset + step }
        ),
        core_ops_range_Range__size_t,
        core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____0 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          size_t,
          core_option_Option__size_t);
      if (uu____0.tag == core_option_None)
      {
        break;
      }
      else
      {
        size_t j = uu____0.f0;
        int32_t
        t =
          libcrux_kyber_arithmetic_montgomery_multiply_fe_by_fer(re[j + step],
            libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
        re[j + step] = re[j] - t;
        re[j] = re[j] + t;
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_ntt_ntt_at_layer_3(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)1U;
  for (size_t i = (size_t)0U; i < (size_t)128U; i++)
  {
    size_t j = i;
    int32_t t = re[j + (size_t)128U] * (int32_t)-1600;
    re[j + (size_t)128U] = re[j] - t;
    re[j] = re[j] + t;
  }
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)1U, re);
  for (size_t i = (size_t)0U; i < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int32_t uu____0 = libcrux_kyber_arithmetic_barrett_reduce(re[i0]);
    re[i0] = uu____0;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

typedef struct K___int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
}
K___int32_t_int32_t;

static inline K___int32_t_int32_t
libcrux_kyber_ntt_ntt_multiply_binomials(
  K___int32_t_int32_t _,
  K___int32_t_int32_t _0,
  int32_t zeta
)
{
  int32_t a0 = _.fst;
  int32_t a1 = _.snd;
  int32_t b0 = _0.fst;
  int32_t b1 = _0.snd;
  int32_t uu____0 = a0 * b0;
  int32_t
  uu____1 =
    libcrux_kyber_arithmetic_montgomery_reduce(uu____0
      + libcrux_kyber_arithmetic_montgomery_reduce(a1 * b1) * zeta);
  return
    (
      (K___int32_t_int32_t){
        .fst = uu____1,
        .snd = libcrux_kyber_arithmetic_montgomery_reduce(a0 * b1 + a1 * b0)
      }
    );
}

static inline void
libcrux_kyber_ntt_ntt_multiply(int32_t (*lhs)[256U], int32_t (*rhs)[256U], int32_t ret[256U])
{
  int32_t out[256U];
  memcpy(out,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)4U;
    i++)
  {
    size_t i0 = i;
    K___int32_t_int32_t lit0;
    lit0.fst = lhs[0U][(size_t)4U * i0];
    lit0.snd = lhs[0U][(size_t)4U * i0 + (size_t)1U];
    K___int32_t_int32_t lit1;
    lit1.fst = rhs[0U][(size_t)4U * i0];
    lit1.snd = rhs[0U][(size_t)4U * i0 + (size_t)1U];
    K___int32_t_int32_t
    product =
      libcrux_kyber_ntt_ntt_multiply_binomials(lit0,
        lit1,
        libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i0]);
    out[(size_t)4U * i0] = product.fst;
    out[(size_t)4U * i0 + (size_t)1U] = product.snd;
    K___int32_t_int32_t lit2;
    lit2.fst = lhs[0U][(size_t)4U * i0 + (size_t)2U];
    lit2.snd = lhs[0U][(size_t)4U * i0 + (size_t)3U];
    K___int32_t_int32_t lit;
    lit.fst = rhs[0U][(size_t)4U * i0 + (size_t)2U];
    lit.snd = rhs[0U][(size_t)4U * i0 + (size_t)3U];
    K___int32_t_int32_t
    product0 =
      libcrux_kyber_ntt_ntt_multiply_binomials(lit2,
        lit,
        -libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i0]);
    out[(size_t)4U * i0 + (size_t)2U] = product0.fst;
    out[(size_t)4U * i0 + (size_t)3U] = product0.snd;
  }
  memcpy(ret, out, (size_t)256U * sizeof (int32_t));
}

typedef struct K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
  uint8_t f3;
  uint8_t f4;
}
K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t;

static inline K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_10(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4
)
{
  uint8_t coef1 = (uint8_t)(coefficient1 & (int32_t)255);
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U & (int32_t)3);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient2 >> 6U & (int32_t)15);
  uint8_t
  coef4 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient3 >> 4U & (int32_t)63);
  uint8_t coef5 = (uint8_t)(coefficient4 >> 2U & (int32_t)255);
  return
    (
      (K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
        .fst = coef1,
        .snd = coef2,
        .thd = coef3,
        .f3 = coef4,
        .f4 = coef5
      }
    );
}

typedef struct
K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_s
{
  uint8_t fst;
  uint8_t snd;
  uint8_t thd;
  uint8_t f3;
  uint8_t f4;
  uint8_t f5;
  uint8_t f6;
  uint8_t f7;
  uint8_t f8;
  uint8_t f9;
  uint8_t f10;
}
K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t;

static inline K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_11(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4,
  int32_t coefficient5,
  int32_t coefficient6,
  int32_t coefficient7,
  int32_t coefficient8
)
{
  uint8_t coef1 = (uint8_t)coefficient1;
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)31)
    << 3U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient2 >> 5U);
  uint8_t coef4 = (uint8_t)(coefficient3 >> 2U & (int32_t)255);
  uint8_t
  coef5 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)127)
    << 1U
    | (uint32_t)(uint8_t)(coefficient3 >> 10U);
  uint8_t
  coef6 =
    (uint32_t)(uint8_t)(coefficient5 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient4 >> 7U);
  uint8_t
  coef7 =
    (uint32_t)(uint8_t)(coefficient6 & (int32_t)1)
    << 7U
    | (uint32_t)(uint8_t)(coefficient5 >> 4U);
  uint8_t coef8 = (uint8_t)(coefficient6 >> 1U & (int32_t)255);
  uint8_t
  coef9 =
    (uint32_t)(uint8_t)(coefficient7 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient6 >> 9U);
  uint8_t
  coef10 =
    (uint32_t)(uint8_t)(coefficient8 & (int32_t)7)
    << 5U
    | (uint32_t)(uint8_t)(coefficient7 >> 6U);
  uint8_t coef11 = (uint8_t)(coefficient8 >> 3U);
  return
    (
      (K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
        .fst = coef1,
        .snd = coef2,
        .thd = coef3,
        .f3 = coef4,
        .f4 = coef5,
        .f5 = coef6,
        .f6 = coef7,
        .f7 = coef8,
        .f8 = coef9,
        .f9 = coef10,
        .f10 = coef11
      }
    );
}

static inline void
libcrux_kyber_ntt_invert_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  for (size_t i = (size_t)0U; i < (size_t)128U >> (uint32_t)layer; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
    size_t offset = round * step * (size_t)2U;
    core_ops_range_Range__size_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__size_t){ .start = offset, .end = offset + step }
        ),
        core_ops_range_Range__size_t,
        core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____0 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          size_t,
          core_option_Option__size_t);
      if (uu____0.tag == core_option_None)
      {
        break;
      }
      else
      {
        size_t j = uu____0.f0;
        int32_t a_minus_b = re[j + step] - re[j];
        re[j] = re[j] + re[j + step];
        int32_t
        uu____1 =
          libcrux_kyber_arithmetic_montgomery_reduce(a_minus_b
            * libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
        re[j + step] = uu____1;
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_serialize_deserialize_then_decompress_message(
  uint8_t serialized[32U],
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)32U,
          serialized,
          uint8_t,
          Eurydice_slice),
        uint8_t,
        size_t);
    i++)
  {
    size_t i0 = i;
    uint8_t byte = serialized[i0];
    core_ops_range_Range__size_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)8U }
        ),
        core_ops_range_Range__size_t,
        core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____0 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          size_t,
          core_option_Option__size_t);
      if (uu____0.tag == core_option_None)
      {
        break;
      }
      else
      {
        size_t j = uu____0.f0;
        int32_t coefficient_compressed = (int32_t)((uint32_t)byte >> (uint32_t)j & 1U);
        int32_t
        uu____1 = libcrux_kyber_compress_decompress_message_coefficient(coefficient_compressed);
        re[(size_t)8U * i0 + j] = uu____1;
      }
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_5(
  uint8_t coefficient2,
  uint8_t coefficient1,
  uint8_t coefficient4,
  uint8_t coefficient3,
  uint8_t coefficient5,
  uint8_t coefficient7,
  uint8_t coefficient6,
  uint8_t coefficient8
)
{
  uint8_t coef1 = ((uint32_t)coefficient2 & 7U) << 5U | (uint32_t)coefficient1;
  uint8_t
  coef2 =
    (((uint32_t)coefficient4 & 1U) << 7U | (uint32_t)coefficient3 << 2U)
    | (uint32_t)coefficient2 >> 3U;
  uint8_t coef3 = ((uint32_t)coefficient5 & 15U) << 4U | (uint32_t)coefficient4 >> 1U;
  uint8_t
  coef4 =
    (((uint32_t)coefficient7 & 3U) << 6U | (uint32_t)coefficient6 << 1U)
    | (uint32_t)coefficient5 >> 4U;
  uint8_t coef5 = (uint32_t)coefficient8 << 3U | (uint32_t)coefficient7 >> 2U;
  return
    (
      (K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t){
        .fst = coef1,
        .snd = coef2,
        .thd = coef3,
        .f3 = coef4,
        .f4 = coef5
      }
    );
}

static inline void
libcrux_kyber_serialize_deserialize_to_reduced_ring_element(
  Eurydice_slice ring_element,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(ring_element, uint8_t, size_t) / (size_t)3U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(ring_element,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)3U,
            .end = i0 * (size_t)3U + (size_t)3U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
    int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
    int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
    re[(size_t)2U * i0] = (byte2 & (int32_t)15) << 8U | (byte1 & (int32_t)255);
    int32_t tmp = re[(size_t)2U * i0] % (int32_t)3329;
    re[(size_t)2U * i0] = tmp;
    re[(size_t)2U * i0 + (size_t)1U] = byte3 << 4U | (byte2 >> 4U & (int32_t)15);
    int32_t tmp0 = re[(size_t)2U * i0 + (size_t)1U] % (int32_t)3329;
    re[(size_t)2U * i0 + (size_t)1U] = tmp0;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

typedef struct K___int32_t_int32_t_int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
  int32_t thd;
  int32_t f3;
}
K___int32_t_int32_t_int32_t_int32_t;

static inline K___int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_10(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = (byte2 & (int32_t)3) << 8U | (byte1 & (int32_t)255);
  int32_t coefficient2 = (byte3 & (int32_t)15) << 6U | byte2 >> 2U;
  int32_t coefficient3 = (byte4 & (int32_t)63) << 4U | byte3 >> 4U;
  int32_t coefficient4 = byte5 << 2U | byte4 >> 6U;
  return
    (
      (K___int32_t_int32_t_int32_t_int32_t){
        .fst = coefficient1,
        .snd = coefficient2,
        .thd = coefficient3,
        .f3 = coefficient4
      }
    );
}

static inline void
libcrux_kyber_serialize_deserialize_then_decompress_10(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)5U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)5U,
            .end = i0 * (size_t)5U + (size_t)5U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
    int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
    int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
    int32_t byte4 = (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
    int32_t byte5 = (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
    K___int32_t_int32_t_int32_t_int32_t
    uu____0 = libcrux_kyber_serialize_decompress_coefficients_10(byte2, byte1, byte3, byte4, byte5);
    int32_t coefficient1 = uu____0.fst;
    int32_t coefficient2 = uu____0.snd;
    int32_t coefficient3 = uu____0.thd;
    int32_t coefficient4 = uu____0.f3;
    int32_t uu____1 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient1);
    re[(size_t)4U * i0] = uu____1;
    int32_t uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient2);
    re[(size_t)4U * i0 + (size_t)1U] = uu____2;
    int32_t uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient3);
    re[(size_t)4U * i0 + (size_t)2U] = uu____3;
    int32_t uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient4);
    re[(size_t)4U * i0 + (size_t)3U] = uu____4;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

typedef struct K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
  int32_t thd;
  int32_t f3;
  int32_t f4;
  int32_t f5;
  int32_t f6;
  int32_t f7;
}
K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t;

static inline K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_11(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte5,
  int32_t byte4,
  int32_t byte6,
  int32_t byte7,
  int32_t byte9,
  int32_t byte8,
  int32_t byte10,
  int32_t byte11
)
{
  int32_t coefficient1 = (byte2 & (int32_t)7) << 8U | byte1;
  int32_t coefficient2 = (byte3 & (int32_t)63) << 5U | byte2 >> 3U;
  int32_t coefficient3 = ((byte5 & (int32_t)1) << 10U | byte4 << 2U) | byte3 >> 6U;
  int32_t coefficient4 = (byte6 & (int32_t)15) << 7U | byte5 >> 1U;
  int32_t coefficient5 = (byte7 & (int32_t)127) << 4U | byte6 >> 4U;
  int32_t coefficient6 = ((byte9 & (int32_t)3) << 9U | byte8 << 1U) | byte7 >> 7U;
  int32_t coefficient7 = (byte10 & (int32_t)31) << 6U | byte9 >> 2U;
  int32_t coefficient8 = byte11 << 3U | byte10 >> 5U;
  return
    (
      (K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t){
        .fst = coefficient1,
        .snd = coefficient2,
        .thd = coefficient3,
        .f3 = coefficient4,
        .f4 = coefficient5,
        .f5 = coefficient6,
        .f6 = coefficient7,
        .f7 = coefficient8
      }
    );
}

static inline void
libcrux_kyber_serialize_deserialize_then_decompress_11(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)11U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)11U,
            .end = i0 * (size_t)11U + (size_t)11U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
    int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
    int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
    int32_t byte4 = (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
    int32_t byte5 = (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
    int32_t byte6 = (int32_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
    int32_t byte7 = (int32_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
    int32_t byte8 = (int32_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
    int32_t byte9 = (int32_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
    int32_t byte10 = (int32_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
    int32_t byte11 = (int32_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t);
    K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
    uu____0 =
      libcrux_kyber_serialize_decompress_coefficients_11(byte2,
        byte1,
        byte3,
        byte5,
        byte4,
        byte6,
        byte7,
        byte9,
        byte8,
        byte10,
        byte11);
    int32_t coefficient1 = uu____0.fst;
    int32_t coefficient2 = uu____0.snd;
    int32_t coefficient3 = uu____0.thd;
    int32_t coefficient4 = uu____0.f3;
    int32_t coefficient5 = uu____0.f4;
    int32_t coefficient6 = uu____0.f5;
    int32_t coefficient7 = uu____0.f6;
    int32_t coefficient8 = uu____0.f7;
    int32_t uu____1 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient1);
    re[(size_t)8U * i0] = uu____1;
    int32_t uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient2);
    re[(size_t)8U * i0 + (size_t)1U] = uu____2;
    int32_t uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient3);
    re[(size_t)8U * i0 + (size_t)2U] = uu____3;
    int32_t uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient4);
    re[(size_t)8U * i0 + (size_t)3U] = uu____4;
    int32_t uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient5);
    re[(size_t)8U * i0 + (size_t)4U] = uu____5;
    int32_t uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient6);
    re[(size_t)8U * i0 + (size_t)5U] = uu____6;
    int32_t uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient7);
    re[(size_t)8U * i0 + (size_t)6U] = uu____7;
    int32_t uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient8);
    re[(size_t)8U * i0 + (size_t)7U] = uu____8;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_ntt_ntt_at_layer_3328(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3328U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)3U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)3U,
            .end = i0 * (size_t)3U + (size_t)3U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
    int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
    int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
    re[(size_t)2U * i0] = (byte2 & (int32_t)15) << 8U | (byte1 & (int32_t)255);
    re[(size_t)2U * i0 + (size_t)1U] = byte3 << 4U | (byte2 >> 4U & (int32_t)15);
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline K___int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_4(uint8_t *byte)
{
  int32_t coefficient1 = (int32_t)Eurydice_bitand_pv_u8(byte, 15U);
  int32_t coefficient2 = (int32_t)((uint32_t)Eurydice_shr_pv_u8(byte, (int32_t)4) & 15U);
  return ((K___int32_t_int32_t){ .fst = coefficient1, .snd = coefficient2 });
}

static inline void
libcrux_kyber_serialize_deserialize_then_decompress_4(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for (size_t i = (size_t)0U; i < core_slice___Slice_T___len(serialized, uint8_t, size_t); i++)
  {
    size_t i0 = i;
    uint8_t *byte = &Eurydice_slice_index(serialized, i0, uint8_t, uint8_t);
    K___int32_t_int32_t uu____0 = libcrux_kyber_serialize_decompress_coefficients_4(byte);
    int32_t coefficient1 = uu____0.fst;
    int32_t coefficient2 = uu____0.snd;
    int32_t uu____1 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient1);
    re[(size_t)2U * i0] = uu____1;
    int32_t uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient2);
    re[(size_t)2U * i0 + (size_t)1U] = uu____2;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_5(
  int32_t byte1,
  int32_t byte2,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = byte1 & (int32_t)31;
  int32_t coefficient2 = (byte2 & (int32_t)3) << 3U | byte1 >> 5U;
  int32_t coefficient3 = byte2 >> 2U & (int32_t)31;
  int32_t coefficient4 = (byte3 & (int32_t)15) << 1U | byte2 >> 7U;
  int32_t coefficient5 = (byte4 & (int32_t)1) << 4U | byte3 >> 4U;
  int32_t coefficient6 = byte4 >> 1U & (int32_t)31;
  int32_t coefficient7 = (byte5 & (int32_t)7) << 2U | byte4 >> 6U;
  int32_t coefficient8 = byte5 >> 3U;
  return
    (
      (K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t){
        .fst = coefficient1,
        .snd = coefficient2,
        .thd = coefficient3,
        .f3 = coefficient4,
        .f4 = coefficient5,
        .f5 = coefficient6,
        .f6 = coefficient7,
        .f7 = coefficient8
      }
    );
}

static inline void
libcrux_kyber_serialize_deserialize_then_decompress_5(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)5U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)5U,
            .end = i0 * (size_t)5U + (size_t)5U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int32_t byte1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
    int32_t byte2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
    int32_t byte3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
    int32_t byte4 = (int32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
    int32_t byte5 = (int32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
    K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
    uu____0 = libcrux_kyber_serialize_decompress_coefficients_5(byte1, byte2, byte3, byte4, byte5);
    int32_t coefficient1 = uu____0.fst;
    int32_t coefficient2 = uu____0.snd;
    int32_t coefficient3 = uu____0.thd;
    int32_t coefficient4 = uu____0.f3;
    int32_t coefficient5 = uu____0.f4;
    int32_t coefficient6 = uu____0.f5;
    int32_t coefficient7 = uu____0.f6;
    int32_t coefficient8 = uu____0.f7;
    int32_t uu____1 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient1);
    re[(size_t)8U * i0] = uu____1;
    int32_t uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient2);
    re[(size_t)8U * i0 + (size_t)1U] = uu____2;
    int32_t uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient3);
    re[(size_t)8U * i0 + (size_t)2U] = uu____3;
    int32_t uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient4);
    re[(size_t)8U * i0 + (size_t)3U] = uu____4;
    int32_t uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient5);
    re[(size_t)8U * i0 + (size_t)4U] = uu____5;
    int32_t uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient6);
    re[(size_t)8U * i0 + (size_t)5U] = uu____6;
    int32_t uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient7);
    re[(size_t)8U * i0 + (size_t)6U] = uu____7;
    int32_t uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient8);
    re[(size_t)8U * i0 + (size_t)7U] = uu____8;
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
libcrux_kyber_serialize_compress_then_serialize_message(int32_t re[256U], uint8_t ret[32U])
{
  uint8_t serialized[32U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
        int32_t,
        size_t)
      / (size_t)8U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    coefficients =
      Eurydice_array_to_subslice((size_t)256U,
        re,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)8U,
            .end = i0 * (size_t)8U + (size_t)8U
          }
        ),
        int32_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_ops_range_Range__size_t
    iter =
      core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
          (core_ops_range_Range__size_t){
            .start = (size_t)0U,
            .end = core_slice___Slice_T___len(coefficients, int32_t, size_t)
          }
        ),
        core_ops_range_Range__size_t,
        core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____0 =
        core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
          size_t,
          core_option_Option__size_t);
      if (uu____0.tag == core_option_None)
      {
        break;
      }
      else
      {
        size_t j = uu____0.f0;
        int32_t *coefficient = &Eurydice_slice_index(coefficients, j, int32_t, int32_t);
        uint16_t
        coefficient0 = libcrux_kyber_arithmetic_to_unsigned_representative(coefficient[0U]);
        uint8_t
        coefficient_compressed = libcrux_kyber_compress_compress_message_coefficient(coefficient0);
        size_t uu____1 = i0;
        serialized[uu____1] =
          (uint32_t)serialized[uu____1]
          | (uint32_t)coefficient_compressed << (uint32_t)j;
      }
    }
  }
  memcpy(ret, serialized, (size_t)32U * sizeof (uint8_t));
}

#if defined(__cplusplus)
}
#endif

#define __internal_libcrux_kyber_common_H_DEFINED
#endif
