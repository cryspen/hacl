/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /nix/store/y2q40xi9l9rn3m3cs60q3ch1lf8z8bkv-ocaml4.14.1-eurydice-dirty/eurydice --config ../c.yaml ../../libcrux_ml_kem.llbc
  F* version: <unknown>
  KaRaMeL version: <unknown>
 */

#include "internal/libcrux_ml_kem.h"

#include "internal/core.h"

uint8_t libcrux_ml_kem_constant_time_ops_is_non_zero(uint8_t value)
{
  uint16_t value0 = (uint16_t)value;
  uint16_t uu____0 = value0;
  uint16_t
  result =
    (((uint32_t)uu____0 | (uint32_t)core_num__u16_7__wrapping_add(~value0, 1U)) & 0xFFFFU)
    >> 8U
    & 1U;
  return (uint8_t)result;
}

void
libcrux_ml_kem_constant_time_ops_select_shared_secret_in_constant_time(
  Eurydice_slice lhs,
  Eurydice_slice rhs,
  uint8_t selector,
  uint8_t ret[32U]
)
{
  uint8_t
  mask = core_num__u8_6__wrapping_sub(libcrux_ml_kem_constant_time_ops_is_non_zero(selector), 1U);
  uint8_t out[32U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = (uint32_t)Eurydice_slice_index(lhs, i0, uint8_t, uint8_t) & (uint32_t)mask;
    uint8_t *uu____1 = &Eurydice_slice_index(rhs, i0, uint8_t, uint8_t);
    out[i0] = (uint32_t)uu____0 | ((uint32_t)uu____1[0U] & (uint32_t)~mask);
  }
  memcpy(ret, out, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials___core__clone__Clone_for_libcrux_ml_kem__libcrux_polynomials__PortableVector__1__clone(
  int16_t (*self)[16U],
  int16_t ret[16U]
)
{
  memcpy(ret, self[0U], (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_zero(int16_t ret[16U])
{
  ret[0U] = (int16_t)0;
  ret[1U] = (int16_t)0;
  ret[2U] = (int16_t)0;
  ret[3U] = (int16_t)0;
  ret[4U] = (int16_t)0;
  ret[5U] = (int16_t)0;
  ret[6U] = (int16_t)0;
  ret[7U] = (int16_t)0;
  ret[8U] = (int16_t)0;
  ret[9U] = (int16_t)0;
  ret[10U] = (int16_t)0;
  ret[11U] = (int16_t)0;
  ret[12U] = (int16_t)0;
  ret[13U] = (int16_t)0;
  ret[14U] = (int16_t)0;
  ret[15U] = (int16_t)0;
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_to_i16_array(int16_t v[16U], int16_t ret[16U])
{
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___to_i16_array(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_to_i16_array(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

#define Ok 0
#define Err 1

typedef uint8_t Result__int16_t_16size_t__core_array_TryFromSliceError_tags;

typedef struct Result__int16_t_16size_t__core_array_TryFromSliceError_s
{
  Result__int16_t_16size_t__core_array_TryFromSliceError_tags tag;
  union {
    int16_t case_Ok[16U];
    core_array_TryFromSliceError case_Err;
  }
  val;
}
Result__int16_t_16size_t__core_array_TryFromSliceError;

static void
unwrap__int16_t_16size_t__core_array_TryFromSliceError(
  Result__int16_t_16size_t__core_array_TryFromSliceError self,
  int16_t ret[16U]
)
{
  if (self.tag == Ok)
  {
    int16_t f0[16U];
    memcpy(f0, self.val.case_Ok, (size_t)16U * sizeof (int16_t));
    memcpy(ret, f0, (size_t)16U * sizeof (int16_t));
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "unwrap not Ok");
    KRML_HOST_EXIT(255U);
  }
}

inline void
libcrux_ml_kem_libcrux_polynomials_from_i16_array(Eurydice_slice array, int16_t ret[16U])
{
  int16_t ret0[16U];
  /* FIXME: missed monomorphization */
  /* core_result_Result dst; */
  Result__int16_t_16size_t__core_array_TryFromSliceError dst;
  Eurydice_slice_to_array2(&dst,
    Eurydice_slice_subslice(array,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)16U }),
      int16_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    Eurydice_slice,
    int16_t [16U],
    void *);
  unwrap__int16_t_16size_t__core_array_TryFromSliceError(dst, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___from_i16_array(
  Eurydice_slice array,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_from_i16_array(array, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_add(int16_t lhs[16U], int16_t (*rhs)[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    lhs[uu____0] = lhs[uu____0] + rhs[0U][i0];
  }
  memcpy(ret, lhs, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(
  int16_t lhs[16U],
  int16_t (*rhs)[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_add(lhs, rhs, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_sub(int16_t lhs[16U], int16_t (*rhs)[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    lhs[uu____0] = lhs[uu____0] - rhs[0U][i0];
  }
  memcpy(ret, lhs, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(
  int16_t lhs[16U],
  int16_t (*rhs)[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_sub(lhs, rhs, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_multiply_by_constant(
  int16_t v[16U],
  int16_t c,
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    v[uu____0] = v[uu____0] * c;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___multiply_by_constant(
  int16_t v[16U],
  int16_t c,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_multiply_by_constant(v, c, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_bitwise_and_with_constant(
  int16_t v[16U],
  int16_t c,
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    size_t uu____0 = i0;
    v[uu____0] = v[uu____0] & c;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___bitwise_and_with_constant(
  int16_t v[16U],
  int16_t c,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_bitwise_and_with_constant(v, c, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_cond_subtract_3329(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    if (v[i0] >= (int16_t)3329)
    {
      size_t uu____0 = i0;
      v[uu____0] = v[uu____0] - (int16_t)3329;
    }
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___cond_subtract_3329(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_cond_subtract_3329(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

int16_t libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(int16_t value)
{
  int32_t
  t =
    (int32_t)value
    * LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_BARRETT_MULTIPLIER
    + (LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_BARRETT_R >> 1U);
  int16_t quotient = (int16_t)(t >> (uint32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_BARRETT_SHIFT);
  return value - quotient * LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
}

inline void libcrux_ml_kem_libcrux_polynomials_barrett_reduce(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t uu____0 = libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[i0]);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_barrett_reduce(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

int16_t libcrux_ml_kem_libcrux_polynomials_montgomery_reduce_element(int32_t value)
{
  int32_t
  k =
    (int32_t)(int16_t)value
    *
      (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R;
  int32_t
  k_times_modulus =
    (int32_t)(int16_t)k
    * (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
  int16_t
  c = (int16_t)(k_times_modulus >> (uint32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_MONTGOMERY_SHIFT);
  int16_t
  value_high = (int16_t)(value >> (uint32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_MONTGOMERY_SHIFT);
  return value_high - c;
}

inline int16_t
libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(int16_t fe, int16_t fer)
{
  return
    libcrux_ml_kem_libcrux_polynomials_montgomery_reduce_element((int32_t)fe * (int32_t)fer);
}

inline void
libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_by_constant(
  int16_t v[16U],
  int16_t c,
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t uu____0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[i0], c);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(
  int16_t v[16U],
  int16_t r,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_by_constant(v, r, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

uint8_t libcrux_ml_kem_libcrux_polynomials_compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

inline void libcrux_ml_kem_libcrux_polynomials_compress_1(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    uint8_t
    uu____0 = libcrux_ml_kem_libcrux_polynomials_compress_message_coefficient((uint16_t)v[i0]);
    v[i0] = (int16_t)uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress_1(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_compress_1(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline uint32_t
libcrux_ml_kem_libcrux_polynomials_get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

int16_t
libcrux_ml_kem_libcrux_polynomials_compress_ciphertext_coefficient(
  uint8_t coefficient_bits,
  uint16_t fe
)
{
  uint64_t compressed = (uint64_t)fe << (uint32_t)coefficient_bits;
  compressed = compressed + 1664ULL;
  compressed = compressed * 10321340ULL;
  compressed = compressed >> 35U;
  return
    (int16_t)libcrux_ml_kem_libcrux_polynomials_get_n_least_significant_bits(coefficient_bits,
      (uint32_t)compressed);
}

inline void
libcrux_ml_kem_libcrux_polynomials_ntt_layer_1_step(
  int16_t v[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t t = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[2U], zeta0);
  v[2U] = v[0U] - t;
  v[0U] = v[0U] + t;
  int16_t t0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[3U], zeta0);
  v[3U] = v[1U] - t0;
  v[1U] = v[1U] + t0;
  int16_t t1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[6U], zeta1);
  v[6U] = v[4U] - t1;
  v[4U] = v[4U] + t1;
  int16_t t2 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[7U], zeta1);
  v[7U] = v[5U] - t2;
  v[5U] = v[5U] + t2;
  int16_t
  t3 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)2U],
      zeta2);
  v[(size_t)8U + (size_t)2U] = v[(size_t)8U + (size_t)0U] - t3;
  v[(size_t)8U + (size_t)0U] = v[(size_t)8U + (size_t)0U] + t3;
  int16_t
  t4 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)3U],
      zeta2);
  v[(size_t)8U + (size_t)3U] = v[(size_t)8U + (size_t)1U] - t4;
  v[(size_t)8U + (size_t)1U] = v[(size_t)8U + (size_t)1U] + t4;
  int16_t
  t5 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)6U],
      zeta3);
  v[(size_t)8U + (size_t)6U] = v[(size_t)8U + (size_t)4U] - t5;
  v[(size_t)8U + (size_t)4U] = v[(size_t)8U + (size_t)4U] + t5;
  int16_t
  t6 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)7U],
      zeta3);
  v[(size_t)8U + (size_t)7U] = v[(size_t)8U + (size_t)5U] - t6;
  v[(size_t)8U + (size_t)5U] = v[(size_t)8U + (size_t)5U] + t6;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_1_step(
  int16_t a[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_ntt_layer_1_step(a, zeta0, zeta1, zeta2, zeta3, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_ntt_layer_2_step(
  int16_t v[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t ret[16U]
)
{
  int16_t t = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[4U], zeta0);
  v[4U] = v[0U] - t;
  v[0U] = v[0U] + t;
  int16_t t0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[5U], zeta0);
  v[5U] = v[1U] - t0;
  v[1U] = v[1U] + t0;
  int16_t t1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[6U], zeta0);
  v[6U] = v[2U] - t1;
  v[2U] = v[2U] + t1;
  int16_t t2 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[7U], zeta0);
  v[7U] = v[3U] - t2;
  v[3U] = v[3U] + t2;
  int16_t
  t3 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)4U],
      zeta1);
  v[(size_t)8U + (size_t)4U] = v[(size_t)8U + (size_t)0U] - t3;
  v[(size_t)8U + (size_t)0U] = v[(size_t)8U + (size_t)0U] + t3;
  int16_t
  t4 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)5U],
      zeta1);
  v[(size_t)8U + (size_t)5U] = v[(size_t)8U + (size_t)1U] - t4;
  v[(size_t)8U + (size_t)1U] = v[(size_t)8U + (size_t)1U] + t4;
  int16_t
  t5 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)6U],
      zeta1);
  v[(size_t)8U + (size_t)6U] = v[(size_t)8U + (size_t)2U] - t5;
  v[(size_t)8U + (size_t)2U] = v[(size_t)8U + (size_t)2U] + t5;
  int16_t
  t6 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[(size_t)8U + (size_t)7U],
      zeta1);
  v[(size_t)8U + (size_t)7U] = v[(size_t)8U + (size_t)3U] - t6;
  v[(size_t)8U + (size_t)3U] = v[(size_t)8U + (size_t)3U] + t6;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_2_step(
  int16_t a[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_ntt_layer_2_step(a, zeta0, zeta1, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_ntt_layer_3_step(
  int16_t v[16U],
  int16_t zeta,
  int16_t ret[16U]
)
{
  int16_t t = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[8U], zeta);
  v[8U] = v[0U] - t;
  v[0U] = v[0U] + t;
  int16_t t0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[9U], zeta);
  v[9U] = v[1U] - t0;
  v[1U] = v[1U] + t0;
  int16_t t1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[10U], zeta);
  v[10U] = v[2U] - t1;
  v[2U] = v[2U] + t1;
  int16_t t2 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[11U], zeta);
  v[11U] = v[3U] - t2;
  v[3U] = v[3U] + t2;
  int16_t t3 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[12U], zeta);
  v[12U] = v[4U] - t3;
  v[4U] = v[4U] + t3;
  int16_t t4 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[13U], zeta);
  v[13U] = v[5U] - t4;
  v[5U] = v[5U] + t4;
  int16_t t5 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[14U], zeta);
  v[14U] = v[6U] - t5;
  v[6U] = v[6U] + t5;
  int16_t t6 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(v[15U], zeta);
  v[15U] = v[7U] - t6;
  v[7U] = v[7U] + t6;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_3_step(
  int16_t a[16U],
  int16_t zeta,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_ntt_layer_3_step(a, zeta, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_1_step(
  int16_t v[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t a_minus_b = v[2U] - v[0U];
  int16_t uu____0 = libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[0U] + v[2U]);
  v[0U] = uu____0;
  int16_t
  uu____1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b, zeta0);
  v[2U] = uu____1;
  int16_t a_minus_b0 = v[3U] - v[1U];
  int16_t uu____2 = libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[1U] + v[3U]);
  v[1U] = uu____2;
  int16_t
  uu____3 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b0, zeta0);
  v[3U] = uu____3;
  int16_t a_minus_b1 = v[6U] - v[4U];
  int16_t uu____4 = libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[4U] + v[6U]);
  v[4U] = uu____4;
  int16_t
  uu____5 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b1, zeta1);
  v[6U] = uu____5;
  int16_t a_minus_b2 = v[7U] - v[5U];
  int16_t uu____6 = libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[5U] + v[7U]);
  v[5U] = uu____6;
  int16_t
  uu____7 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b2, zeta1);
  v[7U] = uu____7;
  int16_t a_minus_b3 = v[(size_t)8U + (size_t)2U] - v[(size_t)8U + (size_t)0U];
  int16_t
  uu____8 =
    libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[(size_t)8U
      + (size_t)0U]
      + v[(size_t)8U + (size_t)2U]);
  v[(size_t)8U + (size_t)0U] = uu____8;
  int16_t
  uu____9 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b3, zeta2);
  v[(size_t)8U + (size_t)2U] = uu____9;
  int16_t a_minus_b4 = v[(size_t)8U + (size_t)3U] - v[(size_t)8U + (size_t)1U];
  int16_t
  uu____10 =
    libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[(size_t)8U
      + (size_t)1U]
      + v[(size_t)8U + (size_t)3U]);
  v[(size_t)8U + (size_t)1U] = uu____10;
  int16_t
  uu____11 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b4, zeta2);
  v[(size_t)8U + (size_t)3U] = uu____11;
  int16_t a_minus_b5 = v[(size_t)8U + (size_t)6U] - v[(size_t)8U + (size_t)4U];
  int16_t
  uu____12 =
    libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[(size_t)8U
      + (size_t)4U]
      + v[(size_t)8U + (size_t)6U]);
  v[(size_t)8U + (size_t)4U] = uu____12;
  int16_t
  uu____13 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b5, zeta3);
  v[(size_t)8U + (size_t)6U] = uu____13;
  int16_t a_minus_b6 = v[(size_t)8U + (size_t)7U] - v[(size_t)8U + (size_t)5U];
  int16_t
  uu____14 =
    libcrux_ml_kem_libcrux_polynomials_barrett_reduce_element(v[(size_t)8U
      + (size_t)5U]
      + v[(size_t)8U + (size_t)7U]);
  v[(size_t)8U + (size_t)5U] = uu____14;
  int16_t
  uu____15 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b6, zeta3);
  v[(size_t)8U + (size_t)7U] = uu____15;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_1_step(
  int16_t a[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_1_step(a, zeta0, zeta1, zeta2, zeta3, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_2_step(
  int16_t v[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t ret[16U]
)
{
  int16_t a_minus_b = v[4U] - v[0U];
  v[0U] = v[0U] + v[4U];
  int16_t
  uu____0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b, zeta0);
  v[4U] = uu____0;
  int16_t a_minus_b0 = v[5U] - v[1U];
  v[1U] = v[1U] + v[5U];
  int16_t
  uu____1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b0, zeta0);
  v[5U] = uu____1;
  int16_t a_minus_b1 = v[6U] - v[2U];
  v[2U] = v[2U] + v[6U];
  int16_t
  uu____2 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b1, zeta0);
  v[6U] = uu____2;
  int16_t a_minus_b2 = v[7U] - v[3U];
  v[3U] = v[3U] + v[7U];
  int16_t
  uu____3 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b2, zeta0);
  v[7U] = uu____3;
  int16_t a_minus_b3 = v[(size_t)8U + (size_t)4U] - v[(size_t)8U + (size_t)0U];
  v[(size_t)8U + (size_t)0U] = v[(size_t)8U + (size_t)0U] + v[(size_t)8U + (size_t)4U];
  int16_t
  uu____4 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b3, zeta1);
  v[(size_t)8U + (size_t)4U] = uu____4;
  int16_t a_minus_b4 = v[(size_t)8U + (size_t)5U] - v[(size_t)8U + (size_t)1U];
  v[(size_t)8U + (size_t)1U] = v[(size_t)8U + (size_t)1U] + v[(size_t)8U + (size_t)5U];
  int16_t
  uu____5 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b4, zeta1);
  v[(size_t)8U + (size_t)5U] = uu____5;
  int16_t a_minus_b5 = v[(size_t)8U + (size_t)6U] - v[(size_t)8U + (size_t)2U];
  v[(size_t)8U + (size_t)2U] = v[(size_t)8U + (size_t)2U] + v[(size_t)8U + (size_t)6U];
  int16_t
  uu____6 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b5, zeta1);
  v[(size_t)8U + (size_t)6U] = uu____6;
  int16_t a_minus_b6 = v[(size_t)8U + (size_t)7U] - v[(size_t)8U + (size_t)3U];
  v[(size_t)8U + (size_t)3U] = v[(size_t)8U + (size_t)3U] + v[(size_t)8U + (size_t)7U];
  int16_t
  uu____7 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b6, zeta1);
  v[(size_t)8U + (size_t)7U] = uu____7;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_2_step(
  int16_t a[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_2_step(a, zeta0, zeta1, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_3_step(
  int16_t v[16U],
  int16_t zeta,
  int16_t ret[16U]
)
{
  int16_t a_minus_b = v[8U] - v[0U];
  v[0U] = v[0U] + v[8U];
  int16_t
  uu____0 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b, zeta);
  v[8U] = uu____0;
  int16_t a_minus_b0 = v[9U] - v[1U];
  v[1U] = v[1U] + v[9U];
  int16_t
  uu____1 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b0, zeta);
  v[9U] = uu____1;
  int16_t a_minus_b1 = v[10U] - v[2U];
  v[2U] = v[2U] + v[10U];
  int16_t
  uu____2 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b1, zeta);
  v[10U] = uu____2;
  int16_t a_minus_b2 = v[11U] - v[3U];
  v[3U] = v[3U] + v[11U];
  int16_t
  uu____3 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b2, zeta);
  v[11U] = uu____3;
  int16_t a_minus_b3 = v[12U] - v[4U];
  v[4U] = v[4U] + v[12U];
  int16_t
  uu____4 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b3, zeta);
  v[12U] = uu____4;
  int16_t a_minus_b4 = v[13U] - v[5U];
  v[5U] = v[5U] + v[13U];
  int16_t
  uu____5 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b4, zeta);
  v[13U] = uu____5;
  int16_t a_minus_b5 = v[14U] - v[6U];
  v[6U] = v[6U] + v[14U];
  int16_t
  uu____6 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b5, zeta);
  v[14U] = uu____6;
  int16_t a_minus_b6 = v[15U] - v[7U];
  v[7U] = v[7U] + v[15U];
  int16_t
  uu____7 = libcrux_ml_kem_libcrux_polynomials_montgomery_multiply_fe_by_fer(a_minus_b6, zeta);
  v[15U] = uu____7;
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_3_step(
  int16_t a[16U],
  int16_t zeta,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_inv_ntt_layer_3_step(a, zeta, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline K___int16_t_int16_t
libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(
  K___int16_t_int16_t _,
  K___int16_t_int16_t _0,
  int16_t zeta
)
{
  int16_t a0 = _.fst;
  int16_t a1 = _.snd;
  int16_t b0 = _0.fst;
  int16_t b1 = _0.snd;
  int32_t uu____0 = (int32_t)a0 * (int32_t)b0;
  int16_t
  uu____1 =
    libcrux_ml_kem_libcrux_polynomials_montgomery_reduce_element(uu____0
      +
        (int32_t)libcrux_ml_kem_libcrux_polynomials_montgomery_reduce_element((int32_t)a1
          * (int32_t)b1)
        * (int32_t)zeta);
  return
    (
      (K___int16_t_int16_t){
        .fst = uu____1,
        .snd = libcrux_ml_kem_libcrux_polynomials_montgomery_reduce_element((int32_t)a0
          * (int32_t)b1
          + (int32_t)a1 * (int32_t)b0)
      }
    );
}

inline void
libcrux_ml_kem_libcrux_polynomials_ntt_multiply(
  int16_t (*lhs)[16U],
  int16_t (*rhs)[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t out[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(out);
  K___int16_t_int16_t lit0;
  lit0.fst = lhs[0U][0U];
  lit0.snd = lhs[0U][1U];
  K___int16_t_int16_t lit1;
  lit1.fst = rhs[0U][0U];
  lit1.snd = rhs[0U][1U];
  K___int16_t_int16_t
  product = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit0, lit1, zeta0);
  out[0U] = product.fst;
  out[1U] = product.snd;
  K___int16_t_int16_t lit2;
  lit2.fst = lhs[0U][2U];
  lit2.snd = lhs[0U][3U];
  K___int16_t_int16_t lit3;
  lit3.fst = rhs[0U][2U];
  lit3.snd = rhs[0U][3U];
  K___int16_t_int16_t
  product0 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit2, lit3, -zeta0);
  out[2U] = product0.fst;
  out[3U] = product0.snd;
  K___int16_t_int16_t lit4;
  lit4.fst = lhs[0U][4U];
  lit4.snd = lhs[0U][5U];
  K___int16_t_int16_t lit5;
  lit5.fst = rhs[0U][4U];
  lit5.snd = rhs[0U][5U];
  K___int16_t_int16_t
  product1 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit4, lit5, zeta1);
  out[4U] = product1.fst;
  out[5U] = product1.snd;
  K___int16_t_int16_t lit6;
  lit6.fst = lhs[0U][6U];
  lit6.snd = lhs[0U][7U];
  K___int16_t_int16_t lit7;
  lit7.fst = rhs[0U][6U];
  lit7.snd = rhs[0U][7U];
  K___int16_t_int16_t
  product2 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit6, lit7, -zeta1);
  out[6U] = product2.fst;
  out[7U] = product2.snd;
  K___int16_t_int16_t lit8;
  lit8.fst = lhs[0U][(size_t)8U + (size_t)0U];
  lit8.snd = lhs[0U][(size_t)8U + (size_t)1U];
  K___int16_t_int16_t lit9;
  lit9.fst = rhs[0U][(size_t)8U + (size_t)0U];
  lit9.snd = rhs[0U][(size_t)8U + (size_t)1U];
  K___int16_t_int16_t
  product3 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit8, lit9, zeta2);
  out[(size_t)8U + (size_t)0U] = product3.fst;
  out[(size_t)8U + (size_t)1U] = product3.snd;
  K___int16_t_int16_t lit10;
  lit10.fst = lhs[0U][(size_t)8U + (size_t)2U];
  lit10.snd = lhs[0U][(size_t)8U + (size_t)3U];
  K___int16_t_int16_t lit11;
  lit11.fst = rhs[0U][(size_t)8U + (size_t)2U];
  lit11.snd = rhs[0U][(size_t)8U + (size_t)3U];
  K___int16_t_int16_t
  product4 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit10, lit11, -zeta2);
  out[(size_t)8U + (size_t)2U] = product4.fst;
  out[(size_t)8U + (size_t)3U] = product4.snd;
  K___int16_t_int16_t lit12;
  lit12.fst = lhs[0U][(size_t)8U + (size_t)4U];
  lit12.snd = lhs[0U][(size_t)8U + (size_t)5U];
  K___int16_t_int16_t lit13;
  lit13.fst = rhs[0U][(size_t)8U + (size_t)4U];
  lit13.snd = rhs[0U][(size_t)8U + (size_t)5U];
  K___int16_t_int16_t
  product5 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit12, lit13, zeta3);
  out[(size_t)8U + (size_t)4U] = product5.fst;
  out[(size_t)8U + (size_t)5U] = product5.snd;
  K___int16_t_int16_t lit14;
  lit14.fst = lhs[0U][(size_t)8U + (size_t)6U];
  lit14.snd = lhs[0U][(size_t)8U + (size_t)7U];
  K___int16_t_int16_t lit;
  lit.fst = rhs[0U][(size_t)8U + (size_t)6U];
  lit.snd = rhs[0U][(size_t)8U + (size_t)7U];
  K___int16_t_int16_t
  product6 = libcrux_ml_kem_libcrux_polynomials_ntt_multiply_binomials(lit14, lit, -zeta3);
  out[(size_t)8U + (size_t)6U] = product6.fst;
  out[(size_t)8U + (size_t)7U] = product6.snd;
  memcpy(ret, out, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_multiply(
  int16_t (*lhs)[16U],
  int16_t (*rhs)[16U],
  int16_t zeta0,
  int16_t zeta1,
  int16_t zeta2,
  int16_t zeta3,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_ntt_multiply(lhs, rhs, zeta0, zeta1, zeta2, zeta3, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_1(int16_t v[16U], uint8_t ret[2U])
{
  uint8_t result[2U] = { 0U };
  for (size_t i = (size_t)0U; i < (size_t)8U; i++)
  {
    size_t i0 = i;
    size_t uu____0 = (size_t)0U;
    result[uu____0] = (uint32_t)result[uu____0] | (uint32_t)(uint8_t)v[i0] << (uint32_t)i0;
  }
  for (size_t i = (size_t)8U; i < (size_t)16U; i++)
  {
    size_t i0 = i;
    size_t uu____1 = (size_t)1U;
    result[uu____1] =
      (uint32_t)result[uu____1]
      | (uint32_t)(uint8_t)v[i0] << (uint32_t)(i0 - (size_t)8U);
  }
  memcpy(ret, result, (size_t)2U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_1(
  int16_t a[16U],
  uint8_t ret[2U]
)
{
  uint8_t ret0[2U];
  libcrux_ml_kem_libcrux_polynomials_serialize_1(a, ret0);
  memcpy(ret, ret0, (size_t)2U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_1(Eurydice_slice v, int16_t ret[16U])
{
  int16_t result[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(result);
  for (size_t i = (size_t)0U; i < (size_t)8U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = &Eurydice_slice_index(v, (size_t)0U, uint8_t, uint8_t);
    result[i0] = (int16_t)((uint32_t)uu____0[0U] >> (uint32_t)i0 & 1U);
  }
  for
  (size_t
    i = (size_t)8U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    uint8_t *uu____1 = &Eurydice_slice_index(v, (size_t)1U, uint8_t, uint8_t);
    result[i0] = (int16_t)((uint32_t)uu____1[0U] >> (uint32_t)(i0 - (size_t)8U) & 1U);
  }
  memcpy(ret, result, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_1(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_1(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_4(int16_t v[16U], uint8_t ret[8U])
{
  uint8_t result[8U] = { 0U };
  result[0U] = (uint32_t)(uint8_t)v[1U] << 4U | (uint32_t)(uint8_t)v[0U];
  result[1U] = (uint32_t)(uint8_t)v[3U] << 4U | (uint32_t)(uint8_t)v[2U];
  result[2U] = (uint32_t)(uint8_t)v[5U] << 4U | (uint32_t)(uint8_t)v[4U];
  result[3U] = (uint32_t)(uint8_t)v[7U] << 4U | (uint32_t)(uint8_t)v[6U];
  result[4U] =
    (uint32_t)(uint8_t)v[(size_t)8U + (size_t)1U]
    << 4U
    | (uint32_t)(uint8_t)v[(size_t)8U + (size_t)0U];
  result[5U] =
    (uint32_t)(uint8_t)v[(size_t)8U + (size_t)3U]
    << 4U
    | (uint32_t)(uint8_t)v[(size_t)8U + (size_t)2U];
  result[6U] =
    (uint32_t)(uint8_t)v[(size_t)8U + (size_t)5U]
    << 4U
    | (uint32_t)(uint8_t)v[(size_t)8U + (size_t)4U];
  result[7U] =
    (uint32_t)(uint8_t)v[(size_t)8U + (size_t)7U]
    << 4U
    | (uint32_t)(uint8_t)v[(size_t)8U + (size_t)6U];
  memcpy(ret, result, (size_t)8U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_4(
  int16_t a[16U],
  uint8_t ret[8U]
)
{
  uint8_t ret0[8U];
  libcrux_ml_kem_libcrux_polynomials_serialize_4(a, ret0);
  memcpy(ret, ret0, (size_t)8U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_4(Eurydice_slice bytes, int16_t ret[16U])
{
  int16_t v[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(v);
  uint8_t *uu____0 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v[0U] = (int16_t)((uint32_t)uu____0[0U] & 15U);
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v[1U] = (int16_t)((uint32_t)uu____1[0U] >> 4U & 15U);
  uint8_t *uu____2 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v[2U] = (int16_t)((uint32_t)uu____2[0U] & 15U);
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v[3U] = (int16_t)((uint32_t)uu____3[0U] >> 4U & 15U);
  uint8_t *uu____4 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v[4U] = (int16_t)((uint32_t)uu____4[0U] & 15U);
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v[5U] = (int16_t)((uint32_t)uu____5[0U] >> 4U & 15U);
  uint8_t *uu____6 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v[6U] = (int16_t)((uint32_t)uu____6[0U] & 15U);
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v[7U] = (int16_t)((uint32_t)uu____7[0U] >> 4U & 15U);
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v[8U] = (int16_t)((uint32_t)uu____8[0U] & 15U);
  uint8_t *uu____9 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v[9U] = (int16_t)((uint32_t)uu____9[0U] >> 4U & 15U);
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  v[10U] = (int16_t)((uint32_t)uu____10[0U] & 15U);
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  v[11U] = (int16_t)((uint32_t)uu____11[0U] >> 4U & 15U);
  uint8_t *uu____12 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  v[12U] = (int16_t)((uint32_t)uu____12[0U] & 15U);
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  v[13U] = (int16_t)((uint32_t)uu____13[0U] >> 4U & 15U);
  uint8_t *uu____14 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  v[14U] = (int16_t)((uint32_t)uu____14[0U] & 15U);
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  v[15U] = (int16_t)((uint32_t)uu____15[0U] >> 4U & 15U);
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_4(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_4(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_5(int16_t v[16U], uint8_t ret[10U])
{
  uint8_t result[10U] = { 0U };
  result[0U] = (uint8_t)((v[1U] & (int16_t)7) << 5U | v[0U]);
  result[1U] = (uint8_t)(((v[3U] & (int16_t)1) << 7U | v[2U] << 2U) | v[1U] >> 3U);
  result[2U] = (uint8_t)((v[4U] & (int16_t)15) << 4U | v[3U] >> 1U);
  result[3U] = (uint8_t)(((v[6U] & (int16_t)3) << 6U | v[5U] << 1U) | v[4U] >> 4U);
  result[4U] = (uint8_t)(v[7U] << 3U | v[6U] >> 2U);
  result[5U] =
    (uint8_t)((v[(size_t)8U + (size_t)1U] & (int16_t)7) << 5U | v[(size_t)8U + (size_t)0U]);
  result[6U] =
    (uint8_t)(((v[(size_t)8U + (size_t)3U] & (int16_t)1) << 7U | v[(size_t)8U + (size_t)2U] << 2U)
    | v[(size_t)8U + (size_t)1U] >> 3U);
  result[7U] =
    (uint8_t)((v[(size_t)8U + (size_t)4U] & (int16_t)15) << 4U | v[(size_t)8U + (size_t)3U] >> 1U);
  result[8U] =
    (uint8_t)(((v[(size_t)8U + (size_t)6U] & (int16_t)3) << 6U | v[(size_t)8U + (size_t)5U] << 1U)
    | v[(size_t)8U + (size_t)4U] >> 4U);
  result[9U] = (uint8_t)(v[(size_t)8U + (size_t)7U] << 3U | v[(size_t)8U + (size_t)6U] >> 2U);
  memcpy(ret, result, (size_t)10U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_5(
  int16_t a[16U],
  uint8_t ret[10U]
)
{
  uint8_t ret0[10U];
  libcrux_ml_kem_libcrux_polynomials_serialize_5(a, ret0);
  memcpy(ret, ret0, (size_t)10U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_5(Eurydice_slice bytes, int16_t ret[16U])
{
  int16_t v[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(v);
  uint8_t *uu____0 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v[0U] = (int16_t)((uint32_t)uu____0[0U] & 31U);
  uint8_t
  uu____1 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & 3U) << 3U;
  uint8_t *uu____2 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  v[1U] = (int16_t)((uint32_t)uu____1 | (uint32_t)uu____2[0U] >> 5U);
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v[2U] = (int16_t)((uint32_t)uu____3[0U] >> 2U & 31U);
  uint8_t
  uu____4 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & 15U) << 1U;
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  v[3U] = (int16_t)((uint32_t)uu____4 | (uint32_t)uu____5[0U] >> 7U);
  uint8_t
  uu____6 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) & 1U) << 4U;
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  v[4U] = (int16_t)((uint32_t)uu____6 | (uint32_t)uu____7[0U] >> 4U);
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v[5U] = (int16_t)((uint32_t)uu____8[0U] >> 1U & 31U);
  uint8_t
  uu____9 = ((uint32_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) & 7U) << 2U;
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  v[6U] = (int16_t)((uint32_t)uu____9 | (uint32_t)uu____10[0U] >> 6U);
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  v[7U] = (int16_t)((uint32_t)uu____11[0U] >> 3U);
  uint8_t *uu____12 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)0U, uint8_t, uint8_t);
  v[8U] = (int16_t)((uint32_t)uu____12[0U] & 31U);
  uint8_t
  uu____13 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t) & 3U)
    << 3U;
  uint8_t *uu____14 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)0U, uint8_t, uint8_t);
  v[9U] = (int16_t)((uint32_t)uu____13 | (uint32_t)uu____14[0U] >> 5U);
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t);
  v[10U] = (int16_t)((uint32_t)uu____15[0U] >> 2U & 31U);
  uint8_t
  uu____16 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)2U, uint8_t, uint8_t) & 15U)
    << 1U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)1U, uint8_t, uint8_t);
  v[11U] = (int16_t)((uint32_t)uu____16 | (uint32_t)uu____17[0U] >> 7U);
  uint8_t
  uu____18 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t) & 1U)
    << 4U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)2U, uint8_t, uint8_t);
  v[12U] = (int16_t)((uint32_t)uu____18 | (uint32_t)uu____19[0U] >> 4U);
  uint8_t *uu____20 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t);
  v[13U] = (int16_t)((uint32_t)uu____20[0U] >> 1U & 31U);
  uint8_t
  uu____21 =
    ((uint32_t)Eurydice_slice_index(bytes, (size_t)5U + (size_t)4U, uint8_t, uint8_t) & 7U)
    << 2U;
  uint8_t *uu____22 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)3U, uint8_t, uint8_t);
  v[14U] = (int16_t)((uint32_t)uu____21 | (uint32_t)uu____22[0U] >> 6U);
  uint8_t *uu____23 = &Eurydice_slice_index(bytes, (size_t)5U + (size_t)4U, uint8_t, uint8_t);
  v[15U] = (int16_t)((uint32_t)uu____23[0U] >> 3U);
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_5(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_5(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_10(int16_t v[16U], uint8_t ret[20U])
{
  uint8_t result[20U] = { 0U };
  result[0U] = (uint8_t)(v[0U] & (int16_t)255);
  result[1U] =
    (uint32_t)(uint8_t)(v[1U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v[0U] >> 8U & (int16_t)3);
  result[2U] =
    (uint32_t)(uint8_t)(v[2U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v[1U] >> 6U & (int16_t)15);
  result[3U] =
    (uint32_t)(uint8_t)(v[3U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v[2U] >> 4U & (int16_t)63);
  result[4U] = (uint8_t)(v[3U] >> 2U & (int16_t)255);
  result[5U] = (uint8_t)(v[4U] & (int16_t)255);
  result[6U] =
    (uint32_t)(uint8_t)(v[5U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v[4U] >> 8U & (int16_t)3);
  result[7U] =
    (uint32_t)(uint8_t)(v[6U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v[5U] >> 6U & (int16_t)15);
  result[8U] =
    (uint32_t)(uint8_t)(v[7U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v[6U] >> 4U & (int16_t)63);
  result[9U] = (uint8_t)(v[7U] >> 2U & (int16_t)255);
  result[10U] = (uint8_t)(v[(size_t)8U + (size_t)0U] & (int16_t)255);
  result[11U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)1U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)0U] >> 8U & (int16_t)3);
  result[12U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)2U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)1U] >> 6U & (int16_t)15);
  result[13U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)3U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)2U] >> 4U & (int16_t)63);
  result[14U] = (uint8_t)(v[(size_t)8U + (size_t)3U] >> 2U & (int16_t)255);
  result[15U] = (uint8_t)(v[(size_t)8U + (size_t)4U] & (int16_t)255);
  result[16U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)5U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)4U] >> 8U & (int16_t)3);
  result[17U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)6U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)5U] >> 6U & (int16_t)15);
  result[18U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)7U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)6U] >> 4U & (int16_t)63);
  result[19U] = (uint8_t)(v[(size_t)8U + (size_t)7U] >> 2U & (int16_t)255);
  memcpy(ret, result, (size_t)20U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_10(
  int16_t a[16U],
  uint8_t ret[20U]
)
{
  uint8_t ret0[20U];
  libcrux_ml_kem_libcrux_polynomials_serialize_10(a, ret0);
  memcpy(ret, ret0, (size_t)20U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_10(Eurydice_slice bytes, int16_t ret[16U])
{
  int16_t result[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(result);
  int16_t
  uu____0 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  result[0U] = uu____0 | ((int16_t)uu____1[0U] & (int16_t)255);
  int16_t
  uu____2 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & (int16_t)15)
    << 6U;
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  result[1U] = uu____2 | (int16_t)uu____3[0U] >> 2U;
  int16_t
  uu____4 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) & (int16_t)63)
    << 4U;
  uint8_t *uu____5 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  result[2U] = uu____4 | (int16_t)uu____5[0U] >> 4U;
  int16_t uu____6 = (int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____7 = &Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  result[3U] = uu____6 | (int16_t)uu____7[0U] >> 6U;
  int16_t
  uu____8 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____9 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  result[4U] = uu____8 | ((int16_t)uu____9[0U] & (int16_t)255);
  int16_t
  uu____10 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t) & (int16_t)15)
    << 6U;
  uint8_t *uu____11 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  result[5U] = uu____10 | (int16_t)uu____11[0U] >> 2U;
  int16_t
  uu____12 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t) & (int16_t)63)
    << 4U;
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  result[6U] = uu____12 | (int16_t)uu____13[0U] >> 4U;
  int16_t uu____14 = (int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  result[7U] = uu____14 | (int16_t)uu____15[0U] >> 6U;
  int16_t
  uu____16 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)1U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)0U, uint8_t, uint8_t);
  result[8U] = uu____16 | ((int16_t)uu____17[0U] & (int16_t)255);
  int16_t
  uu____18 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)2U, uint8_t, uint8_t)
    & (int16_t)15)
    << 6U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)1U, uint8_t, uint8_t);
  result[9U] = uu____18 | (int16_t)uu____19[0U] >> 2U;
  int16_t
  uu____20 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)3U, uint8_t, uint8_t)
    & (int16_t)63)
    << 4U;
  uint8_t *uu____21 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)2U, uint8_t, uint8_t);
  result[10U] = uu____20 | (int16_t)uu____21[0U] >> 4U;
  int16_t
  uu____22 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)4U, uint8_t, uint8_t)
    << 2U;
  uint8_t *uu____23 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)3U, uint8_t, uint8_t);
  result[11U] = uu____22 | (int16_t)uu____23[0U] >> 6U;
  int16_t
  uu____24 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)6U, uint8_t, uint8_t) & (int16_t)3)
    << 8U;
  uint8_t *uu____25 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)5U, uint8_t, uint8_t);
  result[12U] = uu____24 | ((int16_t)uu____25[0U] & (int16_t)255);
  int16_t
  uu____26 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)7U, uint8_t, uint8_t)
    & (int16_t)15)
    << 6U;
  uint8_t *uu____27 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)6U, uint8_t, uint8_t);
  result[13U] = uu____26 | (int16_t)uu____27[0U] >> 2U;
  int16_t
  uu____28 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)8U, uint8_t, uint8_t)
    & (int16_t)63)
    << 4U;
  uint8_t *uu____29 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)7U, uint8_t, uint8_t);
  result[14U] = uu____28 | (int16_t)uu____29[0U] >> 4U;
  int16_t
  uu____30 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)10U + (size_t)9U, uint8_t, uint8_t)
    << 2U;
  uint8_t *uu____31 = &Eurydice_slice_index(bytes, (size_t)10U + (size_t)8U, uint8_t, uint8_t);
  result[15U] = uu____30 | (int16_t)uu____31[0U] >> 6U;
  memcpy(ret, result, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_10(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_10(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_11(int16_t v[16U], uint8_t ret[22U])
{
  uint8_t result[22U] = { 0U };
  result[0U] = (uint8_t)v[0U];
  result[1U] = (uint32_t)(uint8_t)(v[1U] & (int16_t)31) << 3U | (uint32_t)(uint8_t)(v[0U] >> 8U);
  result[2U] = (uint32_t)(uint8_t)(v[2U] & (int16_t)3) << 6U | (uint32_t)(uint8_t)(v[1U] >> 5U);
  result[3U] = (uint8_t)(v[2U] >> 2U & (int16_t)255);
  result[4U] =
    (uint32_t)(uint8_t)(v[3U] & (int16_t)127)
    << 1U
    | (uint32_t)(uint8_t)(v[2U] >> 10U);
  result[5U] = (uint32_t)(uint8_t)(v[4U] & (int16_t)15) << 4U | (uint32_t)(uint8_t)(v[3U] >> 7U);
  result[6U] = (uint32_t)(uint8_t)(v[5U] & (int16_t)1) << 7U | (uint32_t)(uint8_t)(v[4U] >> 4U);
  result[7U] = (uint8_t)(v[5U] >> 1U & (int16_t)255);
  result[8U] = (uint32_t)(uint8_t)(v[6U] & (int16_t)63) << 2U | (uint32_t)(uint8_t)(v[5U] >> 9U);
  result[9U] = (uint32_t)(uint8_t)(v[7U] & (int16_t)7) << 5U | (uint32_t)(uint8_t)(v[6U] >> 6U);
  result[10U] = (uint8_t)(v[7U] >> 3U);
  result[11U] = (uint8_t)v[(size_t)8U + (size_t)0U];
  result[12U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)1U] & (int16_t)31)
    << 3U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)0U] >> 8U);
  result[13U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)2U] & (int16_t)3)
    << 6U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)1U] >> 5U);
  result[14U] = (uint8_t)(v[(size_t)8U + (size_t)2U] >> 2U & (int16_t)255);
  result[15U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)3U] & (int16_t)127)
    << 1U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)2U] >> 10U);
  result[16U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)4U] & (int16_t)15)
    << 4U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)3U] >> 7U);
  result[17U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)5U] & (int16_t)1)
    << 7U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)4U] >> 4U);
  result[18U] = (uint8_t)(v[(size_t)8U + (size_t)5U] >> 1U & (int16_t)255);
  result[19U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)6U] & (int16_t)63)
    << 2U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)5U] >> 9U);
  result[20U] =
    (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)7U] & (int16_t)7)
    << 5U
    | (uint32_t)(uint8_t)(v[(size_t)8U + (size_t)6U] >> 6U);
  result[21U] = (uint8_t)(v[(size_t)8U + (size_t)7U] >> 3U);
  memcpy(ret, result, (size_t)22U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_11(
  int16_t a[16U],
  uint8_t ret[22U]
)
{
  uint8_t ret0[22U];
  libcrux_ml_kem_libcrux_polynomials_serialize_11(a, ret0);
  memcpy(ret, ret0, (size_t)22U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_11(Eurydice_slice bytes, int16_t ret[16U])
{
  int16_t result[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(result);
  int16_t
  uu____0 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t) & (int16_t)7)
    << 8U;
  uint8_t *uu____1 = &Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  result[0U] = uu____0 | (int16_t)uu____1[0U];
  int16_t
  uu____2 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t) & (int16_t)63)
    << 5U;
  uint8_t *uu____3 = &Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  result[1U] = uu____2 | (int16_t)uu____3[0U] >> 3U;
  int16_t
  uu____4 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t) & (int16_t)1)
    << 10U;
  int16_t
  uu____5 = uu____4 | (int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____6 = &Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  result[2U] = uu____5 | (int16_t)uu____6[0U] >> 6U;
  int16_t
  uu____7 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t) & (int16_t)15)
    << 7U;
  uint8_t *uu____8 = &Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  result[3U] = uu____7 | (int16_t)uu____8[0U] >> 1U;
  int16_t
  uu____9 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t) & (int16_t)127)
    << 4U;
  uint8_t *uu____10 = &Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  result[4U] = uu____9 | (int16_t)uu____10[0U] >> 4U;
  int16_t
  uu____11 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t) & (int16_t)3)
    << 9U;
  int16_t
  uu____12 = uu____11 | (int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t) << 1U;
  uint8_t *uu____13 = &Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  result[5U] = uu____12 | (int16_t)uu____13[0U] >> 7U;
  int16_t
  uu____14 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t) & (int16_t)31)
    << 6U;
  uint8_t *uu____15 = &Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  result[6U] = uu____14 | (int16_t)uu____15[0U] >> 2U;
  int16_t uu____16 = (int16_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t) << 3U;
  uint8_t *uu____17 = &Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
  result[7U] = uu____16 | (int16_t)uu____17[0U] >> 5U;
  int16_t
  uu____18 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)1U, uint8_t, uint8_t) & (int16_t)7)
    << 8U;
  uint8_t *uu____19 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)0U, uint8_t, uint8_t);
  result[8U] = uu____18 | (int16_t)uu____19[0U];
  int16_t
  uu____20 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)2U, uint8_t, uint8_t)
    & (int16_t)63)
    << 5U;
  uint8_t *uu____21 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)1U, uint8_t, uint8_t);
  result[9U] = uu____20 | (int16_t)uu____21[0U] >> 3U;
  int16_t
  uu____22 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)4U, uint8_t, uint8_t) & (int16_t)1)
    << 10U;
  int16_t
  uu____23 =
    uu____22
    | (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)3U, uint8_t, uint8_t) << 2U;
  uint8_t *uu____24 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)2U, uint8_t, uint8_t);
  result[10U] = uu____23 | (int16_t)uu____24[0U] >> 6U;
  int16_t
  uu____25 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)5U, uint8_t, uint8_t)
    & (int16_t)15)
    << 7U;
  uint8_t *uu____26 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)4U, uint8_t, uint8_t);
  result[11U] = uu____25 | (int16_t)uu____26[0U] >> 1U;
  int16_t
  uu____27 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)6U, uint8_t, uint8_t)
    & (int16_t)127)
    << 4U;
  uint8_t *uu____28 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)5U, uint8_t, uint8_t);
  result[12U] = uu____27 | (int16_t)uu____28[0U] >> 4U;
  int16_t
  uu____29 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)8U, uint8_t, uint8_t) & (int16_t)3)
    << 9U;
  int16_t
  uu____30 =
    uu____29
    | (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)7U, uint8_t, uint8_t) << 1U;
  uint8_t *uu____31 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)6U, uint8_t, uint8_t);
  result[13U] = uu____30 | (int16_t)uu____31[0U] >> 7U;
  int16_t
  uu____32 =
    ((int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)9U, uint8_t, uint8_t)
    & (int16_t)31)
    << 6U;
  uint8_t *uu____33 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)8U, uint8_t, uint8_t);
  result[14U] = uu____32 | (int16_t)uu____33[0U] >> 2U;
  int16_t
  uu____34 =
    (int16_t)Eurydice_slice_index(bytes, (size_t)11U + (size_t)10U, uint8_t, uint8_t)
    << 3U;
  uint8_t *uu____35 = &Eurydice_slice_index(bytes, (size_t)11U + (size_t)9U, uint8_t, uint8_t);
  result[15U] = uu____34 | (int16_t)uu____35[0U] >> 5U;
  memcpy(ret, result, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_11(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_11(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void libcrux_ml_kem_libcrux_polynomials_serialize_12(int16_t v[16U], uint8_t ret[24U])
{
  uint8_t result[24U] = { 0U };
  result[0U] = (uint8_t)(v[0U] & (int16_t)255);
  result[1U] = (uint8_t)(v[0U] >> 8U | (v[1U] & (int16_t)15) << 4U);
  result[2U] = (uint8_t)(v[1U] >> 4U & (int16_t)255);
  result[3U] = (uint8_t)(v[2U] & (int16_t)255);
  result[4U] = (uint8_t)(v[2U] >> 8U | (v[3U] & (int16_t)15) << 4U);
  result[5U] = (uint8_t)(v[3U] >> 4U & (int16_t)255);
  result[6U] = (uint8_t)(v[4U] & (int16_t)255);
  result[7U] = (uint8_t)(v[4U] >> 8U | (v[5U] & (int16_t)15) << 4U);
  result[8U] = (uint8_t)(v[5U] >> 4U & (int16_t)255);
  result[9U] = (uint8_t)(v[6U] & (int16_t)255);
  result[10U] = (uint8_t)(v[6U] >> 8U | (v[7U] & (int16_t)15) << 4U);
  result[11U] = (uint8_t)(v[7U] >> 4U & (int16_t)255);
  result[12U] = (uint8_t)(v[(size_t)8U + (size_t)0U] & (int16_t)255);
  result[13U] =
    (uint8_t)(v[(size_t)8U + (size_t)0U] >> 8U | (v[(size_t)8U + (size_t)1U] & (int16_t)15) << 4U);
  result[14U] = (uint8_t)(v[(size_t)8U + (size_t)1U] >> 4U & (int16_t)255);
  result[15U] = (uint8_t)(v[(size_t)8U + (size_t)2U] & (int16_t)255);
  result[16U] =
    (uint8_t)(v[(size_t)8U + (size_t)2U] >> 8U | (v[(size_t)8U + (size_t)3U] & (int16_t)15) << 4U);
  result[17U] = (uint8_t)(v[(size_t)8U + (size_t)3U] >> 4U & (int16_t)255);
  result[18U] = (uint8_t)(v[(size_t)8U + (size_t)4U] & (int16_t)255);
  result[19U] =
    (uint8_t)(v[(size_t)8U + (size_t)4U] >> 8U | (v[(size_t)8U + (size_t)5U] & (int16_t)15) << 4U);
  result[20U] = (uint8_t)(v[(size_t)8U + (size_t)5U] >> 4U & (int16_t)255);
  result[21U] = (uint8_t)(v[(size_t)8U + (size_t)6U] & (int16_t)255);
  result[22U] =
    (uint8_t)(v[(size_t)8U + (size_t)6U] >> 8U | (v[(size_t)8U + (size_t)7U] & (int16_t)15) << 4U);
  result[23U] = (uint8_t)(v[(size_t)8U + (size_t)7U] >> 4U & (int16_t)255);
  memcpy(ret, result, (size_t)24U * sizeof (uint8_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_12(
  int16_t a[16U],
  uint8_t ret[24U]
)
{
  uint8_t ret0[24U];
  libcrux_ml_kem_libcrux_polynomials_serialize_12(a, ret0);
  memcpy(ret, ret0, (size_t)24U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_deserialize_12(Eurydice_slice bytes, int16_t ret[16U])
{
  int16_t re[16U];
  libcrux_ml_kem_libcrux_polynomials_zero(re);
  int16_t byte0 = (int16_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
  int16_t byte1 = (int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
  int16_t byte2 = (int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
  int16_t byte3 = (int16_t)Eurydice_slice_index(bytes, (size_t)3U, uint8_t, uint8_t);
  int16_t byte4 = (int16_t)Eurydice_slice_index(bytes, (size_t)4U, uint8_t, uint8_t);
  int16_t byte5 = (int16_t)Eurydice_slice_index(bytes, (size_t)5U, uint8_t, uint8_t);
  int16_t byte6 = (int16_t)Eurydice_slice_index(bytes, (size_t)6U, uint8_t, uint8_t);
  int16_t byte7 = (int16_t)Eurydice_slice_index(bytes, (size_t)7U, uint8_t, uint8_t);
  int16_t byte8 = (int16_t)Eurydice_slice_index(bytes, (size_t)8U, uint8_t, uint8_t);
  int16_t byte9 = (int16_t)Eurydice_slice_index(bytes, (size_t)9U, uint8_t, uint8_t);
  int16_t byte10 = (int16_t)Eurydice_slice_index(bytes, (size_t)10U, uint8_t, uint8_t);
  int16_t byte11 = (int16_t)Eurydice_slice_index(bytes, (size_t)11U, uint8_t, uint8_t);
  re[0U] = (byte1 & (int16_t)15) << 8U | (byte0 & (int16_t)255);
  re[1U] = byte2 << 4U | (byte1 >> 4U & (int16_t)15);
  re[2U] = (byte4 & (int16_t)15) << 8U | (byte3 & (int16_t)255);
  re[3U] = byte5 << 4U | (byte4 >> 4U & (int16_t)15);
  re[4U] = (byte7 & (int16_t)15) << 8U | (byte6 & (int16_t)255);
  re[5U] = byte8 << 4U | (byte7 >> 4U & (int16_t)15);
  re[6U] = (byte10 & (int16_t)15) << 8U | (byte9 & (int16_t)255);
  re[7U] = byte11 << 4U | (byte10 >> 4U & (int16_t)15);
  int16_t byte12 = (int16_t)Eurydice_slice_index(bytes, (size_t)12U, uint8_t, uint8_t);
  int16_t byte13 = (int16_t)Eurydice_slice_index(bytes, (size_t)13U, uint8_t, uint8_t);
  int16_t byte14 = (int16_t)Eurydice_slice_index(bytes, (size_t)14U, uint8_t, uint8_t);
  int16_t byte15 = (int16_t)Eurydice_slice_index(bytes, (size_t)15U, uint8_t, uint8_t);
  int16_t byte16 = (int16_t)Eurydice_slice_index(bytes, (size_t)16U, uint8_t, uint8_t);
  int16_t byte17 = (int16_t)Eurydice_slice_index(bytes, (size_t)17U, uint8_t, uint8_t);
  int16_t byte18 = (int16_t)Eurydice_slice_index(bytes, (size_t)18U, uint8_t, uint8_t);
  int16_t byte19 = (int16_t)Eurydice_slice_index(bytes, (size_t)19U, uint8_t, uint8_t);
  int16_t byte20 = (int16_t)Eurydice_slice_index(bytes, (size_t)20U, uint8_t, uint8_t);
  int16_t byte21 = (int16_t)Eurydice_slice_index(bytes, (size_t)21U, uint8_t, uint8_t);
  int16_t byte22 = (int16_t)Eurydice_slice_index(bytes, (size_t)22U, uint8_t, uint8_t);
  int16_t byte23 = (int16_t)Eurydice_slice_index(bytes, (size_t)23U, uint8_t, uint8_t);
  re[8U] = (byte13 & (int16_t)15) << 8U | (byte12 & (int16_t)255);
  re[9U] = byte14 << 4U | (byte13 >> 4U & (int16_t)15);
  re[10U] = (byte16 & (int16_t)15) << 8U | (byte15 & (int16_t)255);
  re[11U] = byte17 << 4U | (byte16 >> 4U & (int16_t)15);
  re[12U] = (byte19 & (int16_t)15) << 8U | (byte18 & (int16_t)255);
  re[13U] = byte20 << 4U | (byte19 >> 4U & (int16_t)15);
  re[14U] = (byte22 & (int16_t)15) << 8U | (byte21 & (int16_t)255);
  re[15U] = byte23 << 4U | (byte22 >> 4U & (int16_t)15);
  memcpy(ret, re, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_12(
  Eurydice_slice a,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_deserialize_12(a, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline size_t
libcrux_ml_kem_libcrux_polynomials_rej_sample(Eurydice_slice a, Eurydice_slice result)
{
  size_t sampled = (size_t)0U;
  core_slice_iter_Chunks
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(core_slice___Slice_T___chunks(a,
        (size_t)3U,
        uint8_t,
        core_slice_iter_Chunks),
      core_slice_iter_Chunks,
      core_slice_iter_Chunks);
  while (true)
  {
    core_option_Option__Eurydice_slice_uint8_t
    uu____0 =
      core_slice_iter___core__iter__traits__iterator__Iterator_for_core__slice__iter__Chunks__a__T___70__next(&iter,
        uint8_t,
        core_option_Option__Eurydice_slice_uint8_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      Eurydice_slice bytes = uu____0.f0;
      int16_t b1 = (int16_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
      int16_t b2 = (int16_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
      int16_t b3 = (int16_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
      int16_t d1 = (b2 & (int16_t)15) << 8U | b1;
      int16_t d2 = b3 << 4U | b2 >> 4U;
      bool uu____1;
      if (d1 < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS)
      {
        uu____1 = sampled < (size_t)16U;
      }
      else
      {
        uu____1 = false;
      }
      if (uu____1)
      {
        int16_t uu____2 = d1;
        Eurydice_slice_index(result, sampled, int16_t, int16_t) = uu____2;
        sampled++;
      }
      bool uu____3;
      if (d2 < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS)
      {
        uu____3 = sampled < (size_t)16U;
      }
      else
      {
        uu____3 = false;
      }
      if (uu____3)
      {
        int16_t uu____4 = d2;
        Eurydice_slice_index(result, sampled, int16_t, int16_t) = uu____4;
        sampled++;
      }
    }
  }
  return sampled;
}

size_t
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(
  Eurydice_slice a,
  Eurydice_slice out
)
{
  return libcrux_ml_kem_libcrux_polynomials_rej_sample(a, out);
}

const
int16_t
libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[128U] =
  {
    (int16_t)-1044, (int16_t)-758, (int16_t)-359, (int16_t)-1517, (int16_t)1493, (int16_t)1422,
    (int16_t)287, (int16_t)202, (int16_t)-171, (int16_t)622, (int16_t)1577, (int16_t)182,
    (int16_t)962, (int16_t)-1202, (int16_t)-1474, (int16_t)1468, (int16_t)573, (int16_t)-1325,
    (int16_t)264, (int16_t)383, (int16_t)-829, (int16_t)1458, (int16_t)-1602, (int16_t)-130,
    (int16_t)-681, (int16_t)1017, (int16_t)732, (int16_t)608, (int16_t)-1542, (int16_t)411,
    (int16_t)-205, (int16_t)-1571, (int16_t)1223, (int16_t)652, (int16_t)-552, (int16_t)1015,
    (int16_t)-1293, (int16_t)1491, (int16_t)-282, (int16_t)-1544, (int16_t)516, (int16_t)-8,
    (int16_t)-320, (int16_t)-666, (int16_t)-1618, (int16_t)-1162, (int16_t)126, (int16_t)1469,
    (int16_t)-853, (int16_t)-90, (int16_t)-271, (int16_t)830, (int16_t)107, (int16_t)-1421,
    (int16_t)-247, (int16_t)-951, (int16_t)-398, (int16_t)961, (int16_t)-1508, (int16_t)-725,
    (int16_t)448, (int16_t)-1065, (int16_t)677, (int16_t)-1275, (int16_t)-1103, (int16_t)430,
    (int16_t)555, (int16_t)843, (int16_t)-1251, (int16_t)871, (int16_t)1550, (int16_t)105,
    (int16_t)422, (int16_t)587, (int16_t)177, (int16_t)-235, (int16_t)-291, (int16_t)-460,
    (int16_t)1574, (int16_t)1653, (int16_t)-246, (int16_t)778, (int16_t)1159, (int16_t)-147,
    (int16_t)-777, (int16_t)1483, (int16_t)-602, (int16_t)1119, (int16_t)-1590, (int16_t)644,
    (int16_t)-872, (int16_t)349, (int16_t)418, (int16_t)329, (int16_t)-156, (int16_t)-75,
    (int16_t)817, (int16_t)1097, (int16_t)603, (int16_t)610, (int16_t)1322, (int16_t)-1285,
    (int16_t)-1465, (int16_t)384, (int16_t)-1215, (int16_t)-136, (int16_t)1218, (int16_t)-1335,
    (int16_t)-874, (int16_t)220, (int16_t)-1187, (int16_t)-1659, (int16_t)-1185, (int16_t)-1530,
    (int16_t)-1278, (int16_t)794, (int16_t)-1510, (int16_t)-854, (int16_t)-870, (int16_t)478,
    (int16_t)-108, (int16_t)-308, (int16_t)996, (int16_t)991, (int16_t)958, (int16_t)-1460,
    (int16_t)1522, (int16_t)1628
  };

void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret0);
  /* FIXME: assignment with array LHS */
  
  /* ret[0U] = ret0; */ memcpy(ret[0U], ret0, sizeof(int16_t) * 16);
  int16_t ret1[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret1);
  /* ret[1U] = ret1; */ memcpy(ret[1U], ret1, sizeof(int16_t) * 16);
  int16_t ret2[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret2);
  /* ret[2U] = ret2; */ memcpy(ret[2U], ret2, sizeof(int16_t) * 16);
  int16_t ret3[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret3);
  /* ret[3U] = ret3; */ memcpy(ret[3U], ret3, sizeof(int16_t) * 16);
  int16_t ret4[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret4);
  /* ret[4U] = ret4; */ memcpy(ret[4U], ret4, sizeof(int16_t) * 16);
  int16_t ret5[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret5);
  /* ret[5U] = ret5; */ memcpy(ret[5U], ret5, sizeof(int16_t) * 16);
  int16_t ret6[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret6);
  /* ret[6U] = ret6; */ memcpy(ret[6U], ret6, sizeof(int16_t) * 16);
  int16_t ret7[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret7);
  /* ret[7U] = ret7; */ memcpy(ret[7U], ret7, sizeof(int16_t) * 16);
  int16_t ret8[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret8);
  /* ret[8U] = ret8; */ memcpy(ret[8U], ret8, sizeof(int16_t) * 16);
  int16_t ret9[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret9);
  /* ret[9U] = ret9; */ memcpy(ret[9U], ret9, sizeof(int16_t) * 16);
  int16_t ret10[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret10);
  /* ret[10U] = ret10; */ memcpy(ret[10U], ret10, sizeof(int16_t) * 16);
  int16_t ret11[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret11);
  /* ret[11U] = ret11; */ memcpy(ret[11U], ret11, sizeof(int16_t) * 16);
  int16_t ret12[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret12);
  /* ret[12U] = ret12; */ memcpy(ret[12U], ret12, sizeof(int16_t) * 16);
  int16_t ret13[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret13);
  /* ret[13U] = ret13; */ memcpy(ret[13U], ret13, sizeof(int16_t) * 16);
  int16_t ret14[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret14);
  /* ret[14U] = ret14; */ memcpy(ret[14U], ret14, sizeof(int16_t) * 16);
  int16_t ret15[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(ret15);
  /* ret[15U] = ret15; */ memcpy(ret[15U], ret15, sizeof(int16_t) * 16);
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1568size_t_4size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)24U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)24U,
            .end = i0 * (size_t)24U + (size_t)24U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_12(bytes,
      coefficient);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___cond_subtract_3329(coefficient,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1568size_t_4size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1568size_t_4size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_libcrux_polynomials_shift_right___15int32_t(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    v[i0] = v[i0] >> (uint32_t)(int32_t)15;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___shift_right___15int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_shift_right___15int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t a[16U],
  int16_t ret[16U]
)
{
  int16_t t[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___shift_right___15int32_t(a,
    t);
  int16_t fm[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___bitwise_and_with_constant(t,
    LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS,
    fm);
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(a,
    &fm,
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_serialize_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[384U]
)
{
  uint8_t serialized[384U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][i0],
      coefficient);
    uint8_t bytes[24U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_12(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)384U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)24U * i0,
            .end = (size_t)24U * i0 + (size_t)24U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)24U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)384U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector key[4U][16U],
  uint8_t ret[1536U]
)
{
  uint8_t out[1536U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
          key,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re, key[i0], (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)1536U,
        out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = (i0 + (size_t)1U) * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret0[384U];
    libcrux_ml_kem_serialize_serialize_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re,
      ret0);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, out, (size_t)1536U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[4U][16U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1568U]
)
{
  uint8_t public_key_serialized[1568U] = { 0U };
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1568U,
      public_key_serialized,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)1536U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[4U][16U];
  memcpy(uu____1,
    t_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t ret0[1536U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t(uu____1,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1536U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1568U,
      public_key_serialized,
      (size_t)1536U,
      uint8_t,
      size_t,
      Eurydice_slice),
    seed_for_a,
    uint8_t,
    void *);
  memcpy(ret, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
}

bool
libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(
  uint8_t *public_key
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[4U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1568size_t_4size_t(Eurydice_array_to_subslice_to((size_t)1568U,
      public_key,
      (size_t)1536U,
      uint8_t,
      size_t,
      Eurydice_slice),
    deserialized_pk);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[4U][16U];
  memcpy(uu____0,
    deserialized_pk,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[1568U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(uu____0,
    Eurydice_array_to_subslice_from((size_t)1568U,
      public_key,
      (size_t)1536U,
      uint8_t,
      size_t,
      Eurydice_slice),
    public_key_serialized);
  return
    core_array_equality___core__cmp__PartialEq__Array_B__N___for__Array_A__N____eq((size_t)1568U,
      public_key,
      public_key_serialized,
      uint8_t,
      uint8_t,
      bool);
}

bool
libcrux_ml_kem_ind_cca_validate_public_key___4size_t_1536size_t_1568size_t(uint8_t *public_key)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  bool uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(public_key);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(public_key);
  }
  return uu____2;
}

core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1568size_t__
libcrux_ml_kem_mlkem1024_validate_public_key(uint8_t public_key[1568U])
{
  core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1568size_t__ uu____0;
  if (libcrux_ml_kem_ind_cca_validate_public_key___4size_t_1536size_t_1568size_t(public_key))
  {
    core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1568size_t__ lit;
    lit.tag = core_option_Some;
    memcpy(lit.f0, public_key, (size_t)1568U * sizeof (uint8_t));
    uu____0 = lit;
  }
  else
  {
    uu____0 =
      (
        (core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1568size_t__){
          .tag = core_option_None
        }
      );
  }
  return uu____0;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___4size_t(
  Eurydice_slice input,
  uint8_t ret[64U]
)
{
  uint8_t digest[64U] = { 0U };
  libcrux_sha3_portable_sha512(Eurydice_array_to_slice((size_t)64U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)64U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(
  size_t _j,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(i,
      ret0[i]);
  }
  memcpy(ret,
    ret0,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___4size_t(
  uint8_t input[4U][34U],
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t ret[4U]
)
{
  uint64_t state[4U][5U][5U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_sha3_portable_incremental_shake128_init(state[i]);
  }
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &state[i0];
    libcrux_sha3_portable_incremental_shake128_absorb_final(uu____0,
      Eurydice_array_to_slice((size_t)34U, input[i0], uint8_t, Eurydice_slice));
  }
  uint64_t uu____1[4U][5U][5U];
  memcpy(uu____1, state, (size_t)4U * sizeof (uint64_t [5U][5U]));
  memcpy(ret, uu____1, (size_t)4U * sizeof (uint64_t [5U][5U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___4size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[4U],
  uint8_t ret[4U][504U]
)
{
  uint8_t out[4U][504U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_first_three_blocks(uu____0,
      Eurydice_array_to_slice((size_t)504U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)4U * sizeof (uint8_t [504U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_504size_t(
  uint8_t randomness[4U][504U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)4U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)504U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)504U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___4size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[4U],
  uint8_t ret[4U][168U]
)
{
  uint8_t out[4U][168U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_next_block(uu____0,
      Eurydice_array_to_slice((size_t)168U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)4U * sizeof (uint8_t [168U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_168size_t(
  uint8_t randomness[4U][168U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)4U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)168U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)168U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice a,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___from_i16_array(Eurydice_slice_subslice(a,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)16U,
            .end = (i0 + (size_t)1U) * (size_t)16U
          }
        ),
        int16_t,
        core_ops_range_Range__size_t,
        Eurydice_slice),
      uu____0);
    memcpy(result[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(
  int16_t s[272U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(Eurydice_array_to_subslice((size_t)272U,
      s,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)256U }),
      int16_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(
  uint8_t seeds[4U][34U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  size_t sampled_coefficients[4U] = { 0U };
  int16_t out[4U][272U] = { { 0U } };
  uint8_t uu____0[4U][34U];
  memcpy(uu____0, seeds, (size_t)4U * sizeof (uint8_t [34U]));
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t xof_state[4U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___4size_t(uu____0,
    xof_state);
  uint8_t randomness0[4U][504U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___4size_t(&xof_state,
    randomness0);
  uint8_t uu____1[4U][504U];
  memcpy(uu____1, randomness0, (size_t)4U * sizeof (uint8_t [504U]));
  bool
  done =
    libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_504size_t(uu____1,
      sampled_coefficients,
      out);
  while (true)
  {
    if (!!done)
    {
      break;
    }
    uint8_t randomness[4U][168U];
    libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___4size_t(&xof_state,
      randomness);
    uint8_t uu____2[4U][168U];
    memcpy(uu____2, randomness, (size_t)4U * sizeof (uint8_t [168U]));
    done =
      libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_168size_t(uu____2,
        sampled_coefficients,
        out);
  }
  int16_t uu____3[4U][272U];
  memcpy(uu____3, out, (size_t)4U * sizeof (int16_t [272U]));
  void
  (*uu____4)(int16_t x0[272U], libcrux_ml_kem_libcrux_polynomials_PortableVector x1[16U]) =
    libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[4U][16U];
  for (size_t i_array_map = (size_t)0U; i_array_map < (size_t)4U; i_array_map++)
  {
    uu____4(uu____3[i_array_map], uu____5[i_array_map]);
  }
  memcpy(ret,
    uu____5,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(
  uint8_t seed[34U],
  bool transpose,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[4U][4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(i,
      A_transpose[i]);
  }
  for (size_t i0 = (size_t)0U; i0 < (size_t)4U; i0++)
  {
    size_t i1 = i0;
    uint8_t uu____0[34U];
    memcpy(uu____0, seed, (size_t)34U * sizeof (uint8_t));
    uint8_t seeds[4U][34U];
    for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    {
      memcpy(seeds[i], uu____0, (size_t)34U * sizeof (uint8_t));
    }
    for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    {
      size_t j = i;
      seeds[j][32U] = (uint8_t)i1;
      seeds[j][33U] = (uint8_t)j;
    }
    uint8_t uu____1[4U][34U];
    memcpy(uu____1, seeds, (size_t)4U * sizeof (uint8_t [34U]));
    libcrux_ml_kem_libcrux_polynomials_PortableVector sampled[4U][16U];
    libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(uu____1,
      sampled);
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
            sampled,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector sample[16U];
      memcpy(sample,
        sampled[j],
        (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      if (transpose)
      {
        memcpy(A_transpose[j][i1],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
      else
      {
        memcpy(A_transpose[i1][j],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
    }
  }
  memcpy(ret,
    A_transpose,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [4U][16U]));
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(Eurydice_slice slice, uint8_t ret[34U])
{
  uint8_t out[34U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)34U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)34U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(Eurydice_slice slice, uint8_t ret[33U])
{
  uint8_t out[33U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)33U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)33U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___4size_t_128size_t(
  uint8_t (*input)[33U],
  uint8_t ret[4U][128U]
)
{
  uint8_t out[4U][128U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = out[i0];
    libcrux_sha3_portable_shake256((size_t)128U,
      uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice),
      void *);
  }
  memcpy(ret, out, (size_t)4U * sizeof (uint8_t [128U]));
}

inline void
libcrux_ml_kem_sampling_sample_from_binomial_distribution_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice randomness,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  int16_t sampled_i16s[256U] = { 0U };
  for
  (size_t
    i0 = (size_t)0U;
    i0
    < core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)4U;
    i0++)
  {
    size_t chunk_number = i0;
    Eurydice_slice
    byte_chunk =
      Eurydice_slice_subslice(randomness,
        (
          (core_ops_range_Range__size_t){
            .start = chunk_number * (size_t)4U,
            .end = chunk_number * (size_t)4U + (size_t)4U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint32_t uu____0 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
    uint32_t
    uu____1 =
      uu____0
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
    uint32_t
    uu____2 =
      uu____1
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
    uint32_t
    random_bits_as_u32 =
      uu____2
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)3U, uint8_t, uint8_t) << 24U;
    uint32_t even_bits = random_bits_as_u32 & 1431655765U;
    uint32_t odd_bits = random_bits_as_u32 >> 1U & 1431655765U;
    uint32_t coin_toss_outcomes = even_bits + odd_bits;
    for (uint32_t i = 0U; i < CORE_NUM__U32_8__BITS / 4U; i++)
    {
      uint32_t outcome_set = i;
      uint32_t outcome_set0 = outcome_set * 4U;
      int16_t outcome_1 = (int16_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 3U);
      int16_t outcome_2 = (int16_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + 2U) & 3U);
      size_t offset = (size_t)(outcome_set0 >> 2U);
      sampled_i16s[(size_t)8U * chunk_number + offset] = outcome_1 - outcome_2;
    }
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(Eurydice_array_to_slice((size_t)256U,
      sampled_i16s,
      int16_t,
      Eurydice_slice),
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_sampling_sample_from_binomial_distribution_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice randomness,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  int16_t sampled_i16s[256U] = { 0U };
  for
  (size_t
    i0 = (size_t)0U;
    i0
    < core_slice___Slice_T___len(randomness, uint8_t, size_t) / (size_t)3U;
    i0++)
  {
    size_t chunk_number = i0;
    Eurydice_slice
    byte_chunk =
      Eurydice_slice_subslice(randomness,
        (
          (core_ops_range_Range__size_t){
            .start = chunk_number * (size_t)3U,
            .end = chunk_number * (size_t)3U + (size_t)3U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint32_t uu____0 = (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)0U, uint8_t, uint8_t);
    uint32_t
    uu____1 =
      uu____0
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)1U, uint8_t, uint8_t) << 8U;
    uint32_t
    random_bits_as_u24 =
      uu____1
      | (uint32_t)Eurydice_slice_index(byte_chunk, (size_t)2U, uint8_t, uint8_t) << 16U;
    uint32_t first_bits = random_bits_as_u24 & 2396745U;
    uint32_t second_bits = random_bits_as_u24 >> 1U & 2396745U;
    uint32_t third_bits = random_bits_as_u24 >> 2U & 2396745U;
    uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
    for (int32_t i = (int32_t)0; i < (int32_t)24 / (int32_t)6; i++)
    {
      int32_t outcome_set = i;
      int32_t outcome_set0 = outcome_set * (int32_t)6;
      int16_t outcome_1 = (int16_t)(coin_toss_outcomes >> (uint32_t)outcome_set0 & 7U);
      int16_t
      outcome_2 = (int16_t)(coin_toss_outcomes >> (uint32_t)(outcome_set0 + (int32_t)3) & 7U);
      size_t offset = (size_t)(outcome_set0 / (int32_t)6);
      sampled_i16s[(size_t)4U * chunk_number + offset] = outcome_1 - outcome_2;
    }
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(Eurydice_array_to_slice((size_t)256U,
      sampled_i16s,
      int16_t,
      Eurydice_slice),
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  Eurydice_slice randomness,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_sampling_sample_from_binomial_distribution_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(randomness,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ntt_ntt_at_layer_7__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t step = LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT / (size_t)2U;
  for (size_t i = (size_t)0U; i < step; i++)
  {
    size_t j = i;
    int16_t t[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___multiply_by_constant(re[0U][j
      + step],
      (int16_t)-1600,
      t);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(re[0U][j],
      &t,
      uu____0);
    memcpy(re[0U][j + step], uu____0, (size_t)16U * sizeof (int16_t));
    int16_t uu____1[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(re[0U][j],
      &t,
      uu____1);
    memcpy(re[0U][j], uu____1, (size_t)16U * sizeof (int16_t));
  }
}

void
libcrux_ml_kem_libcrux_polynomials_libcrux_traits_montgomery_multiply_fe__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t v[16U],
  int16_t fer,
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(v,
    fer,
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
libcrux_ml_kem_ntt_ntt_layer_int_vec_step__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t a[16U],
  int16_t b[16U],
  int16_t zeta_r
)
{
  int16_t t[16U];
  libcrux_ml_kem_libcrux_polynomials_libcrux_traits_montgomery_multiply_fe__libcrux_ml_kem_libcrux_polynomials_PortableVector(b,
    zeta_r,
    t);
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(a,
    &t,
    b);
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(a,
    &t,
    a);
  K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
  lit;
  memcpy(lit.fst, a, (size_t)16U * sizeof (int16_t));
  memcpy(lit.snd, b, (size_t)16U * sizeof (int16_t));
  return lit;
}

inline void
libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t layer,
  size_t _initial_coefficient_bound
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  for (size_t i0 = (size_t)0U; i0 < (size_t)128U >> (uint32_t)layer; i0++)
  {
    size_t round = i0;
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
    size_t offset = round * step * (size_t)2U;
    size_t offset_vec = offset / (size_t)16U;
    size_t step_vec = step / (size_t)16U;
    for (size_t i = offset_vec; i < offset_vec + step_vec; i++)
    {
      size_t j = i;
      K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
      uu____0 =
        libcrux_ml_kem_ntt_ntt_layer_int_vec_step__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][j],
          re[0U][j + step_vec],
          libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      int16_t x[16U];
      memcpy(x, uu____0.fst, (size_t)16U * sizeof (int16_t));
      int16_t y[16U];
      memcpy(y, uu____0.snd, (size_t)16U * sizeof (int16_t));
      memcpy(re[0U][j], x, (size_t)16U * sizeof (int16_t));
      memcpy(re[0U][j + step_vec], y, (size_t)16U * sizeof (int16_t));
    }
  }
}

inline void
libcrux_ml_kem_ntt_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer,
  size_t _initial_coefficient_bound
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_3_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_ntt_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer,
  size_t _initial_coefficient_bound
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_2_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] + (size_t)1U],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
  }
}

inline void
libcrux_ml_kem_ntt_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer,
  size_t _initial_coefficient_bound
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] + (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_layer_1_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] + (size_t)1U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] + (size_t)2U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] + (size_t)3U],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
    zeta_i[0U] = zeta_i[0U] + (size_t)3U;
  }
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U]
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(self[0U][i0],
      uu____0);
    memcpy(self[0U][i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_ntt_ntt_binomially_sampled_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  libcrux_ml_kem_ntt_ntt_at_layer_7__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  size_t zeta_i = (size_t)1U;
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U,
    (size_t)3U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U,
    (size_t)3U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U,
    (size_t)3U);
  libcrux_ml_kem_ntt_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U,
    (size_t)3U);
  libcrux_ml_kem_ntt_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U,
    (size_t)3U);
  libcrux_ml_kem_ntt_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U,
    (size_t)3U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re_as_ntt[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(i,
      re_as_ntt[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[4U][33U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[4U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___4size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(re_as_ntt[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_binomially_sampled_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re_as_ntt[i0]);
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[4U][16U];
  memcpy(uu____2,
    re_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*rhs)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector out[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(out);
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ntt_multiply(&self[0U][i0],
      &rhs[0U][i0],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + (size_t)4U * i0],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + (size_t)4U * i0 + (size_t)1U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + (size_t)4U * i0 + (size_t)2U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + (size_t)4U * i0 + (size_t)3U],
      uu____0);
    memcpy(out[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, out, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*rhs)[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)16U,
          self[0U],
          int16_t [16U],
          Eurydice_slice),
        int16_t [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(self[0U][i0],
      &rhs[0U][i0],
      uu____0);
    memcpy(self[0U][i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

void
libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_standard_domain__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(v,
    LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS,
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_standard_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error)[16U]
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t j = i;
    int16_t coefficient_normal_form[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_standard_domain__libcrux_ml_kem_libcrux_polynomials_PortableVector(self[0U][j],
      coefficient_normal_form);
    int16_t uu____0[16U];
    int16_t ret[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(coefficient_normal_form,
      &error[0U][j],
      ret);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(ret,
      uu____0);
    memcpy(self[0U][j], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_A)[4U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*s_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
          matrix_A,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [4U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [4U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = matrix_A[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(matrix_element,
        &s_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_standard_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_as_ntt[i1]);
  }
  memcpy(ret,
    result,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

K___uint8_t_1536size_t__uint8_t_1568size_t_
libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___4size_t(key_generation_seed,
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[4U][4U][16U];
  uint8_t ret[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(ret,
    true,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
  uu____2 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(uu____1,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[4U][16U];
  memcpy(secret_as_ntt,
    uu____2.fst,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_as_ntt[4U][16U];
  memcpy(error_as_ntt,
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(uu____3,
      domain_separator).fst,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[4U][16U];
  libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____4[4U][16U];
  memcpy(uu____4,
    t_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[1568U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t_1568size_t(uu____4,
    seed_for_A,
    public_key_serialized);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[4U][16U];
  memcpy(uu____5,
    secret_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t secret_key_serialized[1536U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1536size_t(uu____5,
    secret_key_serialized);
  uint8_t uu____6[1536U];
  memcpy(uu____6, secret_key_serialized, (size_t)1536U * sizeof (uint8_t));
  uint8_t uu____7[1568U];
  memcpy(uu____7, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
  K___uint8_t_1536size_t__uint8_t_1568size_t_ lit;
  memcpy(lit.fst, uu____6, (size_t)1536U * sizeof (uint8_t));
  memcpy(lit.snd, uu____7, (size_t)1568U * sizeof (uint8_t));
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___4size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_sha256(Eurydice_array_to_slice((size_t)32U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_3168size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[3168U]
)
{
  uint8_t out[3168U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice
  uu____6 =
    Eurydice_array_to_subslice((size_t)3168U,
      out,
      (
        (core_ops_range_Range__size_t){
          .start = pointer,
          .end = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  uint8_t ret0[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___4size_t(public_key,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  pointer = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE;
  uint8_t *uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)3168U * sizeof (uint8_t));
}

void
libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___3168size_t(
  uint8_t value[3168U],
  uint8_t ret[3168U]
)
{
  uint8_t uu____0[3168U];
  memcpy(uu____0, value, (size_t)3168U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)3168U * sizeof (uint8_t));
}

libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(
  uint8_t sk[3168U],
  uint8_t pk[1568U]
)
{
  libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t lit;
  memcpy(lit.sk, sk, (size_t)3168U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1568U * sizeof (uint8_t));
  return lit;
}

libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t
libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(
  Eurydice_slice ind_cpa_keypair_randomness,
  Eurydice_slice implicit_rejection_value
)
{
  K___uint8_t_1536size_t__uint8_t_1568size_t_
  uu____0 =
    libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1536U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)1536U * sizeof (uint8_t));
  uint8_t public_key[1568U];
  memcpy(public_key, uu____0.snd, (size_t)1568U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)1536U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[3168U];
  libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_3168size_t(uu____1,
    Eurydice_array_to_slice((size_t)1568U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[3168U];
  memcpy(uu____2, secret_key_serialized, (size_t)3168U * sizeof (uint8_t));
  uint8_t private_key[3168U];
  libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___3168size_t(uu____2,
    private_key);
  uint8_t uu____3[3168U];
  memcpy(uu____3, private_key, (size_t)3168U * sizeof (uint8_t));
  uint8_t uu____4[1568U];
  memcpy(uu____4, public_key, (size_t)1568U * sizeof (uint8_t));
  return
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(uu____3,
      uu____4);
}

libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t
libcrux_ml_kem_ind_cca_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  return uu____2;
}

libcrux_ml_kem_types_MlKemKeyPair____3168size_t__1568size_t
libcrux_ml_kem_mlkem1024_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(uu____0);
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_slice slice, uint8_t ret[64U])
{
  uint8_t out[64U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)64U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)64U * sizeof (uint8_t));
}

uint8_t
*libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return self[0U];
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1536size_t_4size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1536size_t_4size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1536size_t_4size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_128size_t_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_128size_t_2size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_128size_t_2size_t(i,
      error_1[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[4U][33U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[4U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___4size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(error_1[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[4U][16U];
  memcpy(uu____2,
    error_1,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___4size_t_128size_t(
  Eurydice_slice input,
  uint8_t ret[128U]
)
{
  uint8_t digest[128U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)128U, digest, input, void *);
  memcpy(ret, digest, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_1_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] - (size_t)1U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] - (size_t)2U],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] - (size_t)3U],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
    zeta_i[0U] = zeta_i[0U] - (size_t)3U;
  }
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_2_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U] - (size_t)1U],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
  }
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t _layer
)
{
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t round = i;
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___inv_ntt_layer_3_step(re[0U][round],
      libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]],
      uu____0);
    memcpy(re[0U][round], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
libcrux_ml_kem_invert_ntt_inv_ntt_layer_int_vec_step_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t a[16U],
  int16_t b[16U],
  int16_t zeta_r
)
{
  int16_t a_minus_b[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(b,
    &a,
    a_minus_b);
  int16_t ret[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(a,
    &b,
    ret);
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(ret,
    a);
  libcrux_ml_kem_libcrux_polynomials_libcrux_traits_montgomery_multiply_fe__libcrux_ml_kem_libcrux_polynomials_PortableVector(a_minus_b,
    zeta_r,
    b);
  K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
  lit;
  memcpy(lit.fst, a, (size_t)16U * sizeof (int16_t));
  memcpy(lit.snd, b, (size_t)16U * sizeof (int16_t));
  return lit;
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  size_t *zeta_i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  size_t layer
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  for (size_t i0 = (size_t)0U; i0 < (size_t)128U >> (uint32_t)layer; i0++)
  {
    size_t round = i0;
    zeta_i[0U] = zeta_i[0U] - (size_t)1U;
    size_t offset = round * step * (size_t)2U;
    size_t offset_vec = offset / (size_t)16U;
    size_t step_vec = step / (size_t)16U;
    for (size_t i = offset_vec; i < offset_vec + step_vec; i++)
    {
      size_t j = i;
      K___libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_libcrux_polynomials_PortableVector
      uu____0 =
        libcrux_ml_kem_invert_ntt_inv_ntt_layer_int_vec_step_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][j],
          re[0U][j + step_vec],
          libcrux_ml_kem_polynomial_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      int16_t x[16U];
      memcpy(x, uu____0.fst, (size_t)16U * sizeof (int16_t));
      int16_t y[16U];
      memcpy(y, uu____0.snd, (size_t)16U * sizeof (int16_t));
      memcpy(re[0U][j], x, (size_t)16U * sizeof (int16_t));
      memcpy(re[0U][j + step_vec], y, (size_t)16U * sizeof (int16_t));
    }
  }
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t zeta_i = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)7U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error)[16U]
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t j = i;
    int16_t coefficient_normal_form[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(self[0U][j],
      (int16_t)1441,
      coefficient_normal_form);
    int16_t uu____0[16U];
    int16_t ret[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(coefficient_normal_form,
      &error[0U][j],
      ret);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(ret,
      uu____0);
    memcpy(self[0U][j], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_as_ntt)[4U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_1)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
          a_as_ntt,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [4U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [4U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = a_as_ntt[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(a_element,
        &r_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result[i1]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_1[i1]);
  }
  memcpy(ret,
    result,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_libcrux_polynomials_libcrux_traits_decompress_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t uu____0[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___ZERO(uu____0);
  int16_t ret0[16U];
  int16_t ret1[16U];
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(uu____0,
    &v,
    ret1);
  libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___bitwise_and_with_constant(ret1,
    (int16_t)1665,
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  uint8_t serialized[32U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t i0 = i;
    int16_t coefficient_compressed[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_1(Eurydice_array_to_subslice((size_t)32U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)2U * i0,
            .end = (size_t)2U * i0 + (size_t)2U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice),
      coefficient_compressed);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_decompress_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(coefficient_compressed,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_message_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*message)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient_normal_form[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(result[i0],
      (int16_t)1441,
      coefficient_normal_form);
    int16_t tmp0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(self[0U][i0],
      &message[0U][i0],
      tmp0);
    int16_t tmp[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(coefficient_normal_form,
      &tmp0,
      tmp);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(tmp,
      uu____0);
    memcpy(result[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*t_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_2)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*message)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&t_as_ntt[i0],
      &r_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_message_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(error_2,
    message,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_libcrux_polynomials_compress___10int32_t(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t
    uu____0 =
      libcrux_ml_kem_libcrux_polynomials_compress_ciphertext_coefficient((uint8_t)(int32_t)10,
        (uint16_t)v[i0]);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___10int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_compress___10int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_10__libcrux_ml_kem_libcrux_polynomials_PortableVector_352size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    int16_t ret0[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][i0],
      ret0);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___10int32_t(ret0,
      coefficient);
    uint8_t bytes[20U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_10(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)352U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)20U * i0,
            .end = (size_t)20U * i0 + (size_t)20U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)20U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)352U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_libcrux_polynomials_compress___11int32_t(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t
    uu____0 =
      libcrux_ml_kem_libcrux_polynomials_compress_ciphertext_coefficient((uint8_t)(int32_t)11,
        (uint16_t)v[i0]);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___11int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_compress___11int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_11__libcrux_ml_kem_libcrux_polynomials_PortableVector_352size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    int16_t ret0[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][i0],
      ret0);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___11int32_t(ret0,
      coefficient);
    uint8_t bytes[22U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_11(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)352U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)22U * i0,
            .end = (size_t)22U * i0 + (size_t)22U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)22U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)352U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t_352size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[352U]
)
{
  uint8_t uu____0[352U];
  libcrux_ml_kem_serialize_compress_then_serialize_11__libcrux_ml_kem_libcrux_polynomials_PortableVector_352size_t(re,
    uu____0);
  memcpy(ret, uu____0, (size_t)352U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1408size_t_11size_t_352size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector input[4U][16U],
  Eurydice_slice out
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
          input,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re,
      input[i0],
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * ((size_t)1408U / (size_t)4U),
            .end = (i0 + (size_t)1U) * ((size_t)1408U / (size_t)4U)
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret[352U];
    libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t_352size_t(&re,
      ret);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)352U, ret, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

inline void
libcrux_ml_kem_libcrux_polynomials_compress___4int32_t(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t
    uu____0 =
      libcrux_ml_kem_libcrux_polynomials_compress_ciphertext_coefficient((uint8_t)(int32_t)4,
        (uint16_t)v[i0]);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___4int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_compress___4int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_4__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U],
  Eurydice_slice serialized
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    int16_t ret[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[i0],
      ret);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___4int32_t(ret,
      coefficient);
    uint8_t bytes[8U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_4(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)8U * i0,
            .end = (size_t)8U * i0 + (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)8U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

inline void
libcrux_ml_kem_libcrux_polynomials_compress___5int32_t(int16_t v[16U], int16_t ret[16U])
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int16_t
    uu____0 =
      libcrux_ml_kem_libcrux_polynomials_compress_ciphertext_coefficient((uint8_t)(int32_t)5,
        (uint16_t)v[i0]);
    v[i0] = uu____0;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___5int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_compress___5int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_5__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U],
  Eurydice_slice serialized
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficients[16U];
    int16_t ret[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[i0],
      ret);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___5int32_t(ret,
      coefficients);
    uint8_t bytes[10U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_5(coefficients,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)10U * i0,
            .end = (size_t)10U * i0 + (size_t)10U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)10U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_5size_t_160size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U],
  Eurydice_slice out
)
{
  libcrux_ml_kem_serialize_compress_then_serialize_5__libcrux_ml_kem_libcrux_polynomials_PortableVector(re,
    out);
}

void
libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[1568U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[4U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1536size_t_4size_t(Eurydice_slice_subslice_to(public_key,
      (size_t)1536U,
      uint8_t,
      size_t,
      Eurydice_slice),
    t_as_ntt);
  Eurydice_slice
  seed = Eurydice_slice_subslice_from(public_key, (size_t)1536U, uint8_t, size_t, Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[4U][4U][16U];
  uint8_t ret0[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed, ret0);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t(ret0,
    false,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
  uu____1 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_2size_t_128size_t(uu____0,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector r_as_ntt[4U][16U];
  memcpy(r_as_ntt,
    uu____1.fst,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator0 = uu____1.snd;
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t__uint8_t
  uu____3 =
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_128size_t_2size_t(uu____2,
      domain_separator0);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[4U][16U];
  memcpy(error_1,
    uu____3.fst,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____3.snd;
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___4size_t_128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t,
      Eurydice_slice),
    prf_output);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_2[16U];
  libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t,
      Eurydice_slice),
    error_2);
  libcrux_ml_kem_libcrux_polynomials_PortableVector u[4U][16U];
  libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(A_transpose,
    r_as_ntt,
    error_1,
    u);
  uint8_t uu____4[32U];
  memcpy(uu____4, message, (size_t)32U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector message_as_ring_element[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(uu____4,
    message_as_ring_element);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  uint8_t ciphertext[1568U] = { 0U };
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____5 =
    core_slice___Slice_T___split_at_mut(Eurydice_array_to_slice((size_t)1568U,
        ciphertext,
        uint8_t,
        Eurydice_slice),
      (size_t)1408U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice c1 = uu____5.fst;
  Eurydice_slice c2 = uu____5.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____6[4U][16U];
  memcpy(uu____6,
    u,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1408size_t_11size_t_352size_t(uu____6,
    c1);
  libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_5size_t_160size_t(v,
    c2);
  memcpy(ret, ciphertext, (size_t)1568U * sizeof (uint8_t));
}

K___libcrux_ml_kem_types_MlKemCiphertext___1568size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1568U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t,
      Eurydice_slice),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  uint8_t ret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___4size_t(Eurydice_array_to_slice((size_t)1568U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t,
      Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___4size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1568U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t,
      Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[1568U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
    uu____3,
    pseudorandomness,
    ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_slice((size_t)32U,
      shared_secret_array,
      uint8_t,
      Eurydice_slice),
    shared_secret,
    uint8_t,
    void *);
  uint8_t uu____4[1568U];
  memcpy(uu____4, ciphertext, (size_t)1568U * sizeof (uint8_t));
  uint8_t uu____5[1568U];
  memcpy(uu____5, uu____4, (size_t)1568U * sizeof (uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof (uint8_t));
  K___libcrux_ml_kem_types_MlKemCiphertext___1568size_t___uint8_t_32size_t_ lit;
  memcpy(lit.fst, uu____5, (size_t)1568U * sizeof (uint8_t));
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof (uint8_t));
  return lit;
}

K___libcrux_ml_kem_types_MlKemCiphertext___1568size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1568U],
  uint8_t randomness[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  K___libcrux_ml_kem_types_MlKemCiphertext___1568size_t___uint8_t_32size_t_ uu____2;
  if (uu____1)
  {
    uint8_t (*uu____3)[1568U] = public_key;
    uint8_t uu____4[32U];
    memcpy(uu____4, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____3,
        uu____4);
  }
  else
  {
    uint8_t (*uu____5)[1568U] = public_key;
    uint8_t uu____6[32U];
    memcpy(uu____6, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
        uu____6);
  }
  return uu____2;
}

K___libcrux_ml_kem_types_MlKemCiphertext___1568size_t___uint8_t_32size_t_
libcrux_ml_kem_mlkem1024_encapsulate(uint8_t (*public_key)[1568U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1568U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___3168size_t(
  uint8_t (*self)[3168U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)3168U,
        self[0U],
        uint8_t,
        Eurydice_slice),
      mid,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
}

void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_11size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___10int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int32_t
    decompressed =
      (int32_t)v[i0]
      * (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
    decompressed = (decompressed << 1U) + ((int32_t)1 << (uint32_t)(int32_t)10);
    decompressed = decompressed >> (uint32_t)((int32_t)10 + (int32_t)1);
    v[i0] = (int16_t)decompressed;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___10int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___10int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_10__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)20U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)20U,
            .end = i0 * (size_t)20U + (size_t)20U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_10(bytes,
      coefficient);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___10int32_t(coefficient,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___11int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int32_t
    decompressed =
      (int32_t)v[i0]
      * (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
    decompressed = (decompressed << 1U) + ((int32_t)1 << (uint32_t)(int32_t)11);
    decompressed = decompressed >> (uint32_t)((int32_t)11 + (int32_t)1);
    v[i0] = (int16_t)decompressed;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___11int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___11int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_11__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)22U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)22U,
            .end = i0 * (size_t)22U + (size_t)22U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_11(bytes,
      coefficient);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___11int32_t(coefficient,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_11__libcrux_ml_kem_libcrux_polynomials_PortableVector(serialized,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t zeta_i = (size_t)0U;
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)7U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U,
    (size_t)3328U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_11size_t(
  uint8_t *ciphertext,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_11size_t(i,
      u_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)1568U,
          ciphertext,
          uint8_t,
          Eurydice_slice),
        uint8_t,
        size_t)
      / (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U);
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    u_bytes =
      Eurydice_array_to_subslice((size_t)1568U,
        ciphertext,
        (
          (core_ops_range_Range__size_t){
            .start = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U),
            .end = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U)
            + LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t(u_bytes,
      uu____0);
    memcpy(u_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_11size_t(&u_as_ntt[i0]);
  }
  memcpy(ret,
    u_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___4int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int32_t
    decompressed =
      (int32_t)v[i0]
      * (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
    decompressed = (decompressed << 1U) + ((int32_t)1 << (uint32_t)(int32_t)4);
    decompressed = decompressed >> (uint32_t)((int32_t)4 + (int32_t)1);
    v[i0] = (int16_t)decompressed;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___4int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___4int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_4__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)8U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)8U,
            .end = i0 * (size_t)8U + (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_4(bytes,
      coefficient);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___4int32_t(coefficient,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___5int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    < LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_ELEMENTS_IN_VECTOR;
    i++)
  {
    size_t i0 = i;
    int32_t
    decompressed =
      (int32_t)v[i0]
      * (int32_t)LIBCRUX_ML_KEM_LIBCRUX_POLYNOMIALS_LIBCRUX_TRAITS_FIELD_MODULUS;
    decompressed = (decompressed << 1U) + ((int32_t)1 << (uint32_t)(int32_t)5);
    decompressed = decompressed >> (uint32_t)((int32_t)5 + (int32_t)1);
    v[i0] = (int16_t)decompressed;
  }
  memcpy(ret, v, (size_t)16U * sizeof (int16_t));
}

void
libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___5int32_t(
  int16_t v[16U],
  int16_t ret[16U]
)
{
  int16_t ret0[16U];
  libcrux_ml_kem_libcrux_polynomials_decompress_ciphertext_coefficient___5int32_t(v, ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (int16_t));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_5__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)10U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)10U,
            .end = i0 * (size_t)10U + (size_t)10U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_5(bytes,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
    int16_t uu____1[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___decompress_ciphertext_coefficient___5int32_t(re[i0],
      uu____1);
    memcpy(re[i0], uu____1, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_5size_t(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_5__libcrux_ml_kem_libcrux_polynomials_PortableVector(serialized,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_to_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
  for
  (size_t
    i = (size_t)0U;
    i
    < core_slice___Slice_T___len(serialized, uint8_t, size_t) / (size_t)24U;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    bytes =
      Eurydice_slice_subslice(serialized,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * (size_t)24U,
            .end = i0 * (size_t)24U + (size_t)24U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___deserialize_12(bytes,
      uu____0);
    memcpy(re[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, re, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  Eurydice_slice secret_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[4U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[4U][16U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(i,
      secret_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(secret_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    secret_bytes =
      Eurydice_slice_subslice(secret_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(secret_bytes,
      uu____0);
    memcpy(secret_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    secret_as_ntt,
    (size_t)4U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___subtract_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector b[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient_normal_form[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___montgomery_multiply_by_constant(b[i0],
      (int16_t)1441,
      coefficient_normal_form);
    int16_t uu____0[16U];
    int16_t ret0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___sub(self[0U][i0],
      &coefficient_normal_form,
      ret0);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___barrett_reduce(ret0,
      uu____0);
    memcpy(b[i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
  memcpy(ret, b, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*v)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*secret_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*u_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&secret_as_ntt[i0],
      &u_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___subtract_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(v,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U],
  uint8_t ret[32U]
)
{
  uint8_t serialized[32U] = { 0U };
  for (size_t i = (size_t)0U; i < (size_t)16U; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[i0],
      coefficient);
    int16_t coefficient_compressed[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress_1(coefficient,
      coefficient_compressed);
    uint8_t bytes[2U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_1(coefficient_compressed,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)32U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)2U * i0,
            .end = (size_t)2U * i0 + (size_t)2U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)2U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_1408size_t_11size_t_5size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[4U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_11size_t(ciphertext,
    u_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_5size_t(Eurydice_array_to_subslice_from((size_t)1568U,
      ciphertext,
      (size_t)1408U,
      uint8_t,
      size_t,
      Eurydice_slice),
    v);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[4U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(secret_key,
    secret_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector message[16U];
  libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(&v,
    secret_as_ntt,
    u_as_ntt,
    message);
  uint8_t ret0[32U];
  libcrux_ml_kem_serialize_compress_then_serialize_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(message,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___1600size_t(Eurydice_slice slice, uint8_t ret[1600U])
{
  uint8_t out[1600U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1600U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1600U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return Eurydice_array_to_slice((size_t)1568U, self[0U], uint8_t, Eurydice_slice);
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___4size_t_32size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)32U, digest, input, void *);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

uint8_t
libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  for (size_t i = (size_t)0U; i < (size_t)1568U; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = Eurydice_slice_index(lhs, i0, uint8_t, uint8_t);
    r =
      (uint32_t)r
      | ((uint32_t)uu____0 ^ (uint32_t)Eurydice_slice_index(rhs, i0, uint8_t, uint8_t));
  }
  return libcrux_ml_kem_constant_time_ops_is_non_zero(r);
}

void
libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(
  uint8_t (*private_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___3168size_t(private_key,
      (size_t)1536U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)1568U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_1568size_t_1408size_t_11size_t_5size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___4size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1600U];
  libcrux_ml_kem_ind_cpa_into_padded_array___1600size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1600U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1568size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___4size_t_32size_t(Eurydice_array_to_slice((size_t)1600U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1568U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
    uu____6,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice
  uu____7 =
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1568size_t(ciphertext);
  uint8_t
  selector =
    libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(uu____7,
      Eurydice_array_to_slice((size_t)1568U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_ml_kem_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cca_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(
  uint8_t (*private_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  uint8_t uu____2[32U];
  if (uu____1)
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(private_key,
      ciphertext,
      uu____2);
  }
  else
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___4size_t___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(private_key,
      ciphertext,
      uu____2);
    memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
    return;
  }
  memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_mlkem1024_decapsulate(
  uint8_t (*private_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_ml_kem_ind_cca_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(private_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_800size_t_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_800size_t_2size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_800size_t_2size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector key[2U][16U],
  uint8_t ret[768U]
)
{
  uint8_t out[768U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          key,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re, key[i0], (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)768U,
        out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = (i0 + (size_t)1U) * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret0[384U];
    libcrux_ml_kem_serialize_serialize_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re,
      ret0);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, out, (size_t)768U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[2U][16U],
  Eurydice_slice seed_for_a,
  uint8_t ret[800U]
)
{
  uint8_t public_key_serialized[800U] = { 0U };
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)800U,
      public_key_serialized,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)768U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[2U][16U];
  memcpy(uu____1,
    t_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t ret0[768U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t(uu____1,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)768U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)800U,
      public_key_serialized,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    seed_for_a,
    uint8_t,
    void *);
  memcpy(ret, public_key_serialized, (size_t)800U * sizeof (uint8_t));
}

bool
libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(
  uint8_t *public_key
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[2U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_800size_t_2size_t(Eurydice_array_to_subslice_to((size_t)800U,
      public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    deserialized_pk);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[2U][16U];
  memcpy(uu____0,
    deserialized_pk,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[800U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(uu____0,
    Eurydice_array_to_subslice_from((size_t)800U,
      public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    public_key_serialized);
  return
    core_array_equality___core__cmp__PartialEq__Array_B__N___for__Array_A__N____eq((size_t)800U,
      public_key,
      public_key_serialized,
      uint8_t,
      uint8_t,
      bool);
}

bool
libcrux_ml_kem_ind_cca_validate_public_key___2size_t_768size_t_800size_t(uint8_t *public_key)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  bool uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(public_key);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(public_key);
  }
  return uu____2;
}

core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__
libcrux_ml_kem_mlkem512_validate_public_key(uint8_t public_key[800U])
{
  core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__ uu____0;
  if (libcrux_ml_kem_ind_cca_validate_public_key___2size_t_768size_t_800size_t(public_key))
  {
    core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__ lit;
    lit.tag = core_option_Some;
    memcpy(lit.f0, public_key, (size_t)800U * sizeof (uint8_t));
    uu____0 = lit;
  }
  else
  {
    uu____0 =
      (
        (core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__){
          .tag = core_option_None
        }
      );
  }
  return uu____0;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(
  Eurydice_slice input,
  uint8_t ret[64U]
)
{
  uint8_t digest[64U] = { 0U };
  libcrux_sha3_portable_sha512(Eurydice_array_to_slice((size_t)64U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)64U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  size_t _j,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(i,
      ret0[i]);
  }
  memcpy(ret,
    ret0,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___2size_t(
  uint8_t input[2U][34U],
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t ret[2U]
)
{
  uint64_t state[2U][5U][5U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_sha3_portable_incremental_shake128_init(state[i]);
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &state[i0];
    libcrux_sha3_portable_incremental_shake128_absorb_final(uu____0,
      Eurydice_array_to_slice((size_t)34U, input[i0], uint8_t, Eurydice_slice));
  }
  uint64_t uu____1[2U][5U][5U];
  memcpy(uu____1, state, (size_t)2U * sizeof (uint64_t [5U][5U]));
  memcpy(ret, uu____1, (size_t)2U * sizeof (uint64_t [5U][5U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___2size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[2U],
  uint8_t ret[2U][504U]
)
{
  uint8_t out[2U][504U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_first_three_blocks(uu____0,
      Eurydice_array_to_slice((size_t)504U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [504U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_504size_t(
  uint8_t randomness[2U][504U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)504U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)504U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___2size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[2U],
  uint8_t ret[2U][168U]
)
{
  uint8_t out[2U][168U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_next_block(uu____0,
      Eurydice_array_to_slice((size_t)168U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [168U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_168size_t(
  uint8_t randomness[2U][168U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)168U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)168U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

void
libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  int16_t s[272U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(Eurydice_array_to_subslice((size_t)272U,
      s,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)256U }),
      int16_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  uint8_t seeds[2U][34U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  size_t sampled_coefficients[2U] = { 0U };
  int16_t out[2U][272U] = { { 0U } };
  uint8_t uu____0[2U][34U];
  memcpy(uu____0, seeds, (size_t)2U * sizeof (uint8_t [34U]));
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t xof_state[2U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___2size_t(uu____0,
    xof_state);
  uint8_t randomness0[2U][504U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___2size_t(&xof_state,
    randomness0);
  uint8_t uu____1[2U][504U];
  memcpy(uu____1, randomness0, (size_t)2U * sizeof (uint8_t [504U]));
  bool
  done =
    libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_504size_t(uu____1,
      sampled_coefficients,
      out);
  while (true)
  {
    if (!!done)
    {
      break;
    }
    uint8_t randomness[2U][168U];
    libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___2size_t(&xof_state,
      randomness);
    uint8_t uu____2[2U][168U];
    memcpy(uu____2, randomness, (size_t)2U * sizeof (uint8_t [168U]));
    done =
      libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_168size_t(uu____2,
        sampled_coefficients,
        out);
  }
  int16_t uu____3[2U][272U];
  memcpy(uu____3, out, (size_t)2U * sizeof (int16_t [272U]));
  void
  (*uu____4)(int16_t x0[272U], libcrux_ml_kem_libcrux_polynomials_PortableVector x1[16U]) =
    libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[2U][16U];
  for (size_t i_array_map = (size_t)0U; i_array_map < (size_t)2U; i_array_map++)
  {
    uu____4(uu____3[i_array_map], uu____5[i_array_map]);
  }
  memcpy(ret,
    uu____5,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  uint8_t seed[34U],
  bool transpose,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[2U][2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(i,
      A_transpose[i]);
  }
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    uint8_t uu____0[34U];
    memcpy(uu____0, seed, (size_t)34U * sizeof (uint8_t));
    uint8_t seeds[2U][34U];
    for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    {
      memcpy(seeds[i], uu____0, (size_t)34U * sizeof (uint8_t));
    }
    for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    {
      size_t j = i;
      seeds[j][32U] = (uint8_t)i1;
      seeds[j][33U] = (uint8_t)j;
    }
    uint8_t uu____1[2U][34U];
    memcpy(uu____1, seeds, (size_t)2U * sizeof (uint8_t [34U]));
    libcrux_ml_kem_libcrux_polynomials_PortableVector sampled[2U][16U];
    libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(uu____1,
      sampled);
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            sampled,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector sample[16U];
      memcpy(sample,
        sampled[j],
        (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      if (transpose)
      {
        memcpy(A_transpose[j][i1],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
      else
      {
        memcpy(A_transpose[i1][j],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
    }
  }
  memcpy(ret,
    A_transpose,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [2U][16U]));
}

void
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_192size_t(
  uint8_t (*input)[33U],
  uint8_t ret[2U][192U]
)
{
  uint8_t out[2U][192U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = out[i0];
    libcrux_sha3_portable_shake256((size_t)192U,
      uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice),
      void *);
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [192U]));
}

inline void
libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  Eurydice_slice randomness,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_sampling_sample_from_binomial_distribution_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(randomness,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re_as_ntt[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(i,
      re_as_ntt[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[2U][33U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[2U][192U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_192size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(Eurydice_array_to_slice((size_t)192U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(re_as_ntt[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_binomially_sampled_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re_as_ntt[i0]);
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[2U][16U];
  memcpy(uu____2,
    re_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*rhs)[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)16U,
          self[0U],
          int16_t [16U],
          Eurydice_slice),
        int16_t [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(self[0U][i0],
      &rhs[0U][i0],
      uu____0);
    memcpy(self[0U][i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_A)[2U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*s_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          matrix_A,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [2U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [2U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = matrix_A[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(matrix_element,
        &s_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_standard_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_as_ntt[i1]);
  }
  memcpy(ret,
    result,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

K___uint8_t_768size_t__uint8_t_800size_t_
libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(key_generation_seed,
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[2U][2U][16U];
  uint8_t ret[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(ret,
    true,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
  uu____2 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____1,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[2U][16U];
  memcpy(secret_as_ntt,
    uu____2.fst,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_as_ntt[2U][16U];
  memcpy(error_as_ntt,
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____3,
      domain_separator).fst,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[2U][16U];
  libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____4[2U][16U];
  memcpy(uu____4,
    t_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[800U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_800size_t(uu____4,
    seed_for_A,
    public_key_serialized);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[2U][16U];
  memcpy(uu____5,
    secret_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t secret_key_serialized[768U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t(uu____5,
    secret_key_serialized);
  uint8_t uu____6[768U];
  memcpy(uu____6, secret_key_serialized, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____7[800U];
  memcpy(uu____7, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  K___uint8_t_768size_t__uint8_t_800size_t_ lit;
  memcpy(lit.fst, uu____6, (size_t)768U * sizeof (uint8_t));
  memcpy(lit.snd, uu____7, (size_t)800U * sizeof (uint8_t));
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_sha256(Eurydice_array_to_slice((size_t)32U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[1632U]
)
{
  uint8_t out[1632U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice
  uu____6 =
    Eurydice_array_to_subslice((size_t)1632U,
      out,
      (
        (core_ops_range_Range__size_t){
          .start = pointer,
          .end = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  uint8_t ret0[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(public_key,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  pointer = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE;
  uint8_t *uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1632U * sizeof (uint8_t));
}

void
libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___1632size_t(
  uint8_t value[1632U],
  uint8_t ret[1632U]
)
{
  uint8_t uu____0[1632U];
  memcpy(uu____0, value, (size_t)1632U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)1632U * sizeof (uint8_t));
}

libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(
  uint8_t sk[1632U],
  uint8_t pk[800U]
)
{
  libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t lit;
  memcpy(lit.sk, sk, (size_t)1632U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)800U * sizeof (uint8_t));
  return lit;
}

libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice ind_cpa_keypair_randomness,
  Eurydice_slice implicit_rejection_value
)
{
  K___uint8_t_768size_t__uint8_t_800size_t_
  uu____0 =
    libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[768U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)768U * sizeof (uint8_t));
  uint8_t public_key[800U];
  memcpy(public_key, uu____0.snd, (size_t)800U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)768U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[1632U];
  libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t(uu____1,
    Eurydice_array_to_slice((size_t)800U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[1632U];
  memcpy(uu____2, secret_key_serialized, (size_t)1632U * sizeof (uint8_t));
  uint8_t private_key[1632U];
  libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___1632size_t(uu____2,
    private_key);
  uint8_t uu____3[1632U];
  memcpy(uu____3, private_key, (size_t)1632U * sizeof (uint8_t));
  uint8_t uu____4[800U];
  memcpy(uu____4, public_key, (size_t)800U * sizeof (uint8_t));
  return
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(uu____3,
      uu____4);
}

libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
libcrux_ml_kem_ind_cca_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  return uu____2;
}

libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
libcrux_ml_kem_mlkem512_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(uu____0);
}

uint8_t
*libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___800size_t(
  uint8_t (*self)[800U]
)
{
  return self[0U];
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_768size_t_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_768size_t_2size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_768size_t_2size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_128size_t(
  uint8_t (*input)[33U],
  uint8_t ret[2U][128U]
)
{
  uint8_t out[2U][128U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = out[i0];
    libcrux_sha3_portable_shake256((size_t)128U,
      uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice),
      void *);
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [128U]));
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(i,
      error_1[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[2U][33U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[2U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(error_1[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[2U][16U];
  memcpy(uu____2,
    error_1,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_128size_t(
  Eurydice_slice input,
  uint8_t ret[128U]
)
{
  uint8_t digest[128U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)128U, digest, input, void *);
  memcpy(ret, digest, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t zeta_i = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)7U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline void
libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_as_ntt)[2U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_1)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          a_as_ntt,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [2U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [2U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = a_as_ntt[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(a_element,
        &r_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result[i1]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_1[i1]);
  }
  memcpy(ret,
    result,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*t_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_2)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*message)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&t_as_ntt[i0],
      &r_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_message_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(error_2,
    message,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_10__libcrux_ml_kem_libcrux_polynomials_PortableVector_320size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    int16_t ret0[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][i0],
      ret0);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___10int32_t(ret0,
      coefficient);
    uint8_t bytes[20U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_10(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)320U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)20U * i0,
            .end = (size_t)20U * i0 + (size_t)20U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)20U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)320U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_11__libcrux_ml_kem_libcrux_polynomials_PortableVector_320size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U] = { 0U };
  for (size_t i = (size_t)0U; i < LIBCRUX_ML_KEM_POLYNOMIAL_VECTORS_IN_RING_ELEMENT; i++)
  {
    size_t i0 = i;
    int16_t coefficient[16U];
    int16_t ret0[16U];
    libcrux_ml_kem_libcrux_polynomials_libcrux_traits_to_unsigned_representative__libcrux_ml_kem_libcrux_polynomials_PortableVector(re[0U][i0],
      ret0);
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___compress___11int32_t(ret0,
      coefficient);
    uint8_t bytes[22U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___serialize_11(coefficient,
      bytes);
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)320U,
        serialized,
        (
          (core_ops_range_Range__size_t){
            .start = (size_t)22U * i0,
            .end = (size_t)22U * i0 + (size_t)22U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)22U, bytes, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, serialized, (size_t)320U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t_320size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U],
  uint8_t ret[320U]
)
{
  uint8_t uu____0[320U];
  libcrux_ml_kem_serialize_compress_then_serialize_10__libcrux_ml_kem_libcrux_polynomials_PortableVector_320size_t(re,
    uu____0);
  memcpy(ret, uu____0, (size_t)320U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_640size_t_10size_t_320size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector input[2U][16U],
  Eurydice_slice out
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          input,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re,
      input[i0],
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * ((size_t)640U / (size_t)2U),
            .end = (i0 + (size_t)1U) * ((size_t)640U / (size_t)2U)
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret[320U];
    libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t_320size_t(&re,
      ret);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)320U, ret, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

inline void
libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_128size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U],
  Eurydice_slice out
)
{
  libcrux_ml_kem_serialize_compress_then_serialize_4__libcrux_ml_kem_libcrux_polynomials_PortableVector(re,
    out);
}

void
libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[768U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[2U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_768size_t_2size_t(Eurydice_slice_subslice_to(public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    t_as_ntt);
  Eurydice_slice
  seed = Eurydice_slice_subslice_from(public_key, (size_t)768U, uint8_t, size_t, Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[2U][2U][16U];
  uint8_t ret0[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed, ret0);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(ret0,
    false,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
  uu____1 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____0,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector r_as_ntt[2U][16U];
  memcpy(r_as_ntt,
    uu____1.fst,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator0 = uu____1.snd;
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t__uint8_t
  uu____3 =
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(uu____2,
      domain_separator0);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[2U][16U];
  memcpy(error_1,
    uu____3.fst,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____3.snd;
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t,
      Eurydice_slice),
    prf_output);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_2[16U];
  libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t,
      Eurydice_slice),
    error_2);
  libcrux_ml_kem_libcrux_polynomials_PortableVector u[2U][16U];
  libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(A_transpose,
    r_as_ntt,
    error_1,
    u);
  uint8_t uu____4[32U];
  memcpy(uu____4, message, (size_t)32U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector message_as_ring_element[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(uu____4,
    message_as_ring_element);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  uint8_t ciphertext[768U] = { 0U };
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____5 =
    core_slice___Slice_T___split_at_mut(Eurydice_array_to_slice((size_t)768U,
        ciphertext,
        uint8_t,
        Eurydice_slice),
      (size_t)640U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice c1 = uu____5.fst;
  Eurydice_slice c2 = uu____5.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____6[2U][16U];
  memcpy(uu____6,
    u,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_640size_t_10size_t_320size_t(uu____6,
    c1);
  libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_128size_t(v,
    c2);
  memcpy(ret, ciphertext, (size_t)768U * sizeof (uint8_t));
}

K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  uint8_t (*public_key)[800U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t,
      Eurydice_slice),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  uint8_t ret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(Eurydice_array_to_slice((size_t)800U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t,
      Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)800U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t,
      Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[768U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____2,
    uu____3,
    pseudorandomness,
    ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_slice((size_t)32U,
      shared_secret_array,
      uint8_t,
      Eurydice_slice),
    shared_secret,
    uint8_t,
    void *);
  uint8_t uu____4[768U];
  memcpy(uu____4, ciphertext, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____5[768U];
  memcpy(uu____5, uu____4, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof (uint8_t));
  K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_ lit;
  memcpy(lit.fst, uu____5, (size_t)768U * sizeof (uint8_t));
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof (uint8_t));
  return lit;
}

K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  uint8_t (*public_key)[800U],
  uint8_t randomness[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_ uu____2;
  if (uu____1)
  {
    uint8_t (*uu____3)[800U] = public_key;
    uint8_t uu____4[32U];
    memcpy(uu____4, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____3,
        uu____4);
  }
  else
  {
    uint8_t (*uu____5)[800U] = public_key;
    uint8_t uu____6[32U];
    memcpy(uu____6, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
        uu____6);
  }
  return uu____2;
}

K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
libcrux_ml_kem_mlkem512_encapsulate(uint8_t (*public_key)[800U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[800U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___1632size_t(
  uint8_t (*self)[1632U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)1632U,
        self[0U],
        uint8_t,
        Eurydice_slice),
      mid,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
}

void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_10size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_10__libcrux_ml_kem_libcrux_polynomials_PortableVector(serialized,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t zeta_i = (size_t)0U;
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)7U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U,
    (size_t)3328U);
  libcrux_ml_kem_ntt_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U,
    (size_t)3328U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_10size_t(
  uint8_t *ciphertext,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_10size_t(i,
      u_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)768U,
          ciphertext,
          uint8_t,
          Eurydice_slice),
        uint8_t,
        size_t)
      / (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U);
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    u_bytes =
      Eurydice_array_to_subslice((size_t)768U,
        ciphertext,
        (
          (core_ops_range_Range__size_t){
            .start = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U),
            .end = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U)
            + LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(u_bytes,
      uu____0);
    memcpy(u_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(&u_as_ntt[i0]);
  }
  memcpy(ret,
    u_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(
  Eurydice_slice serialized,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_4__libcrux_ml_kem_libcrux_polynomials_PortableVector(serialized,
    uu____0);
  memcpy(ret, uu____0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  Eurydice_slice secret_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[2U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[2U][16U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(i,
      secret_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(secret_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    secret_bytes =
      Eurydice_slice_subslice(secret_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(secret_bytes,
      uu____0);
    memcpy(secret_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    secret_as_ntt,
    (size_t)2U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*v)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*secret_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*u_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&secret_as_ntt[i0],
      &u_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___subtract_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(v,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_640size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[2U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_10size_t(ciphertext,
    u_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t,
      Eurydice_slice),
    v);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[2U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(secret_key,
    secret_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector message[16U];
  libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(&v,
    secret_as_ntt,
    u_as_ntt,
    message);
  uint8_t ret0[32U];
  libcrux_ml_kem_serialize_compress_then_serialize_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(message,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___800size_t(Eurydice_slice slice, uint8_t ret[800U])
{
  uint8_t out[800U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)800U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)800U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___768size_t(
  uint8_t (*self)[768U]
)
{
  return Eurydice_array_to_slice((size_t)768U, self[0U], uint8_t, Eurydice_slice);
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_32size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)32U, digest, input, void *);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

uint8_t
libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  for (size_t i = (size_t)0U; i < (size_t)768U; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = Eurydice_slice_index(lhs, i0, uint8_t, uint8_t);
    r =
      (uint32_t)r
      | ((uint32_t)uu____0 ^ (uint32_t)Eurydice_slice_index(rhs, i0, uint8_t, uint8_t));
  }
  return libcrux_ml_kem_constant_time_ops_is_non_zero(r);
}

void
libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  uint8_t (*private_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___1632size_t(private_key,
      (size_t)768U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)800U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t_768size_t_640size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[800U];
  libcrux_ml_kem_ind_cpa_into_padded_array___800size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)800U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___768size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_32size_t(Eurydice_array_to_slice((size_t)800U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[768U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
    uu____6,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice
  uu____7 =
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___768size_t(ciphertext);
  uint8_t
  selector =
    libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(uu____7,
      Eurydice_array_to_slice((size_t)768U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_ml_kem_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cca_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  uint8_t (*private_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  uint8_t uu____2[32U];
  if (uu____1)
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
      ciphertext,
      uu____2);
  }
  else
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
      ciphertext,
      uu____2);
    memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
    return;
  }
  memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_mlkem512_decapsulate(
  uint8_t (*private_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_ml_kem_ind_cca_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1184size_t_3size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1184size_t_3size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1184size_t_3size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector key[3U][16U],
  uint8_t ret[1152U]
)
{
  uint8_t out[1152U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
          key,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re, key[i0], (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)1152U,
        out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = (i0 + (size_t)1U) * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret0[384U];
    libcrux_ml_kem_serialize_serialize_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re,
      ret0);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, out, (size_t)1152U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[3U][16U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1184U]
)
{
  uint8_t public_key_serialized[1184U] = { 0U };
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1184U,
      public_key_serialized,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)1152U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[3U][16U];
  memcpy(uu____1,
    t_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t ret0[1152U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t(uu____1,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1152U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1184U,
      public_key_serialized,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    seed_for_a,
    uint8_t,
    void *);
  memcpy(ret, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
}

bool
libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(
  uint8_t *public_key
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[3U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1184size_t_3size_t(Eurydice_array_to_subslice_to((size_t)1184U,
      public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    deserialized_pk);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[3U][16U];
  memcpy(uu____0,
    deserialized_pk,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[1184U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(uu____0,
    Eurydice_array_to_subslice_from((size_t)1184U,
      public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    public_key_serialized);
  return
    core_array_equality___core__cmp__PartialEq__Array_B__N___for__Array_A__N____eq((size_t)1184U,
      public_key,
      public_key_serialized,
      uint8_t,
      uint8_t,
      bool);
}

bool
libcrux_ml_kem_ind_cca_validate_public_key___3size_t_1152size_t_1184size_t(uint8_t *public_key)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  bool uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(public_key);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(public_key);
  }
  return uu____2;
}

core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1184size_t__
libcrux_ml_kem_mlkem768_validate_public_key(uint8_t public_key[1184U])
{
  core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1184size_t__ uu____0;
  if (libcrux_ml_kem_ind_cca_validate_public_key___3size_t_1152size_t_1184size_t(public_key))
  {
    core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1184size_t__ lit;
    lit.tag = core_option_Some;
    memcpy(lit.f0, public_key, (size_t)1184U * sizeof (uint8_t));
    uu____0 = lit;
  }
  else
  {
    uu____0 =
      (
        (core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___1184size_t__){
          .tag = core_option_None
        }
      );
  }
  return uu____0;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___3size_t(
  Eurydice_slice input,
  uint8_t ret[64U]
)
{
  uint8_t digest[64U] = { 0U };
  libcrux_sha3_portable_sha512(Eurydice_array_to_slice((size_t)64U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)64U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(
  size_t _j,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(i,
      ret0[i]);
  }
  memcpy(ret,
    ret0,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___3size_t(
  uint8_t input[3U][34U],
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t ret[3U]
)
{
  uint64_t state[3U][5U][5U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_sha3_portable_incremental_shake128_init(state[i]);
  }
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &state[i0];
    libcrux_sha3_portable_incremental_shake128_absorb_final(uu____0,
      Eurydice_array_to_slice((size_t)34U, input[i0], uint8_t, Eurydice_slice));
  }
  uint64_t uu____1[3U][5U][5U];
  memcpy(uu____1, state, (size_t)3U * sizeof (uint64_t [5U][5U]));
  memcpy(ret, uu____1, (size_t)3U * sizeof (uint64_t [5U][5U]));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___3size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[3U],
  uint8_t ret[3U][504U]
)
{
  uint8_t out[3U][504U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_first_three_blocks(uu____0,
      Eurydice_array_to_slice((size_t)504U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)3U * sizeof (uint8_t [504U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_504size_t(
  uint8_t randomness[3U][504U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)3U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)504U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)504U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___3size_t(
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t (*self)[3U],
  uint8_t ret[3U][168U]
)
{
  uint8_t out[3U][168U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    uint64_t (*uu____0)[5U][5U] = &self[0U][i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_next_block(uu____0,
      Eurydice_array_to_slice((size_t)168U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)3U * sizeof (uint8_t [168U]));
}

inline bool
libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_168size_t(
  uint8_t randomness[3U][168U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)3U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)168U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        out0 =
          core_convert___core__convert__AsMut__Slice_T___for__Slice_T___9__as_mut(Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            int16_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___rej_sample(Eurydice_array_to_subslice((size_t)168U,
              randomness[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = r * (size_t)24U,
                  .end = r * (size_t)24U + (size_t)24U
                }
              ),
              uint8_t,
              core_ops_range_Range__size_t,
              Eurydice_slice),
            out0);
        size_t uu____0 = i1;
        sampled_coefficients[uu____0] = sampled_coefficients[uu____0] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

void
libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(
  int16_t s[272U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_libcrux_polynomials_PortableVector(Eurydice_array_to_subslice((size_t)272U,
      s,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)256U }),
      int16_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(
  uint8_t seeds[3U][34U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  size_t sampled_coefficients[3U] = { 0U };
  int16_t out[3U][272U] = { { 0U } };
  uint8_t uu____0[3U][34U];
  memcpy(uu____0, seeds, (size_t)3U * sizeof (uint8_t [34U]));
  libcrux_sha3_generic_keccak_KeccakState__uint64_t__1size_t xof_state[3U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___3size_t(uu____0,
    xof_state);
  uint8_t randomness0[3U][504U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___3size_t(&xof_state,
    randomness0);
  uint8_t uu____1[3U][504U];
  memcpy(uu____1, randomness0, (size_t)3U * sizeof (uint8_t [504U]));
  bool
  done =
    libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_504size_t(uu____1,
      sampled_coefficients,
      out);
  while (true)
  {
    if (!!done)
    {
      break;
    }
    uint8_t randomness[3U][168U];
    libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___3size_t(&xof_state,
      randomness);
    uint8_t uu____2[3U][168U];
    memcpy(uu____2, randomness, (size_t)3U * sizeof (uint8_t [168U]));
    done =
      libcrux_ml_kem_sampling_sample_from_uniform_distribution_next__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_168size_t(uu____2,
        sampled_coefficients,
        out);
  }
  int16_t uu____3[3U][272U];
  memcpy(uu____3, out, (size_t)3U * sizeof (int16_t [272U]));
  void
  (*uu____4)(int16_t x0[272U], libcrux_ml_kem_libcrux_polynomials_PortableVector x1[16U]) =
    libcrux_ml_kem_sampling_sample_from_xof_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[3U][16U];
  for (size_t i_array_map = (size_t)0U; i_array_map < (size_t)3U; i_array_map++)
  {
    uu____4(uu____3[i_array_map], uu____5[i_array_map]);
  }
  memcpy(ret,
    uu____5,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(
  uint8_t seed[34U],
  bool transpose,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[3U][3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_matrix_sample_matrix_A_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(i,
      A_transpose[i]);
  }
  for (size_t i0 = (size_t)0U; i0 < (size_t)3U; i0++)
  {
    size_t i1 = i0;
    uint8_t uu____0[34U];
    memcpy(uu____0, seed, (size_t)34U * sizeof (uint8_t));
    uint8_t seeds[3U][34U];
    for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    {
      memcpy(seeds[i], uu____0, (size_t)34U * sizeof (uint8_t));
    }
    for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    {
      size_t j = i;
      seeds[j][32U] = (uint8_t)i1;
      seeds[j][33U] = (uint8_t)j;
    }
    uint8_t uu____1[3U][34U];
    memcpy(uu____1, seeds, (size_t)3U * sizeof (uint8_t [34U]));
    libcrux_ml_kem_libcrux_polynomials_PortableVector sampled[3U][16U];
    libcrux_ml_kem_sampling_sample_from_xof__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(uu____1,
      sampled);
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
            sampled,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector sample[16U];
      memcpy(sample,
        sampled[j],
        (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      if (transpose)
      {
        memcpy(A_transpose[j][i1],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
      else
      {
        memcpy(A_transpose[i1][j],
          sample,
          (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
      }
    }
  }
  memcpy(ret,
    A_transpose,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [3U][16U]));
}

void
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___3size_t_128size_t(
  uint8_t (*input)[33U],
  uint8_t ret[3U][128U]
)
{
  uint8_t out[3U][128U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    uint8_t *uu____0 = out[i0];
    libcrux_sha3_portable_shake256((size_t)128U,
      uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice),
      void *);
  }
  memcpy(ret, out, (size_t)3U * sizeof (uint8_t [128U]));
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector re_as_ntt[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(i,
      re_as_ntt[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[3U][33U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[3U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___3size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(re_as_ntt[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_binomially_sampled_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(&re_as_ntt[i0]);
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[3U][16U];
  memcpy(uu____2,
    re_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*self)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*rhs)[16U]
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)16U,
          self[0U],
          int16_t [16U],
          Eurydice_slice),
        int16_t [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    int16_t uu____0[16U];
    libcrux_ml_kem_libcrux_polynomials___libcrux_ml_kem__libcrux_polynomials__libcrux_traits__Operations_for_libcrux_ml_kem__libcrux_polynomials__PortableVector___add(self[0U][i0],
      &rhs[0U][i0],
      uu____0);
    memcpy(self[0U][i0], uu____0, (size_t)16U * sizeof (int16_t));
  }
}

inline void
libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_A)[3U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*s_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_matrix_compute_As_plus_e_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
          matrix_A,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [3U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [3U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = matrix_A[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*matrix_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(matrix_element,
        &s_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_standard_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_as_ntt[i1]);
  }
  memcpy(ret,
    result,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

K___uint8_t_1152size_t__uint8_t_1184size_t_
libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___3size_t(key_generation_seed,
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[3U][3U][16U];
  uint8_t ret[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(ret,
    true,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
  uu____2 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(uu____1,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[3U][16U];
  memcpy(secret_as_ntt,
    uu____2.fst,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_as_ntt[3U][16U];
  memcpy(error_as_ntt,
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(uu____3,
      domain_separator).fst,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[3U][16U];
  libcrux_ml_kem_matrix_compute_As_plus_e__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____4[3U][16U];
  memcpy(uu____4,
    t_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t public_key_serialized[1184U];
  libcrux_ml_kem_ind_cpa_serialize_public_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t_1184size_t(uu____4,
    seed_for_A,
    public_key_serialized);
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____5[3U][16U];
  memcpy(uu____5,
    secret_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t secret_key_serialized[1152U];
  libcrux_ml_kem_ind_cpa_serialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1152size_t(uu____5,
    secret_key_serialized);
  uint8_t uu____6[1152U];
  memcpy(uu____6, secret_key_serialized, (size_t)1152U * sizeof (uint8_t));
  uint8_t uu____7[1184U];
  memcpy(uu____7, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  K___uint8_t_1152size_t__uint8_t_1184size_t_ lit;
  memcpy(lit.fst, uu____6, (size_t)1152U * sizeof (uint8_t));
  memcpy(lit.snd, uu____7, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___3size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_sha256(Eurydice_array_to_slice((size_t)32U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2400size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[2400U]
)
{
  uint8_t out[2400U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice
  uu____6 =
    Eurydice_array_to_subslice((size_t)2400U,
      out,
      (
        (core_ops_range_Range__size_t){
          .start = pointer,
          .end = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  uint8_t ret0[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___3size_t(public_key,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  pointer = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE;
  uint8_t *uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)2400U * sizeof (uint8_t));
}

void
libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___2400size_t(
  uint8_t value[2400U],
  uint8_t ret[2400U]
)
{
  uint8_t uu____0[2400U];
  memcpy(uu____0, value, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)2400U * sizeof (uint8_t));
}

libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(
  uint8_t sk[2400U],
  uint8_t pk[1184U]
)
{
  libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t lit;
  memcpy(lit.sk, sk, (size_t)2400U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t
libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice ind_cpa_keypair_randomness,
  Eurydice_slice implicit_rejection_value
)
{
  K___uint8_t_1152size_t__uint8_t_1184size_t_
  uu____0 =
    libcrux_ml_kem_ind_cpa_generate_keypair__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1152U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)1152U * sizeof (uint8_t));
  uint8_t public_key[1184U];
  memcpy(public_key, uu____0.snd, (size_t)1184U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)1152U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[2400U];
  libcrux_ml_kem_ind_cca_serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2400size_t(uu____1,
    Eurydice_array_to_slice((size_t)1184U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[2400U];
  memcpy(uu____2, secret_key_serialized, (size_t)2400U * sizeof (uint8_t));
  uint8_t private_key[2400U];
  libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___2400size_t(uu____2,
    private_key);
  uint8_t uu____3[2400U];
  memcpy(uu____3, private_key, (size_t)2400U * sizeof (uint8_t));
  uint8_t uu____4[1184U];
  memcpy(uu____4, public_key, (size_t)1184U * sizeof (uint8_t));
  return
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(uu____3,
      uu____4);
}

libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t
libcrux_ml_kem_ind_cca_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  else
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  return uu____2;
}

libcrux_ml_kem_types_MlKemKeyPair____2400size_t__1184size_t
libcrux_ml_kem_mlkem768_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(uu____0);
}

uint8_t
*libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1184size_t(
  uint8_t (*self)[1184U]
)
{
  return self[0U];
}

void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1152size_t_3size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1152size_t_3size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector deserialized_pk[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_serialize_deserialize_ring_elements_reduced_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_1152size_t_3size_t(i,
      deserialized_pk[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(ring_element,
      uu____0);
    memcpy(deserialized_pk[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_128size_t_2size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_128size_t_2size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_128size_t_2size_t(i,
      error_1[i]);
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[3U][33U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[3U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___3size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____1[16U];
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_outputs[i0],
        uint8_t,
        Eurydice_slice),
      uu____1);
    memcpy(error_1[i0],
      uu____1,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____2[3U][16U];
  memcpy(uu____2,
    error_1,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  lit.snd = domain_separator;
  return lit;
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___3size_t_128size_t(
  Eurydice_slice input,
  uint8_t ret[128U]
)
{
  uint8_t digest[128U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)128U, digest, input, void *);
  memcpy(ret, digest, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  size_t _i,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*re)[16U]
)
{
  size_t zeta_i = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_1__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)1U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_2__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)2U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_3__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)3U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)4U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)5U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)6U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_libcrux_polynomials_PortableVector(&zeta_i,
    re,
    (size_t)7U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(re);
}

inline void
libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_as_ntt)[3U][16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_1)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_matrix_compute_vector_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(i,
      result[i]);
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
          a_as_ntt,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [3U][16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [3U][16U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_libcrux_polynomials_PortableVector (*row)[16U] = a_as_ntt[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
            row,
            libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
            Eurydice_slice),
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_libcrux_polynomials_PortableVector (*a_element)[16U] = &row[j];
      libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(a_element,
        &r_as_ntt[j],
        product);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result[i1]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(&result[i1],
      &error_1[i1]);
  }
  memcpy(ret,
    result,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*t_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*r_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*error_2)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*message)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&t_as_ntt[i0],
      &r_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_message_error_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(error_2,
    message,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_960size_t_10size_t_320size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector input[3U][16U],
  Eurydice_slice out
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
          input,
          libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
          Eurydice_slice),
        libcrux_ml_kem_libcrux_polynomials_PortableVector [16U],
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector re[16U];
    memcpy(re,
      input[i0],
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * ((size_t)960U / (size_t)3U),
            .end = (i0 + (size_t)1U) * ((size_t)960U / (size_t)3U)
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret[320U];
    libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t_320size_t(&re,
      ret);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)320U, ret, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

void
libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[1088U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector t_as_ntt[3U][16U];
  libcrux_ml_kem_serialize_deserialize_ring_elements_reduced__libcrux_ml_kem_libcrux_polynomials_PortableVector_1152size_t_3size_t(Eurydice_slice_subslice_to(public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    t_as_ntt);
  Eurydice_slice
  seed = Eurydice_slice_subslice_from(public_key, (size_t)1152U, uint8_t, size_t, Eurydice_slice);
  libcrux_ml_kem_libcrux_polynomials_PortableVector A_transpose[3U][3U][16U];
  uint8_t ret0[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed, ret0);
  libcrux_ml_kem_matrix_sample_matrix_A__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t(ret0,
    false,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
  uu____1 =
    libcrux_ml_kem_ind_cpa_sample_vector_cbd_then_ntt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2size_t_128size_t(uu____0,
      0U);
  libcrux_ml_kem_libcrux_polynomials_PortableVector r_as_ntt[3U][16U];
  memcpy(r_as_ntt,
    uu____1.fst,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator0 = uu____1.snd;
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t__uint8_t
  uu____3 =
    libcrux_ml_kem_ind_cpa_sample_ring_element_cbd__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_128size_t_2size_t(uu____2,
      domain_separator0);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_1[3U][16U];
  memcpy(error_1,
    uu____3.fst,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  uint8_t domain_separator = uu____3.snd;
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___3size_t_128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t,
      Eurydice_slice),
    prf_output);
  libcrux_ml_kem_libcrux_polynomials_PortableVector error_2[16U];
  libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_libcrux_polynomials_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t,
      Eurydice_slice),
    error_2);
  libcrux_ml_kem_libcrux_polynomials_PortableVector u[3U][16U];
  libcrux_ml_kem_matrix_compute_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(A_transpose,
    r_as_ntt,
    error_1,
    u);
  uint8_t uu____4[32U];
  memcpy(uu____4, message, (size_t)32U * sizeof (uint8_t));
  libcrux_ml_kem_libcrux_polynomials_PortableVector message_as_ring_element[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(uu____4,
    message_as_ring_element);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_matrix_compute_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  uint8_t ciphertext[1088U] = { 0U };
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____5 =
    core_slice___Slice_T___split_at_mut(Eurydice_array_to_slice((size_t)1088U,
        ciphertext,
        uint8_t,
        Eurydice_slice),
      (size_t)960U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice c1 = uu____5.fst;
  Eurydice_slice c2 = uu____5.snd;
  libcrux_ml_kem_libcrux_polynomials_PortableVector uu____6[3U][16U];
  memcpy(uu____6,
    u,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
  libcrux_ml_kem_ind_cpa_compress_then_serialize_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_960size_t_10size_t_320size_t(uu____6,
    c1);
  libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t_128size_t(v,
    c2);
  memcpy(ret, ciphertext, (size_t)1088U * sizeof (uint8_t));
}

K___libcrux_ml_kem_types_MlKemCiphertext___1088size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t,
      Eurydice_slice),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  uint8_t ret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___3size_t(Eurydice_array_to_slice((size_t)1184U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t,
      Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___3size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1184U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t,
      Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[1088U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
    uu____3,
    pseudorandomness,
    ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_slice((size_t)32U,
      shared_secret_array,
      uint8_t,
      Eurydice_slice),
    shared_secret,
    uint8_t,
    void *);
  uint8_t uu____4[1088U];
  memcpy(uu____4, ciphertext, (size_t)1088U * sizeof (uint8_t));
  uint8_t uu____5[1088U];
  memcpy(uu____5, uu____4, (size_t)1088U * sizeof (uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof (uint8_t));
  K___libcrux_ml_kem_types_MlKemCiphertext___1088size_t___uint8_t_32size_t_ lit;
  memcpy(lit.fst, uu____5, (size_t)1088U * sizeof (uint8_t));
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof (uint8_t));
  return lit;
}

K___libcrux_ml_kem_types_MlKemCiphertext___1088size_t___uint8_t_32size_t_
libcrux_ml_kem_ind_cca_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  K___libcrux_ml_kem_types_MlKemCiphertext___1088size_t___uint8_t_32size_t_ uu____2;
  if (uu____1)
  {
    uint8_t (*uu____3)[1184U] = public_key;
    uint8_t uu____4[32U];
    memcpy(uu____4, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____3,
        uu____4);
  }
  else
  {
    uint8_t (*uu____5)[1184U] = public_key;
    uint8_t uu____6[32U];
    memcpy(uu____6, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
        uu____6);
  }
  return uu____2;
}

K___libcrux_ml_kem_types_MlKemCiphertext___1088size_t___uint8_t_32size_t_
libcrux_ml_kem_mlkem768_encapsulate(uint8_t (*public_key)[1184U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1184U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_ml_kem_ind_cca_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___2400size_t(
  uint8_t (*self)[2400U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)2400U,
        self[0U],
        uint8_t,
        Eurydice_slice),
      mid,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
}

void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_10size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_10size_t(
  uint8_t *ciphertext,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_10size_t(i,
      u_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)1088U,
          ciphertext,
          uint8_t,
          Eurydice_slice),
        uint8_t,
        size_t)
      / (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U);
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    u_bytes =
      Eurydice_array_to_subslice((size_t)1088U,
        ciphertext,
        (
          (core_ops_range_Range__size_t){
            .start = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U),
            .end = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U)
            + LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(u_bytes,
      uu____0);
    memcpy(u_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
    libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_10size_t(&u_as_ntt[i0]);
  }
  memcpy(ret,
    u_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

void
libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  size_t _,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret0[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(ret0);
  memcpy(ret, ret0, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

inline void
libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  Eurydice_slice secret_key,
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[3U][16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[3U][16U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    libcrux_ml_kem_ind_cpa_deserialize_secret_key_closure__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(i,
      secret_as_ntt[i]);
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(secret_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    secret_bytes =
      Eurydice_slice_subslice(secret_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_libcrux_polynomials_PortableVector uu____0[16U];
    libcrux_ml_kem_serialize_deserialize_to_uncompressed_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector(secret_bytes,
      uu____0);
    memcpy(secret_as_ntt[i0],
      uu____0,
      (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
  }
  memcpy(ret,
    secret_as_ntt,
    (size_t)3U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector [16U]));
}

inline void
libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*v)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*secret_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector (*u_as_ntt)[16U],
  libcrux_ml_kem_libcrux_polynomials_PortableVector ret[16U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector result[16U];
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_libcrux_polynomials_PortableVector(result);
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_libcrux_polynomials_PortableVector product[16U];
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_libcrux_polynomials_PortableVector(&secret_as_ntt[i0],
      &u_as_ntt[i0],
      product);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result,
      &product);
  }
  libcrux_ml_kem_invert_ntt_invert_ntt_montgomery__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&result);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___subtract_reduce__libcrux_ml_kem_libcrux_polynomials_PortableVector(v,
    result,
    result);
  memcpy(ret, result, (size_t)16U * sizeof (libcrux_ml_kem_libcrux_polynomials_PortableVector));
}

void
libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_960size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  libcrux_ml_kem_libcrux_polynomials_PortableVector u_as_ntt[3U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_then_decompress_u__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_10size_t(ciphertext,
    u_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector v[16U];
  libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_libcrux_polynomials_PortableVector_4size_t(Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t,
      Eurydice_slice),
    v);
  libcrux_ml_kem_libcrux_polynomials_PortableVector secret_as_ntt[3U][16U];
  libcrux_ml_kem_ind_cpa_deserialize_secret_key__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(secret_key,
    secret_as_ntt);
  libcrux_ml_kem_libcrux_polynomials_PortableVector message[16U];
  libcrux_ml_kem_matrix_compute_message__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t(&v,
    secret_as_ntt,
    u_as_ntt,
    message);
  uint8_t ret0[32U];
  libcrux_ml_kem_serialize_compress_then_serialize_message__libcrux_ml_kem_libcrux_polynomials_PortableVector(message,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_ind_cpa_into_padded_array___1120size_t(Eurydice_slice slice, uint8_t ret[1120U])
{
  uint8_t out[1120U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1120U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1120U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1088size_t(
  uint8_t (*self)[1088U]
)
{
  return Eurydice_array_to_slice((size_t)1088U, self[0U], uint8_t, Eurydice_slice);
}

void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___3size_t_32size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_shake256((size_t)32U, digest, input, void *);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

uint8_t
libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  for (size_t i = (size_t)0U; i < (size_t)1088U; i++)
  {
    size_t i0 = i;
    uint8_t uu____0 = Eurydice_slice_index(lhs, i0, uint8_t, uint8_t);
    r =
      (uint32_t)r
      | ((uint32_t)uu____0 ^ (uint32_t)Eurydice_slice_index(rhs, i0, uint8_t, uint8_t));
  }
  return libcrux_ml_kem_constant_time_ops_is_non_zero(r);
}

void
libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*private_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPrivateKey_SIZE__12__split_at___2400size_t(private_key,
      (size_t)1152U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)1184U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_ml_kem_ind_cpa_decrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_3size_t_1088size_t_960size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___3size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1120U];
  libcrux_ml_kem_ind_cpa_into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1120U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1088size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___3size_t_32size_t(Eurydice_array_to_slice((size_t)1120U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  libcrux_ml_kem_ind_cpa_encrypt__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
    uu____6,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice
  uu____7 =
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___1088size_t(ciphertext);
  uint8_t
  selector =
    libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(uu____7,
      Eurydice_array_to_slice((size_t)1088U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_ml_kem_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_ind_cca_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*private_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  bool uu____0;
  uu____0 = false;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  uint8_t uu____2[32U];
  if (uu____1)
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(private_key,
      ciphertext,
      uu____2);
  }
  else
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_libcrux_polynomials_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___3size_t___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(private_key,
      ciphertext,
      uu____2);
    memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
    return;
  }
  memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_mlkem768_decapsulate(
  uint8_t (*private_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_ml_kem_ind_cca_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(private_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

