/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: ../../../eurydice/eurydice --config ../../kyber-c.yaml ../libcrux_kyber.llbc
  F* version: c990b3ca
  KaRaMeL version: 63d581ed
 */

#include "internal/libcrux_kyber768.h"

#include "internal/libcrux_kyber_common.h"
#include "internal/core.h"
#include "libcrux_hacl_glue.h"

static inline void
deserialize_ring_elements_reduced___1184size_t_3size_t(
  Eurydice_slice public_key,
  int32_t ret[3U][256U]
)
{
  int32_t deserialized_pk[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(deserialized_pk[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(public_key,
            uint8_t,
            size_t)
          / LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      ring_element =
        Eurydice_slice_subslice(public_key,
          (
            (core_ops_range_Range__size_t){
              .start = i * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT,
              .end = i
              * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
              + LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t uu____1[256U];
      libcrux_kyber_serialize_deserialize_to_reduced_ring_element(ring_element, uu____1);
      memcpy(deserialized_pk[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  memcpy(ret, deserialized_pk, (size_t)3U * sizeof (int32_t [256U]));
}

static inline void
serialize_secret_key___3size_t_1152size_t(int32_t key[3U][256U], uint8_t ret[1152U])
{
  uint8_t out[1152U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        key,
        int32_t [256U],
        Eurydice_slice),
      int32_t [256U],
      size_t);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t re[256U];
      memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
      Eurydice_slice
      uu____1 =
        Eurydice_array_to_subslice((size_t)1152U,
          out,
          (
            (core_ops_range_Range__size_t){
              .start = i * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT,
              .end = (i + (size_t)1U) * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint8_t ret0[384U];
      libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret0);
      core_slice___Slice_T___copy_from_slice(uu____1,
        Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
        uint8_t,
        void *);
    }
  }
  memcpy(ret, out, (size_t)1152U * sizeof (uint8_t));
}

static inline void
serialize_public_key___3size_t_1152size_t_1184size_t(
  int32_t t_as_ntt[3U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1184U]
)
{
  uint8_t public_key_serialized[1184U] = { 0U };
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1184U,
      public_key_serialized,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)1152U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  int32_t uu____1[3U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t ret0[1152U];
  serialize_secret_key___3size_t_1152size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1152U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1184U,
      public_key_serialized,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    seed_for_a,
    uint8_t,
    void *);
  memcpy(ret, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
}

static bool validate_public_key___3size_t_1152size_t_1184size_t(uint8_t *public_key)
{
  int32_t deserialized_pk[3U][256U];
  deserialize_ring_elements_reduced___1184size_t_3size_t(Eurydice_array_to_subslice_to((size_t)1184U,
      public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    deserialized_pk);
  int32_t uu____0[3U][256U];
  memcpy(uu____0, deserialized_pk, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1184U];
  serialize_public_key___3size_t_1152size_t_1184size_t(uu____0,
    Eurydice_array_to_subslice_from((size_t)1184U,
      public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    public_key_serialized);
  return
    core_array_equality___core__cmp__PartialEq__Array_B__N___for__Array_A__N____eq((size_t)1184U,
      public_key,
      public_key_serialized,
      uint8_t,
      uint8_t,
      bool);
}

core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__
libcrux_kyber_kyber768_validate_public_key(uint8_t public_key[1184U])
{
  core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__ uu____0;
  if (validate_public_key___3size_t_1152size_t_1184size_t(public_key))
  {
    core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__ lit;
    lit.tag = core_option_Some;
    memcpy(lit.f0, public_key, (size_t)1184U * sizeof (uint8_t));
    uu____0 = lit;
  }
  else
  {
    uu____0 =
      (
        (core_option_Option__libcrux_kyber_types_MlKemPublicKey__1184size_t__){
          .tag = core_option_None
        }
      );
  }
  return uu____0;
}

static inline libcrux_digest_incremental_x4_Shake128StateX4
absorb___3size_t(uint8_t input[3U][34U])
{
  libcrux_digest_incremental_x4_Shake128StateX4
  state = libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__new();
  Eurydice_slice data[3U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    uint8_t buf[1U] = { 0U };
    data[i] = Eurydice_array_to_slice((size_t)1U, buf, uint8_t, Eurydice_slice);
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      uu____1 = Eurydice_array_to_slice((size_t)34U, input[i], uint8_t, Eurydice_slice);
      data[i] = uu____1;
    }
  }
  libcrux_digest_incremental_x4_Shake128StateX4 *uu____2 = &state;
  Eurydice_slice uu____3[3U];
  memcpy(uu____3, data, (size_t)3U * sizeof (Eurydice_slice));
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__absorb_final((size_t)3U,
    uu____2,
    uu____3,
    void *);
  return state;
}

static inline void
squeeze_three_blocks___3size_t(
  libcrux_digest_incremental_x4_Shake128StateX4 *xof_state,
  uint8_t ret[3U][504U]
)
{
  uint8_t output[3U][504U];
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__squeeze_blocks((size_t)504U,
    (size_t)3U,
    xof_state,
    output,
    void *);
  uint8_t out[3U][504U] = { { 0U } };
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      uint8_t uu____1[504U];
      memcpy(uu____1, output[i], (size_t)504U * sizeof (uint8_t));
      memcpy(out[i], uu____1, (size_t)504U * sizeof (uint8_t));
    }
  }
  memcpy(ret, out, (size_t)3U * sizeof (uint8_t [504U]));
}

static bool
sample_from_uniform_distribution_next___3size_t_504size_t(
  uint8_t randomness[3U][504U],
  size_t *sampled_coefficients,
  int32_t (*out)[256U]
)
{
  bool done = true;
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      core_slice_iter_Chunks
      iter =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(core_slice___Slice_T___chunks(Eurydice_array_to_slice((size_t)504U,
              randomness[i],
              uint8_t,
              Eurydice_slice),
            (size_t)3U,
            uint8_t,
            core_slice_iter_Chunks),
          core_slice_iter_Chunks,
          core_slice_iter_Chunks);
      while (true)
      {
        core_option_Option__Eurydice_slice_uint8_t
        uu____1 =
          core_slice_iter___core__iter__traits__iterator__Iterator_for_core__slice__iter__Chunks__a__T___70__next(&iter,
            uint8_t,
            core_option_Option__Eurydice_slice_uint8_t);
        if (uu____1.tag == core_option_None)
        {
          break;
        }
        else
        {
          Eurydice_slice bytes = uu____1.f0;
          int32_t b1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
          int32_t b2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
          int32_t b3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____2;
          if (d1 < LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS)
          {
            uu____2 = sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
          }
          else
          {
            uu____2 = false;
          }
          if (uu____2)
          {
            out[i][sampled_coefficients[i]] = d1;
            size_t uu____3 = i;
            sampled_coefficients[uu____3] = sampled_coefficients[uu____3] + (size_t)1U;
          }
          bool uu____4;
          if (d2 < LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS)
          {
            uu____4 = sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
          }
          else
          {
            uu____4 = false;
          }
          if (uu____4)
          {
            out[i][sampled_coefficients[i]] = d2;
            size_t uu____5 = i;
            sampled_coefficients[uu____5] = sampled_coefficients[uu____5] + (size_t)1U;
          }
        }
      }
      if (sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        done = false;
      }
    }
  }
  return done;
}

static inline void
squeeze_block___3size_t(
  libcrux_digest_incremental_x4_Shake128StateX4 *xof_state,
  uint8_t ret[3U][168U]
)
{
  uint8_t output[3U][168U];
  libcrux_digest_incremental_x4__libcrux__digest__incremental_x4__Shake128StateX4__squeeze_blocks((size_t)168U,
    (size_t)3U,
    xof_state,
    output,
    void *);
  uint8_t out[3U][168U] = { { 0U } };
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      uint8_t uu____1[168U];
      memcpy(uu____1, output[i], (size_t)168U * sizeof (uint8_t));
      memcpy(out[i], uu____1, (size_t)168U * sizeof (uint8_t));
    }
  }
  memcpy(ret, out, (size_t)3U * sizeof (uint8_t [168U]));
}

static bool
sample_from_uniform_distribution_next___3size_t_168size_t(
  uint8_t randomness[3U][168U],
  size_t *sampled_coefficients,
  int32_t (*out)[256U]
)
{
  bool done = true;
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      core_slice_iter_Chunks
      iter =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(core_slice___Slice_T___chunks(Eurydice_array_to_slice((size_t)168U,
              randomness[i],
              uint8_t,
              Eurydice_slice),
            (size_t)3U,
            uint8_t,
            core_slice_iter_Chunks),
          core_slice_iter_Chunks,
          core_slice_iter_Chunks);
      while (true)
      {
        core_option_Option__Eurydice_slice_uint8_t
        uu____1 =
          core_slice_iter___core__iter__traits__iterator__Iterator_for_core__slice__iter__Chunks__a__T___70__next(&iter,
            uint8_t,
            core_option_Option__Eurydice_slice_uint8_t);
        if (uu____1.tag == core_option_None)
        {
          break;
        }
        else
        {
          Eurydice_slice bytes = uu____1.f0;
          int32_t b1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t, uint8_t);
          int32_t b2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t, uint8_t);
          int32_t b3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____2;
          if (d1 < LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS)
          {
            uu____2 = sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
          }
          else
          {
            uu____2 = false;
          }
          if (uu____2)
          {
            out[i][sampled_coefficients[i]] = d1;
            size_t uu____3 = i;
            sampled_coefficients[uu____3] = sampled_coefficients[uu____3] + (size_t)1U;
          }
          bool uu____4;
          if (d2 < LIBCRUX_KYBER_CONSTANTS_FIELD_MODULUS)
          {
            uu____4 = sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
          }
          else
          {
            uu____4 = false;
          }
          if (uu____4)
          {
            out[i][sampled_coefficients[i]] = d2;
            size_t uu____5 = i;
            sampled_coefficients[uu____5] = sampled_coefficients[uu____5] + (size_t)1U;
          }
        }
      }
      if (sampled_coefficients[i] < LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        done = false;
      }
    }
  }
  return done;
}

static void sample_from_xof___3size_t(uint8_t seeds[3U][34U], int32_t ret[3U][256U])
{
  size_t sampled_coefficients[3U] = { 0U };
  int32_t out[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(out[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  uint8_t uu____0[3U][34U];
  memcpy(uu____0, seeds, (size_t)3U * sizeof (uint8_t [34U]));
  libcrux_digest_incremental_x4_Shake128StateX4 xof_state = absorb___3size_t(uu____0);
  uint8_t randomness0[3U][504U];
  squeeze_three_blocks___3size_t(&xof_state, randomness0);
  uint8_t uu____1[3U][504U];
  memcpy(uu____1, randomness0, (size_t)3U * sizeof (uint8_t [504U]));
  bool
  done =
    sample_from_uniform_distribution_next___3size_t_504size_t(uu____1,
      sampled_coefficients,
      out);
  while (true)
  {
    if (!!done)
    {
      break;
    }
    uint8_t randomness[3U][168U];
    squeeze_block___3size_t(&xof_state, randomness);
    uint8_t uu____2[3U][168U];
    memcpy(uu____2, randomness, (size_t)3U * sizeof (uint8_t [168U]));
    done =
      sample_from_uniform_distribution_next___3size_t_168size_t(uu____2,
        sampled_coefficients,
        out);
  }
  libcrux_kyber_hash_functions_free_state(xof_state);
  memcpy(ret, out, (size_t)3U * sizeof (int32_t [256U]));
}

static inline void
sample_matrix_A___3size_t(uint8_t seed[34U], bool transpose, int32_t ret[3U][3U][256U])
{
  int32_t A_transpose[3U][3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(A_transpose[i][0U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
    memcpy(A_transpose[i][1U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
    memcpy(A_transpose[i][2U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i0 = uu____0.f0;
      uint8_t uu____1[34U];
      memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
      uint8_t seeds[3U][34U];
      for (size_t i = (size_t)0U; i < (size_t)3U; i++)
      {
        memcpy(seeds[i], uu____1, (size_t)34U * sizeof (uint8_t));
      }
      core_ops_range_Range__size_t
      iter1 =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____2 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter1,
            size_t,
            core_option_Option__size_t);
        if (uu____2.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____2.f0;
          seeds[j][32U] = (uint8_t)i0;
          seeds[j][33U] = (uint8_t)j;
        }
      }
      uint8_t uu____3[3U][34U];
      memcpy(uu____3, seeds, (size_t)3U * sizeof (uint8_t [34U]));
      int32_t sampled[3U][256U];
      sample_from_xof___3size_t(uu____3, sampled);
      core_ops_range_Range__size_t
      iter =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____4 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
            size_t,
            core_option_Option__size_t);
        if (uu____4.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____4.f0;
          if (transpose)
          {
            memcpy(A_transpose[j][i0], sampled[j], (size_t)256U * sizeof (int32_t));
          }
          else
          {
            memcpy(A_transpose[i0][j], sampled[j], (size_t)256U * sizeof (int32_t));
          }
        }
      }
    }
  }
  memcpy(ret, A_transpose, (size_t)3U * sizeof (int32_t [3U][256U]));
}

void libcrux_kyber_ind_cpa_into_padded_array___34size_t(Eurydice_slice slice, uint8_t ret[34U])
{
  uint8_t out[34U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)34U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)34U * sizeof (uint8_t));
}

void libcrux_kyber_ind_cpa_into_padded_array___33size_t(Eurydice_slice slice, uint8_t ret[33U])
{
  uint8_t out[33U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)33U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)33U * sizeof (uint8_t));
}

void libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_slice input, uint8_t ret[128U])
{
  uint8_t ret0[128U];
  libcrux_digest_shake256((size_t)128U, input, ret0, void *);
  memcpy(ret, ret0, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution_2(randomness, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

typedef struct __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t_s
{
  int32_t fst[3U][256U];
  uint8_t snd;
}
__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t;

static inline __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(re_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      prf_input[32U] = domain_separator;
      domain_separator = (uint32_t)domain_separator + 1U;
      uint8_t prf_output[128U];
      libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
          prf_input,
          uint8_t,
          Eurydice_slice),
        prf_output);
      int32_t r[256U];
      libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
          prf_output,
          uint8_t,
          Eurydice_slice),
        r);
      int32_t uu____1[256U];
      libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
      memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  int32_t uu____2[3U][256U];
  memcpy(uu____2, re_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t lit;
  memcpy(lit.fst, uu____2, (size_t)3U * sizeof (int32_t [256U]));
  lit.snd = domain_separator;
  return lit;
}

static void
add_to_ring_element___3size_t(int32_t lhs[256U], int32_t (*rhs)[256U], int32_t ret[256U])
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t, Eurydice_slice),
      int32_t,
      size_t);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      size_t uu____1 = i;
      lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
    }
  }
  memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
}

static inline void
compute_As_plus_e___3size_t(
  int32_t (*matrix_A)[3U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        matrix_A,
        Eurydice_error_t_cg_array,
        Eurydice_slice),
      int32_t [3U][256U],
      size_t);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit0,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t (*row)[256U] = matrix_A[i];
      core_ops_range_Range__size_t lit;
      lit.start = (size_t)0U;
      lit.end =
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
            row,
            int32_t [256U],
            Eurydice_slice),
          int32_t [256U],
          size_t);
      core_ops_range_Range__size_t
      iter0 =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____1 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
            size_t,
            core_option_Option__size_t);
        if (uu____1.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____1.f0;
          int32_t (*matrix_element)[256U] = &row[j];
          int32_t product[256U];
          libcrux_kyber_ntt_ntt_multiply(matrix_element, &s_as_ntt[j], product);
          int32_t uu____2[256U];
          add_to_ring_element___3size_t(result[i], &product, uu____2);
          memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
        }
      }
      core_ops_range_Range__size_t
      iter1 =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){
              .start = (size_t)0U,
              .end = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT
            }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____3 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter1,
            size_t,
            core_option_Option__size_t);
        if (uu____3.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____3.f0;
          int32_t
          coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
          int32_t
          uu____4 =
            libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
          result[i][j] = uu____4;
        }
      }
    }
  }
  memcpy(ret, result, (size_t)3U * sizeof (int32_t [256U]));
}

typedef struct
__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__s
{
  int32_t fst[3U][256U];
  int32_t snd[3U][256U];
  int32_t thd[3U][3U][256U];
}
__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t_;

typedef struct
__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t__s
{
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t_
  fst;
  uint8_t snd[1184U];
}
__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t_;

static __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t_
generate_keypair_unpacked___3size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  int32_t a_transpose[3U][3U][256U];
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  sample_matrix_A___3size_t(ret, true, a_transpose);
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____2 = sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____1, 0U);
  int32_t secret_as_ntt[3U][256U];
  memcpy(secret_as_ntt, uu____2.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[3U][256U];
  memcpy(error_as_ntt,
    sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____3, domain_separator).fst,
    (size_t)3U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[3U][256U];
  compute_As_plus_e___3size_t(a_transpose, secret_as_ntt, error_as_ntt, t_as_ntt);
  int32_t uu____4[3U][256U];
  memcpy(uu____4, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1184U];
  serialize_public_key___3size_t_1152size_t_1184size_t(uu____4,
    seed_for_A,
    public_key_serialized);
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____5 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____5.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____5.f0;
      core_ops_range_Range__size_t
      iter =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)256U }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____6 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
            size_t,
            core_option_Option__size_t);
        if (uu____6.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____6.f0;
          uint16_t
          uu____7 = libcrux_kyber_arithmetic_to_unsigned_representative(secret_as_ntt[i][j]);
          secret_as_ntt[i][j] = (int32_t)uu____7;
          uint16_t uu____8 = libcrux_kyber_arithmetic_to_unsigned_representative(t_as_ntt[i][j]);
          t_as_ntt[i][j] = (int32_t)uu____8;
        }
      }
    }
  }
  int32_t a_matrix[3U][3U][256U];
  memcpy(a_matrix, a_transpose, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_ops_range_Range__size_t
  iter1 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____9 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter1,
        size_t,
        core_option_Option__size_t);
    if (uu____9.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____9.f0;
      core_ops_range_Range__size_t
      iter =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____10 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
            size_t,
            core_option_Option__size_t);
        if (uu____10.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____10.f0;
          memcpy(a_matrix[i][j], a_transpose[j][i], (size_t)256U * sizeof (int32_t));
        }
      }
    }
  }
  int32_t uu____11[3U][256U];
  memcpy(uu____11, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  int32_t uu____12[3U][256U];
  memcpy(uu____12, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  int32_t uu____13[3U][3U][256U];
  memcpy(uu____13, a_matrix, (size_t)3U * sizeof (int32_t [3U][256U]));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t_
  uu____14;
  memcpy(uu____14.fst, uu____11, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(uu____14.snd, uu____12, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(uu____14.thd, uu____13, (size_t)3U * sizeof (int32_t [3U][256U]));
  uint8_t uu____15[1184U];
  memcpy(uu____15, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t_
  lit;
  lit.fst = uu____14;
  memcpy(lit.snd, uu____15, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

typedef struct __uint8_t_1152size_t__uint8_t_1184size_t__s
{
  uint8_t fst[1152U];
  uint8_t snd[1184U];
}
__uint8_t_1152size_t__uint8_t_1184size_t_;

static __uint8_t_1152size_t__uint8_t_1184size_t_
generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t_
  uu____0 =
    generate_keypair_unpacked___3size_t_1184size_t_1152size_t_2size_t_128size_t(key_generation_seed);
  int32_t secret_as_ntt[3U][256U];
  memcpy(secret_as_ntt, uu____0.fst.fst, (size_t)3U * sizeof (int32_t [256U]));
  int32_t _t_as_ntt[3U][256U];
  memcpy(_t_as_ntt, uu____0.fst.snd, (size_t)3U * sizeof (int32_t [256U]));
  int32_t _a_transpose[3U][3U][256U];
  memcpy(_a_transpose, uu____0.fst.thd, (size_t)3U * sizeof (int32_t [3U][256U]));
  uint8_t public_key_serialized[1184U];
  memcpy(public_key_serialized, uu____0.snd, (size_t)1184U * sizeof (uint8_t));
  int32_t uu____1[3U][256U];
  memcpy(uu____1, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1152U];
  serialize_secret_key___3size_t_1152size_t(uu____1, secret_key_serialized);
  uint8_t uu____2[1152U];
  memcpy(uu____2, secret_key_serialized, (size_t)1152U * sizeof (uint8_t));
  uint8_t uu____3[1184U];
  memcpy(uu____3, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  __uint8_t_1152size_t__uint8_t_1184size_t_ lit;
  memcpy(lit.fst, uu____2, (size_t)1152U * sizeof (uint8_t));
  memcpy(lit.snd, uu____3, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

static inline void
serialize_kem_secret_key___2400size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[2400U]
)
{
  uint8_t out[2400U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice
  uu____6 =
    Eurydice_array_to_subslice((size_t)2400U,
      out,
      (
        (core_ops_range_Range__size_t){
          .start = pointer,
          .end = pointer + LIBCRUX_KYBER_CONSTANTS_H_DIGEST_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  pointer = pointer + LIBCRUX_KYBER_CONSTANTS_H_DIGEST_SIZE;
  uint8_t *uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)2400U * sizeof (uint8_t));
}

typedef uint8_t MlKemPrivateKey___2400size_t[2400U];

static void from___2400size_t(uint8_t value[2400U], uint8_t ret[2400U])
{
  uint8_t uu____0[2400U];
  memcpy(uu____0, value, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)2400U * sizeof (uint8_t));
}

static libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
from___2400size_t_1184size_t(uint8_t sk[2400U], uint8_t pk[1184U])
{
  libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t lit;
  memcpy(lit.sk, sk, (size_t)2400U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

static libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_KYBER_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_KYBER_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  __uint8_t_1152size_t__uint8_t_1184size_t_
  uu____0 =
    generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1152U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)1152U * sizeof (uint8_t));
  uint8_t public_key[1184U];
  memcpy(public_key, uu____0.snd, (size_t)1184U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)1152U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[2400U];
  serialize_kem_secret_key___2400size_t(uu____1,
    Eurydice_array_to_slice((size_t)1184U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[2400U];
  memcpy(uu____2, secret_key_serialized, (size_t)2400U * sizeof (uint8_t));
  uint8_t private_key[2400U];
  from___2400size_t(uu____2, private_key);
  uint8_t uu____3[2400U];
  memcpy(uu____3, private_key, (size_t)2400U * sizeof (uint8_t));
  uint8_t uu____4[1184U];
  memcpy(uu____4, public_key, (size_t)1184U * sizeof (uint8_t));
  return from___2400size_t_1184size_t(uu____3, uu____4);
}

libcrux_kyber_types_MlKemKeyPair___2400size_t_1184size_t
libcrux_kyber_kyber768_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(uu____0);
}

void
core_result__core__result__Result_T__E___unwrap__uint8_t_32size_t__core_array_TryFromSliceError(
  core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError self,
  uint8_t ret[32U]
)
{
  if (self.tag == core_result_Ok)
  {
    uint8_t f0[32U];
    memcpy(f0, self.val.case_Ok, (size_t)32U * sizeof (uint8_t));
    memcpy(ret, f0, (size_t)32U * sizeof (uint8_t));
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "unwrap not Ok");
    KRML_HOST_EXIT(255U);
  }
}

static void from___1184size_t(uint8_t value[1184U], uint8_t ret[1184U])
{
  uint8_t uu____0[1184U];
  memcpy(uu____0, value, (size_t)1184U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)1184U * sizeof (uint8_t));
}

static K___libcrux_kyber_MlKemState__3size_t___libcrux_kyber_types_MlKemPublicKey__1184size_t__
generate_keypair_unpacked___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_KYBER_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_KYBER_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t____libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__uint8_t_1184size_t_
  uu____0 =
    generate_keypair_unpacked___3size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  int32_t secret_as_ntt[3U][256U];
  memcpy(secret_as_ntt, uu____0.fst.fst, (size_t)3U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[3U][256U];
  memcpy(t_as_ntt, uu____0.fst.snd, (size_t)3U * sizeof (int32_t [256U]));
  int32_t a_transpose[3U][3U][256U];
  memcpy(a_transpose, uu____0.fst.thd, (size_t)3U * sizeof (int32_t [3U][256U]));
  uint8_t ind_cpa_public_key[1184U];
  memcpy(ind_cpa_public_key, uu____0.snd, (size_t)1184U * sizeof (uint8_t));
  uint8_t ind_cpa_public_key_hash[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1184U,
      ind_cpa_public_key,
      uint8_t,
      Eurydice_slice),
    ind_cpa_public_key_hash);
  uint8_t rej[32U];
  core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError dst;
  Eurydice_slice_to_array2(&dst,
    implicit_rejection_value,
    Eurydice_slice,
    uint8_t [32U],
    void *);
  core_result__core__result__Result_T__E___unwrap__uint8_t_32size_t__core_array_TryFromSliceError(dst,
    rej);
  uint8_t uu____1[1184U];
  memcpy(uu____1, ind_cpa_public_key, (size_t)1184U * sizeof (uint8_t));
  uint8_t pubkey[1184U];
  from___1184size_t(uu____1, pubkey);
  int32_t uu____2[3U][256U];
  memcpy(uu____2, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  int32_t uu____3[3U][256U];
  memcpy(uu____3, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  int32_t uu____4[3U][3U][256U];
  memcpy(uu____4, a_transpose, (size_t)3U * sizeof (int32_t [3U][256U]));
  uint8_t uu____5[32U];
  memcpy(uu____5, rej, (size_t)32U * sizeof (uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, ind_cpa_public_key_hash, (size_t)32U * sizeof (uint8_t));
  K___libcrux_kyber_MlKemState__3size_t___libcrux_kyber_types_MlKemPublicKey__1184size_t__ lit;
  memcpy(lit.fst.secret_as_ntt, uu____2, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(lit.fst.t_as_ntt, uu____3, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(lit.fst.a_transpose, uu____4, (size_t)3U * sizeof (int32_t [3U][256U]));
  memcpy(lit.fst.rej, uu____5, (size_t)32U * sizeof (uint8_t));
  memcpy(lit.fst.ind_cpa_public_key_hash, uu____6, (size_t)32U * sizeof (uint8_t));
  memcpy(lit.snd, pubkey, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

K___libcrux_kyber_MlKemState__3size_t___libcrux_kyber_types_MlKemPublicKey__1184size_t__
libcrux_kyber_kyber768_generate_key_pair_unpacked(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    generate_keypair_unpacked___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(uu____0);
}

void libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_slice slice, uint8_t ret[64U])
{
  uint8_t out[64U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)64U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)64U * sizeof (uint8_t));
}

static uint8_t *as_slice___1184size_t(uint8_t (*self)[1184U])
{
  return self[0U];
}

static inline void
deserialize_ring_elements_reduced___1152size_t_3size_t(
  Eurydice_slice public_key,
  int32_t ret[3U][256U]
)
{
  int32_t deserialized_pk[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(deserialized_pk[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(public_key,
            uint8_t,
            size_t)
          / LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      ring_element =
        Eurydice_slice_subslice(public_key,
          (
            (core_ops_range_Range__size_t){
              .start = i * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT,
              .end = i
              * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
              + LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t uu____1[256U];
      libcrux_kyber_serialize_deserialize_to_reduced_ring_element(ring_element, uu____1);
      memcpy(deserialized_pk[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  memcpy(ret, deserialized_pk, (size_t)3U * sizeof (int32_t [256U]));
}

static inline void
sample_ring_element_cbd___3size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[3U][256U]
)
{
  int32_t error_1[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(error_1[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      prf_input[32U] = domain_separator[0U];
      domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
      uint8_t prf_output[128U];
      libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
          prf_input,
          uint8_t,
          Eurydice_slice),
        prf_output);
      int32_t uu____1[256U];
      libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
          prf_output,
          uint8_t,
          Eurydice_slice),
        uu____1);
      memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  memcpy(ret, error_1, (size_t)3U * sizeof (int32_t [256U]));
}

static inline void invert_ntt_montgomery___3size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)2U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
      re[i] = uu____1;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
compute_vector_u___3size_t(
  int32_t (*a_as_ntt)[3U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        a_as_ntt,
        Eurydice_error_t_cg_array,
        Eurydice_slice),
      int32_t [3U][256U],
      size_t);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit0,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t (*row)[256U] = a_as_ntt[i];
      core_ops_range_Range__size_t lit;
      lit.start = (size_t)0U;
      lit.end =
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
            row,
            int32_t [256U],
            Eurydice_slice),
          int32_t [256U],
          size_t);
      core_ops_range_Range__size_t
      iter0 =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____1 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
            size_t,
            core_option_Option__size_t);
        if (uu____1.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____1.f0;
          int32_t (*a_element)[256U] = &row[j];
          int32_t product[256U];
          libcrux_kyber_ntt_ntt_multiply(a_element, &r_as_ntt[j], product);
          int32_t uu____2[256U];
          add_to_ring_element___3size_t(result[i], &product, uu____2);
          memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
        }
      }
      int32_t uu____3[256U];
      invert_ntt_montgomery___3size_t(result[i], uu____3);
      memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
      core_ops_range_Range__size_t
      iter1 =
        core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
            (core_ops_range_Range__size_t){
              .start = (size_t)0U,
              .end = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT
            }
          ),
          core_ops_range_Range__size_t,
          core_ops_range_Range__size_t);
      while (true)
      {
        core_option_Option__size_t
        uu____4 =
          core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter1,
            size_t,
            core_option_Option__size_t);
        if (uu____4.tag == core_option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____4.f0;
          int32_t
          coefficient_normal_form =
            libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
          int32_t
          uu____5 = libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
          result[i][j] = uu____5;
        }
      }
    }
  }
  memcpy(ret, result, (size_t)3U * sizeof (int32_t [256U]));
}

static inline void
compute_ring_element_v___3size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      add_to_ring_element___3size_t(result, &product, result);
    }
  }
  invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____1.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____1.f0;
      int32_t
      coefficient_normal_form =
        libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
      int32_t
      uu____2 =
        libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
          + error_2[0U][i]
          + message[0U][i]);
      result[i] = uu____2;
    }
  }
  memcpy(ret, result, (size_t)256U * sizeof (int32_t));
}

static inline void compress_then_serialize_10___320size_t(int32_t re[256U], uint8_t ret[320U])
{
  uint8_t serialized[320U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t)
    / (size_t)4U;
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      coefficients =
        Eurydice_array_to_subslice((size_t)256U,
          re,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)4U,
              .end = i * (size_t)4U + (size_t)4U
            }
          ),
          int32_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t
      coefficient1 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)0U,
              int32_t,
              int32_t)));
      int32_t
      coefficient2 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)1U,
              int32_t,
              int32_t)));
      int32_t
      coefficient3 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)2U,
              int32_t,
              int32_t)));
      int32_t
      coefficient4 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)3U,
              int32_t,
              int32_t)));
      K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
      uu____1 =
        libcrux_kyber_serialize_compress_coefficients_10(coefficient1,
          coefficient2,
          coefficient3,
          coefficient4);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      serialized[(size_t)5U * i] = coef1;
      serialized[(size_t)5U * i + (size_t)1U] = coef2;
      serialized[(size_t)5U * i + (size_t)2U] = coef3;
      serialized[(size_t)5U * i + (size_t)3U] = coef4;
      serialized[(size_t)5U * i + (size_t)4U] = coef5;
    }
  }
  memcpy(ret, serialized, (size_t)320U * sizeof (uint8_t));
}

static inline void compress_then_serialize_11___320size_t(int32_t re[256U], uint8_t ret[320U])
{
  uint8_t serialized[320U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      coefficients =
        Eurydice_array_to_subslice((size_t)256U,
          re,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)8U,
              .end = i * (size_t)8U + (size_t)8U
            }
          ),
          int32_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t
      coefficient1 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)0U,
              int32_t,
              int32_t)));
      int32_t
      coefficient2 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)1U,
              int32_t,
              int32_t)));
      int32_t
      coefficient3 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)2U,
              int32_t,
              int32_t)));
      int32_t
      coefficient4 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)3U,
              int32_t,
              int32_t)));
      int32_t
      coefficient5 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)4U,
              int32_t,
              int32_t)));
      int32_t
      coefficient6 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)5U,
              int32_t,
              int32_t)));
      int32_t
      coefficient7 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)6U,
              int32_t,
              int32_t)));
      int32_t
      coefficient8 =
        libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)7U,
              int32_t,
              int32_t)));
      K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
      uu____1 =
        libcrux_kyber_serialize_compress_coefficients_11(coefficient1,
          coefficient2,
          coefficient3,
          coefficient4,
          coefficient5,
          coefficient6,
          coefficient7,
          coefficient8);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      uint8_t coef6 = uu____1.f5;
      uint8_t coef7 = uu____1.f6;
      uint8_t coef8 = uu____1.f7;
      uint8_t coef9 = uu____1.f8;
      uint8_t coef10 = uu____1.f9;
      uint8_t coef11 = uu____1.f10;
      serialized[(size_t)11U * i] = coef1;
      serialized[(size_t)11U * i + (size_t)1U] = coef2;
      serialized[(size_t)11U * i + (size_t)2U] = coef3;
      serialized[(size_t)11U * i + (size_t)3U] = coef4;
      serialized[(size_t)11U * i + (size_t)4U] = coef5;
      serialized[(size_t)11U * i + (size_t)5U] = coef6;
      serialized[(size_t)11U * i + (size_t)6U] = coef7;
      serialized[(size_t)11U * i + (size_t)7U] = coef8;
      serialized[(size_t)11U * i + (size_t)8U] = coef9;
      serialized[(size_t)11U * i + (size_t)9U] = coef10;
      serialized[(size_t)11U * i + (size_t)10U] = coef11;
    }
  }
  memcpy(ret, serialized, (size_t)320U * sizeof (uint8_t));
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t uu____0[320U];
  compress_then_serialize_10___320size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)320U * sizeof (uint8_t));
}

static void
compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(
  int32_t input[3U][256U],
  uint8_t ret[960U]
)
{
  uint8_t out[960U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        input,
        int32_t [256U],
        Eurydice_slice),
      int32_t [256U],
      size_t);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t re[256U];
      memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
      Eurydice_slice
      uu____1 =
        Eurydice_array_to_subslice((size_t)960U,
          out,
          (
            (core_ops_range_Range__size_t){
              .start = i * ((size_t)960U / (size_t)3U),
              .end = (i + (size_t)1U) * ((size_t)960U / (size_t)3U)
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint8_t ret0[320U];
      libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(re, ret0);
      core_slice___Slice_T___copy_from_slice(uu____1,
        Eurydice_array_to_slice((size_t)320U, ret0, uint8_t, Eurydice_slice),
        uint8_t,
        void *);
    }
  }
  memcpy(ret, out, (size_t)960U * sizeof (uint8_t));
}

static inline void compress_then_serialize_4___128size_t(int32_t re[256U], uint8_t ret[128U])
{
  uint8_t serialized[128U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      coefficients =
        Eurydice_array_to_subslice((size_t)256U,
          re,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)2U,
              .end = i * (size_t)2U + (size_t)2U
            }
          ),
          int32_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint8_t
      coefficient1 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)0U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient2 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)1U,
              int32_t,
              int32_t)));
      serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
    }
  }
  memcpy(ret, serialized, (size_t)128U * sizeof (uint8_t));
}

static inline void compress_then_serialize_5___128size_t(int32_t re[256U], uint8_t ret[128U])
{
  uint8_t serialized[128U] = { 0U };
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t, Eurydice_slice),
      int32_t,
      size_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter(lit,
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      coefficients =
        Eurydice_array_to_subslice((size_t)256U,
          re,
          (
            (core_ops_range_Range__size_t){
              .start = i * (size_t)8U,
              .end = i * (size_t)8U + (size_t)8U
            }
          ),
          int32_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      uint8_t
      coefficient1 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)0U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient2 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)1U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient3 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)2U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient4 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)3U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient5 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)4U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient6 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)5U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient7 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)6U,
              int32_t,
              int32_t)));
      uint8_t
      coefficient8 =
        (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
          libcrux_kyber_arithmetic_to_unsigned_representative(Eurydice_slice_index(coefficients,
              (size_t)7U,
              int32_t,
              int32_t)));
      K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
      uu____1 =
        libcrux_kyber_serialize_compress_coefficients_5(coefficient2,
          coefficient1,
          coefficient4,
          coefficient3,
          coefficient5,
          coefficient7,
          coefficient6,
          coefficient8);
      uint8_t coef1 = uu____1.fst;
      uint8_t coef2 = uu____1.snd;
      uint8_t coef3 = uu____1.thd;
      uint8_t coef4 = uu____1.f3;
      uint8_t coef5 = uu____1.f4;
      serialized[(size_t)5U * i] = coef1;
      serialized[(size_t)5U * i + (size_t)1U] = coef2;
      serialized[(size_t)5U * i + (size_t)2U] = coef3;
      serialized[(size_t)5U * i + (size_t)3U] = coef4;
      serialized[(size_t)5U * i + (size_t)4U] = coef5;
    }
  }
  memcpy(ret, serialized, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t uu____0[128U];
  compress_then_serialize_4___128size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)128U * sizeof (uint8_t));
}

static inline void into_padded_array___1088size_t(Eurydice_slice slice, uint8_t ret[1088U])
{
  uint8_t out[1088U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1088U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1088U * sizeof (uint8_t));
}

static void
encrypt_unpacked___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*a_transpose)[3U][256U],
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[1088U]
)
{
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  __libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____1 = sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____0, 0U);
  int32_t r_as_ntt[3U][256U];
  memcpy(r_as_ntt, uu____1.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____1.snd;
  int32_t error_1[3U][256U];
  sample_ring_element_cbd___3size_t_128size_t_2size_t(prf_input, &domain_separator, error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t,
      Eurydice_slice),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t,
      Eurydice_slice),
    error_2);
  int32_t u[3U][256U];
  compute_vector_u___3size_t(a_transpose, r_as_ntt, error_1, u);
  uint8_t uu____2[32U];
  memcpy(uu____2, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____2, message_as_ring_element);
  int32_t v[256U];
  compute_ring_element_v___3size_t(t_as_ntt, r_as_ntt, &error_2, &message_as_ring_element, v);
  int32_t uu____3[3U][256U];
  memcpy(uu____3, u, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t c1[960U];
  compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(uu____3, c1);
  uint8_t c2[128U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[1088U];
  into_padded_array___1088size_t(Eurydice_array_to_slice((size_t)960U,
      c1,
      uint8_t,
      Eurydice_slice),
    ciphertext);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  memcpy(ret, ciphertext, (size_t)1088U * sizeof (uint8_t));
}

static void
encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[1088U]
)
{
  int32_t t_as_ntt[3U][256U];
  deserialize_ring_elements_reduced___1152size_t_3size_t(Eurydice_slice_subslice_to(public_key,
      (size_t)1152U,
      uint8_t,
      size_t,
      Eurydice_slice),
    t_as_ntt);
  Eurydice_slice
  seed = Eurydice_slice_subslice_from(public_key, (size_t)1152U, uint8_t, size_t, Eurydice_slice);
  int32_t a_transpose[3U][3U][256U];
  uint8_t ret0[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret0);
  sample_matrix_A___3size_t(ret0, false, a_transpose);
  int32_t (*uu____0)[256U] = t_as_ntt;
  int32_t (*uu____1)[3U][256U] = a_transpose;
  uint8_t uu____2[32U];
  memcpy(uu____2, message, (size_t)32U * sizeof (uint8_t));
  uint8_t ret1[1088U];
  encrypt_unpacked___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
    uu____1,
    uu____2,
    randomness,
    ret1);
  memcpy(ret, ret1, (size_t)1088U * sizeof (uint8_t));
}

typedef uint8_t MlKemCiphertext___1088size_t[1088U];

static K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_
encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t,
      Eurydice_slice),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      LIBCRUX_KYBER_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1184U,
      as_slice___1184size_t(public_key),
      uint8_t,
      Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1184U,
      as_slice___1184size_t(public_key),
      uint8_t,
      Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[1088U];
  encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
    uu____3,
    pseudorandomness,
    ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_slice((size_t)32U,
      shared_secret_array,
      uint8_t,
      Eurydice_slice),
    shared_secret,
    uint8_t,
    void *);
  uint8_t uu____4[1088U];
  memcpy(uu____4, ciphertext, (size_t)1088U * sizeof (uint8_t));
  uint8_t uu____5[1088U];
  memcpy(uu____5, uu____4, (size_t)1088U * sizeof (uint8_t));
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof (uint8_t));
  K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_ lit;
  memcpy(lit.fst, uu____5, (size_t)1088U * sizeof (uint8_t));
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof (uint8_t));
  return lit;
}

K___libcrux_kyber_types_MlKemCiphertext__1088size_t___uint8_t_32size_t_
libcrux_kyber_kyber768_encapsulate(uint8_t (*public_key)[1184U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1184U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

static K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
split_at___2400size_t(uint8_t (*self)[2400U], size_t mid)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)2400U,
        self[0U],
        uint8_t,
        Eurydice_slice),
      mid,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
}

static inline void
deserialize_secret_key___3size_t(Eurydice_slice secret_key, int32_t ret[3U][256U])
{
  int32_t secret_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(secret_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(secret_key,
            uint8_t,
            size_t)
          / LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      secret_bytes =
        Eurydice_slice_subslice(secret_key,
          (
            (core_ops_range_Range__size_t){
              .start = i * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT,
              .end = i
              * LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
              + LIBCRUX_KYBER_CONSTANTS_BYTES_PER_RING_ELEMENT
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t uu____1[256U];
      libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(secret_bytes, uu____1);
      memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  memcpy(ret, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_10(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_vector_u___10size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
      re[i] = uu____1;
    }
  }
  memcpy(ret, re, (size_t)256U * sizeof (int32_t));
}

static inline void
deserialize_then_decompress_u___3size_t_1088size_t_10size_t(
  uint8_t *ciphertext,
  int32_t ret[3U][256U]
)
{
  int32_t u_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    memcpy(u_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  }
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)1088U,
              ciphertext,
              uint8_t,
              Eurydice_slice),
            uint8_t,
            size_t)
          / (LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U)
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      Eurydice_slice
      u_bytes =
        Eurydice_array_to_subslice((size_t)1088U,
          ciphertext,
          (
            (core_ops_range_Range__size_t){
              .start = i
              * (LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U),
              .end = i
              * (LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U)
              + LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U
            }
          ),
          uint8_t,
          core_ops_range_Range__size_t,
          Eurydice_slice);
      int32_t u[256U];
      libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
      int32_t uu____1[256U];
      libcrux_kyber_ntt_ntt_vector_u___10size_t(u, uu____1);
      memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
    }
  }
  memcpy(ret, u_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_4(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

static inline void
compute_message___3size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)3U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      add_to_ring_element___3size_t(result, &product, result);
    }
  }
  invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t
  iter0 =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_KYBER_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT
        }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter0,
        size_t,
        core_option_Option__size_t);
    if (uu____1.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____1.f0;
      int32_t
      coefficient_normal_form =
        libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
      int32_t uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
      result[i] = uu____2;
    }
  }
  memcpy(ret, result, (size_t)256U * sizeof (int32_t));
}

static void
decrypt_unpacked___3size_t_1088size_t_960size_t_10size_t_4size_t(
  int32_t (*secret_as_ntt)[256U],
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[3U][256U];
  deserialize_then_decompress_u___3size_t_1088size_t_10size_t(ciphertext, u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t,
      Eurydice_slice),
    v);
  int32_t message[256U];
  compute_message___3size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static void
decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t secret_as_ntt[3U][256U];
  deserialize_secret_key___3size_t(secret_key, secret_as_ntt);
  uint8_t ret0[32U];
  decrypt_unpacked___3size_t_1088size_t_960size_t_10size_t_4size_t(secret_as_ntt,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static inline void into_padded_array___1120size_t(Eurydice_slice slice, uint8_t ret[1120U])
{
  uint8_t out[1120U] = { 0U };
  uint8_t *uu____0 = out;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1120U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = core_slice___Slice_T___len(slice, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    slice,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1120U * sizeof (uint8_t));
}

static Eurydice_slice as_ref___1088size_t(uint8_t (*self)[1088U])
{
  return Eurydice_array_to_slice((size_t)1088U, self[0U], uint8_t, Eurydice_slice);
}

void libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_shake256((size_t)32U, input, ret0, void *);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static uint8_t
compare_ciphertexts_in_constant_time___1088size_t(Eurydice_slice lhs, Eurydice_slice rhs)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t
  iter =
    core_iter_traits_collect___core__iter__traits__collect__IntoIterator_for_I___into_iter((
        (core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)1088U }
      ),
      core_ops_range_Range__size_t,
      core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 =
      core_iter_range___core__iter__traits__iterator__Iterator_for_core__ops__range__Range_A___3__next(&iter,
        size_t,
        core_option_Option__size_t);
    if (uu____0.tag == core_option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t, uint8_t);
      r =
        (uint32_t)r
        | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t, uint8_t));
    }
  }
  return libcrux_kyber_constant_time_ops_is_non_zero(r);
}

static void
decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 = split_at___2400size_t(secret_key, (size_t)1152U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)1184U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      LIBCRUX_KYBER_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1120U];
  into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1120U,
      to_hash,
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    as_ref___1088size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1120U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
    uu____6,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice uu____7 = as_ref___1088size_t(ciphertext);
  uint8_t
  selector =
    compare_ciphertexts_in_constant_time___1088size_t(uu____7,
      Eurydice_array_to_slice((size_t)1088U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber768_decapsulate(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static void
decapsulate_unpacked___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  libcrux_kyber_MlKemState___3size_t *state,
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  int32_t (*secret_as_ntt)[256U] = state->secret_as_ntt;
  int32_t (*t_as_ntt)[256U] = state->t_as_ntt;
  int32_t (*a_transpose)[3U][256U] = state->a_transpose;
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_slice((size_t)32U,
      state->rej,
      uint8_t,
      Eurydice_slice);
  Eurydice_slice
  ind_cpa_public_key_hash =
    Eurydice_array_to_slice((size_t)32U,
      state->ind_cpa_public_key_hash,
      uint8_t,
      Eurydice_slice);
  uint8_t decrypted[32U];
  decrypt_unpacked___3size_t_1088size_t_960size_t_10size_t_4size_t(secret_as_ntt,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____0.fst;
  Eurydice_slice pseudorandomness = uu____0.snd;
  uint8_t to_hash[1120U];
  into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____1 =
    Eurydice_array_to_subslice_from((size_t)1120U,
      to_hash,
      LIBCRUX_KYBER_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____1,
    as_ref___1088size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1120U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  int32_t (*uu____2)[256U] = t_as_ntt;
  int32_t (*uu____3)[3U][256U] = a_transpose;
  uint8_t uu____4[32U];
  memcpy(uu____4, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  encrypt_unpacked___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
    uu____3,
    uu____4,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice uu____5 = as_ref___1088size_t(ciphertext);
  uint8_t
  selector =
    compare_ciphertexts_in_constant_time___1088size_t(uu____5,
      Eurydice_array_to_slice((size_t)1088U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____6 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____6,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber768_decapsulate_unpacked(
  libcrux_kyber_MlKemState___3size_t *state,
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  decapsulate_unpacked___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(state,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

