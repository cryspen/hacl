mod test_util;

use regex::Regex;
use std::fmt;

use hacl_rust::bignum::BigUInt;

use data_encoding::HEXUPPER;
use rand::prelude::SmallRng;
use rand::{RngCore, SeedableRng};

#[test]
fn test_to_from() {
    let trials = 1_000;
    let mut small_rng = SmallRng::seed_from_u64(2038_u64);

    #[derive(Clone)]
    struct Failure {
        in_data: Vec<u8>,
        out_data: Vec<u8>,
        bad_prefix: Option<Vec<u8>>,
        trial: u32,
    }
    impl fmt::Debug for Failure {
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt.debug_struct("Failure")
                .field("in", &format_args!("{:?}\n", &self.in_data))
                .field("out", &format_args!("{:?}\n", &self.out_data))
                .field("bad_prefix", &format_args!("{:?}\n", &self.bad_prefix))
                .field("trial", &format_args!("{:?}\n", &self.trial))
                .finish()
        }
    }

    // Less verbose than {:?}
    impl fmt::Display for Failure {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            writeln!(
                f,
                "(in.len: {}, out.len: {}, bad_prefix: {:?}, trial: {})",
                self.in_data.len(),
                self.out_data.len(),
                self.bad_prefix,
                self.trial
            )
        }
    }
    #[derive(Clone)]
    struct FailureVec(Vec<Failure>);

    // There is probably a better way to get FailureVec to inherit
    // Vec methods, but I only need two.
    impl FailureVec {
        fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
        fn len(&self) -> usize {
            self.0.len()
        }
        fn push(&mut self, v: Failure) {
            self.0.push(v)
        }
    }

    impl fmt::Display for FailureVec {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            writeln!(f, "Failures:")?;
            for v in &self.0 {
                write!(f, "\t{}", v)?;
            }
            Ok(())
        }
    }

    let mut failures: FailureVec = FailureVec(Vec::new());

    const TEST_SIZE: usize = BigUInt::BN_BYTE_LENGTH - 17;
    // const TEST_SIZE: usize = Bignum::BN_BYTE_LENGTH - 14;

    for trial in 1..=trials {
        let mut dest: [u8; TEST_SIZE] = [0; TEST_SIZE];
        small_rng.fill_bytes(&mut dest);

        let in_data = dest;
        let in_vec = dest.to_vec();

        let bn = BigUInt::new(&in_data).unwrap();
        let b_vec = bn.to_vec8().unwrap();

        let mut trimmed_b: Vec<u8> = Vec::new();
        let len_diff = b_vec.len() - in_vec.len();
        let mut should_be_zeros_but_isnt: Vec<u8> = vec![0; len_diff];
        if len_diff > 0 {
            trimmed_b = if let Some(v) = b_vec.strip_prefix(vec![0_u8; len_diff].as_slice()) {
                v.to_vec()
            } else {
                should_be_zeros_but_isnt = b_vec[..len_diff].to_vec();
                b_vec.to_vec()
            }
        }
        let bad_prefix = if should_be_zeros_but_isnt.iter().any(|&x| x != 0_u8) {
            Some(should_be_zeros_but_isnt)
        } else {
            None
        };

        if !trimmed_b.eq(&in_vec) {
            let f = &Failure {
                in_data: in_data.to_vec(),
                out_data: b_vec.clone(),
                bad_prefix,
                trial,
            };
            failures.push(f.clone());
        }
    }

    // If you want the gory details of each failure use the format string
    // with the "{:?}" for failures.
    assert!(
        failures.is_empty(),
        "{}\nThere were {} in-out failure(s) out of {} trials",
        // "{:?}\nThere were {} in-out failure(s) out of {} trials",
        failures,
        failures.len(),
        trials
    );
}

#[test]
#[allow(clippy::neg_cmp_op_on_partial_ord)]
fn test_partial_ord() {
    let trials = 1_000;
    let mut small_rng = SmallRng::seed_from_u64(123_u64);

    // let byte_size = Bignum::BN_BYTE_LENGTH - 256;
    let byte_size = BigUInt::BN_BYTE_LENGTH;
    let dest = &mut vec![0; byte_size];
    for trial in 0..trials {
        // we create random a: u128 and a_bn: Bignum
        // which should have same numeric value.
        // And we do the same for b and b_bn.
        small_rng.fill_bytes(dest);
        let a = dest.to_vec();
        let a_bn = BigUInt::new(dest).unwrap();

        small_rng.fill_bytes(dest);
        let b = dest.to_vec();
        let b_bn = BigUInt::new(dest).unwrap();

        assert!(a_bn == a_bn);
        let i_cmp = a.partial_cmp(&b).unwrap();
        let b_cmp = a_bn.partial_cmp(&b_bn).unwrap();

        assert!(
            i_cmp == b_cmp,
            "i_cmp {:?} != b_cmp {:?} in trial {}",
            i_cmp,
            b_cmp,
            trial
        );
    }
}

#[test]
#[ignore]
// Run
//   cargo test test_memleak -- --ignored
// which may take several minutes.
// That should give you plenty of time to see if processes with names matching
// /test_bignum-*/ grow in memory.
fn test_memleak() {
    let trials = 500_000_u64;
    let mut small_rng = SmallRng::seed_from_u64(123_u64);

    for _ in 0..trials {
        let data = &mut vec![0_u8; 512];
        data.fill(0);

        small_rng.fill_bytes(&mut data[..]);
        let a = BigUInt::new(data).unwrap();

        small_rng.fill_bytes(&mut data[..]);
        let b = BigUInt::new(data).unwrap();

        let mut true_count = 0;

        if a < b {
            true_count += 1;
        }
        if a > b {
            true_count += 1;
        }
        if a == b {
            true_count += 1;
        }

        assert!(true_count == 1, "We have the wrong number of truths.")
    }
}

#[test]
fn test_constants() {
    let b001 = &BigUInt::new(&[0_u8, 0, 1]).unwrap();
    let b101 = &BigUInt::new(&[1_u8, 0, 1]).unwrap();
    let b000 = &BigUInt::new(&[0_u8, 0, 0]).unwrap();
    let b222 = &BigUInt::new(&[2_u8, 2, 2]).unwrap();

    for bn in [&BigUInt::ONE, &BigUInt::ZERO, b001, b101, b000, b222] {
        assert!(bn == bn, "Something isn't equal to itself")
    }

    struct TestVector<'a> {
        a: &'a BigUInt,
        b: &'a BigUInt,
        expected: bool,
        name: &'a str,
    }

    let tests = [
        TestVector {
            a: &BigUInt::ONE,
            b: &BigUInt::ZERO,
            expected: false,
            name: "ONE, ZERO",
        },
        TestVector {
            a: b000,
            b: &BigUInt::ZERO,
            expected: true,
            name: "b000, ZERO",
        },
        TestVector {
            a: b001,
            b: &BigUInt::ZERO,
            expected: false,
            name: "b001, ZERO",
        },
        TestVector {
            a: b101,
            b: &BigUInt::ZERO,
            expected: false,
            name: "b101, ZERO",
        },
        TestVector {
            a: b222,
            b: &BigUInt::ZERO,
            expected: false,
            name: "b222, ZERO",
        },
        TestVector {
            a: b000,
            b: &BigUInt::ONE,
            expected: false,
            name: "b001, ONE",
        },
        TestVector {
            a: b001,
            b: &BigUInt::ONE,
            expected: true,
            name: "b001, ONE",
        },
        TestVector {
            a: b101,
            b: &BigUInt::ONE,
            expected: false,
            name: "b101, ONE",
        },
        TestVector {
            a: b222,
            b: &BigUInt::ONE,
            expected: false,
            name: "b222, ONE",
        },
        TestVector {
            a: &BigUInt::ZERO,
            b: &BigUInt::ONE,
            expected: false,
            name: "ZERO, ONE",
        },
        TestVector {
            a: b222,
            b: b101,
            expected: false,
            name: "b222, b101",
        },
    ];

    for t in tests {
        assert!(
            (t.a == t.b) == t.expected,
            "(a,b) Unexpected result for {}",
            t.name
        );
        assert!(
            (t.b == t.a) == t.expected,
            "(b,a) Unexpected result for {}",
            t.name
        );
    }
}

#[test]
fn test_hex() {
    // run enough trials to know that we will get some leading zero bytes.
    let trials = 1_000;

    // really should loop to try at different lengths, including odd ones
    let vec_size = BigUInt::BN_BYTE_LENGTH - 129;
    let mut small_rng = SmallRng::seed_from_u64(1138_u64);

    for trial in 1..=trials {
        let mut dest = vec![0_u8; vec_size];
        small_rng.fill_bytes(&mut dest);

        let in_hex = HEXUPPER.encode(&dest);
        let bn = BigUInt::from_hex(in_hex.as_str()).unwrap();
        let out_hex = bn.to_hex();

        let in_hex = in_hex.trim_start_matches("00");

        let out_hex = out_hex.trim_start_matches("00");

        assert!(
            in_hex == out_hex,
            "Hexes aren't equal in trial {}\n\tin: {}\n\tout {}",
            trial,
            in_hex,
            out_hex
        );
    }
}

// modpow BIG_B (base), BIG_E (exponent), BIG_M (modulus), BIG_R (result)
// are taken from tests in num_bigint

static BIG_B: &str = "\
                      efac3c0a_0de55551_fee0bfe4_67fa017a_1a898fa1_6ca57cb1\
                      ca9e3248_cacc09a9_b99d6abc_38418d0f_82ae4238_d9a68832\
                      aadec7c1_ac5fed48_7a56a71b_67ac59d5_afb28022_20d9592d\
                      247c4efc_abbd9b75_586088ee_1dc00dc4_232a8e15_6e8191dd\
                      675b6ae0_c80f5164_752940bc_284b7cee_885c1e10_e495345b\
                      8fbe9cfd_e5233fe1_19459d0b_d64be53c_27de5a02_a829976b\
                      33096862_82dad291_bd38b6a9_be396646_ddaf8039_a2573c39\
                      1b14e8bc_2cb53e48_298c047e_d9879e9c_5a521076_f0e27df3\
                      990e1659_d3d8205b_6443ebc0_9918ebee_6764f668_9f2b2be3\
                      b59cbc76_d76d0dfc_d737c3ec_0ccf9c00_ad0554bf_17e776ad\
                      b4edf9cc_6ce540be_76229093_5c53893b";

static BIG_E: &str = "\
                      be0e6ea6_08746133_e0fbc1bf_82dba91e_e2b56231_a81888d2\
                      a833a1fc_f7ff002a_3c486a13_4f420bf3_a5435be9_1a5c8391\
                      774d6e6c_085d8357_b0c97d4d_2bb33f7c_34c68059_f78d2541\
                      eacc8832_426f1816_d3be001e_b69f9242_51c7708e_e10efe98\
                      449c9a4a_b55a0f23_9d797410_515da00d_3ea07970_4478a2ca\
                      c3d5043c_bd9be1b4_6dce479d_4302d344_84a939e6_0ab5ada7\
                      12ae34b2_30cc473c_9f8ee69d_2cac5970_29f5bf18_bc8203e4\
                      f3e895a2_13c94f1e_24c73d77_e517e801_53661fdd_a2ce9e47\
                      a73dd7f8_2f2adb1e_3f136bf7_8ae5f3b8_08730de1_a4eff678\
                      e77a06d0_19a522eb_cbefba2a_9caf7736_b157c5c6_2d192591\
                      17946850_2ddb1822_117b68a0_32f7db88";

// This modulus is the prime from the 2048-bit MODP DH group:
// https://tools.ietf.org/html/rfc3526#section-3
static BIG_M: &str = "\
                      FFFFFFFF_FFFFFFFF_C90FDAA2_2168C234_C4C6628B_80DC1CD1\
                      29024E08_8A67CC74_020BBEA6_3B139B22_514A0879_8E3404DD\
                      EF9519B3_CD3A431B_302B0A6D_F25F1437_4FE1356D_6D51C245\
                      E485B576_625E7EC6_F44C42E9_A637ED6B_0BFF5CB6_F406B7ED\
                      EE386BFB_5A899FA5_AE9F2411_7C4B1FE6_49286651_ECE45B3D\
                      C2007CB8_A163BF05_98DA4836_1C55D39A_69163FA8_FD24CF5F\
                      83655D23_DCA3AD96_1C62F356_208552BB_9ED52907_7096966D\
                      670C354E_4ABC9804_F1746C08_CA18217C_32905E46_2E36CE3B\
                      E39E772C_180E8603_9B2783A2_EC07A28F_B5C55DF0_6F4C52C9\
                      DE2BCBF6_95581718_3995497C_EA956AE5_15D22618_98FA0510\
                      15728E5A_8AACAA68_FFFFFFFF_FFFFFFFF";

static BIG_R: &str = "\
                      a1468311_6e56edc9_7a98228b_5e924776_0dd7836e_caabac13\
                      eda5373b_4752aa65_a1454850_40dc770e_30aa8675_6be7d3a8\
                      9d3085e4_da5155cf_b451ef62_54d0da61_cf2b2c87_f495e096\
                      055309f7_77802bbb_37271ba8_1313f1b5_075c75d1_024b6c77\
                      fdb56f17_b05bce61_e527ebfd_2ee86860_e9907066_edd526e7\
                      93d289bf_6726b293_41b0de24_eff82424_8dfd374b_4ec59542\
                      35ced2b2_6b195c90_10042ffb_8f58ce21_bc10ec42_64fda779\
                      d352d234_3d4eaea6_a86111ad_a37e9555_43ca78ce_2885bed7\
                      5a30d182_f1cf6834_dc5b6e27_1a41ac34_a2e91e11_33363ff0\
                      f88a7b04_900227c9_f6e6d06b_7856b4bb_4e354d61_060db6c8\
                      109c4735_6e7db425_7b5d74c7_0b709508";

#[test]
fn test_modpow_big() {
    let base_hex = BIG_B.to_uppercase().replace('_', "");
    let exp_hex = BIG_E.to_uppercase().replace('_', "");
    let mod_hex = BIG_M.to_uppercase().replace('_', "");
    let expected_hex = BIG_R.to_uppercase().replace('_', "");

    let base = BigUInt::from_hex(&base_hex).unwrap();
    let exp = BigUInt::from_hex(&exp_hex).unwrap();
    let mut modulus = BigUInt::from_hex(&mod_hex).unwrap();
    let expected = BigUInt::from_hex(&expected_hex).unwrap();

    let result = base.modpow(&exp, &mut modulus).unwrap();

    assert!(result == expected);
}

#[test]
fn test_mont_modpow_big() {
    let base_hex = BIG_B.to_uppercase().replace('_', "");
    let exp_hex = BIG_E.to_uppercase().replace('_', "");
    let mod_hex = BIG_M.to_uppercase().replace('_', "");
    let expected_hex = BIG_R.to_uppercase().replace('_', "");

    let base = BigUInt::from_hex(&base_hex).unwrap();
    let exp = BigUInt::from_hex(&exp_hex).unwrap();
    let mut modulus = BigUInt::from_hex(&mod_hex).unwrap();
    modulus.precomp_mont_ctx().unwrap();
    let expected = BigUInt::from_hex(&expected_hex).unwrap();

    let result = base.modpow(&exp, &mut modulus).unwrap();

    assert!(result == expected);
}

#[test]
fn test_is_odd() {
    struct TestVector<'a> {
        hex: String,
        is_odd: bool,
        name: &'a str,
    }

    // use the numbers (hex strings) we had for modpow testing
    let b = BIG_B.to_uppercase().replace('_', "");
    let e = BIG_E.to_uppercase().replace('_', "");
    let m = BIG_M.to_uppercase().replace('_', "");
    let r = BIG_R.to_uppercase().replace('_', "");

    let tests = vec![
        TestVector {
            hex: b,
            is_odd: true,
            name: "b",
        },
        TestVector {
            hex: e,
            is_odd: false,
            name: "e",
        },
        TestVector {
            hex: m,
            is_odd: true,
            name: "m",
        },
        TestVector {
            hex: r,
            is_odd: false,
            name: "r",
        },
    ];

    let re_last = Regex::new(r"(..)$").unwrap();
    for t in tests {
        // There must be better ways to do this without bringing in all the regex machinery
        let caps = re_last.captures(&t.hex).unwrap();
        let last_byte = HEXUPPER.decode(caps[0].as_bytes()).unwrap();
        let pp_byte = last_byte[0].wrapping_add(1);
        let mm_byte = last_byte[0].wrapping_sub(1);

        let t_pp = re_last.replace(&t.hex, HEXUPPER.encode(&[pp_byte]));
        let t_mm = re_last.replace(&t.hex, HEXUPPER.encode(&[mm_byte]));

        let bn = BigUInt::from_hex(&t.hex).unwrap();
        let bn_pp = BigUInt::from_hex(&t_pp).unwrap();
        let bn_mm = BigUInt::from_hex(&t_mm).unwrap();

        let is_odd_t = bn.is_odd().unwrap();
        let is_odd_pp = bn_pp.is_odd().unwrap();
        let is_odd_mm = bn_mm.is_odd().unwrap();

        assert!(
            is_odd_t == t.is_odd,
            "{}'s oddness should be {}",
            t.name,
            t.is_odd
        );
        assert!(is_odd_pp == is_odd_mm);
        assert!(is_odd_t != is_odd_mm);
    }
}

#[test]
fn test_reduction() {
    struct TestVector<'a> {
        a: &'a str,
        m: &'a str,
        expected: &'a str,
    }

    let tests = vec![
        TestVector{
            a: "C05435C41E04E22D4365C583C8C5C113C466619F65C796FC72B9B5757F099445D46875A42325966A91DDEF451B3E62D04EF4AB25A4300960C1A9A4DCE0DED710FD48293BC40D2E8992F278CE4C1DE7180B6EFCFCBD6BA80DB9BD4CF4585DFFE171B8274A73803E289909BDD2A15F8B1D808B6F3855C815F3CDB1E9DC666FDE6973F326152C517E48B5D16EC922A8CE7DD03E082669C591B1B9BF879BF7CE2E8F57CA22212872C34C43333FBEE4D749D389EE69B3C83E5ADA0C6178529B061DA56E3B752ADCF5DBE4E64C8372447F0B2DCB678303EE998C1C2896E434B4D523094EE9F4C7C563239563E7EC08DF47C053F33E4B99CBA8CE2A7938425A424BCC6565945A101C3230E89A7A845BD1776920ACECADF50BF23ED1612648D85DD1341BA9CC764DC60A388DB26694A9B8F740B54AC9C84137CAE2ED3615F79DF7BDACB8372DA286F4169D915CC88907F3C3556E949CD6EC50AE847076FFC5D5AB400DD7E6277A93A28C4B38B194A3041B8928E1B20B47387118AC53AE0F707E9E1E399E414F3A6D8B34E19189BC4051DF69E78E85F438EDB54A769810872BDF395C20C9805DD011FBA8250D06A163C838DDF9EEC2F41B1489AEBE98188D9E1E2BF37775D4FDA58AE8A45B9720ECF2069606A1DFC4FAFFCC4F290B805469A125C3972F5341EC15ADE4D09FDD88B1B30193E1627941F92AE680969554B6FA71B19899A389",
            m: "750E63CC22A489435AB7B69B1B6230EF56E2B7C159C3319B61FC199D717EEFEEB37A45E614096C72AA97E7918EF01B9A46C540AE4BEC94B97C9E8707734F95DDEBF110DCF81B2D045C49622A43CA6A75A23A0C270C4A823A8F7A00C235F47A36CB97A19BECDB3229BAED9D86651998948EADB45E23AF82E9B3BECA5966CB950AD040641ECBBE6CD0FE0915FA9585ABC9AC5719AAEFFDF0BF6834C90CFCD5D3D83F517C05BA1AFA391BB8804B58BDB646537492696F2A646A251F4323B5504D1B999C3B84D91BD3CD83ABD7BF679596BF443BDFA1976C9C1C95AD88F48E53A40656DD5355E3BF4626D963CAB9671A42A1C8D7AD44A0E89389AA67CF30686BAE1383E74DD6A64A9A83F6A5BB72543034F5E83AC76446AB0587F4882D5371C4EAFAC05C6AF3F2D83259DA96A8FC63258396C417CE43713B09C5EAB30F8C6BD2A61603D9AC9C1848CB253C33785F66CCB7E99B04DD4677B7CBF00EA5485684A0486C345D70539750E43A191EEA30A11CB3A7C5836CB177C9880BD9EFD503545D2D38A27DAB919267391F70FA95A6C3978087635377FD6E87922D823B3AFA2EC00E6118FD04B4109349AA6D1BC28AFF51CCA9EB13C6C0D420E0D95CE684242905D73D4AF77388D72F6D28995287F177C34BF3983BB762C25ABF4F0B775362ED6C951281EB3D7CE6F5B6DD313F219B81403D3831732B02A22F55110D48B23BDE7F9AB1",
            expected: "4B45D1F7FB6058E9E8AE0EE8AD6390246D83A9DE0C04656110BD9BD80D8AA45720EE2FBE0F1C29F7E74607B38C4E4736082F6A77584374A7450B1DD56D8F41331157185ECBF2018536A916A408537CA26934F0D5B12125D32A434C32226985AAA62085AE86A50BFEDE1C204C3C45F288F1DDBADA3218930A19F31F82FFA4495EA3B2C1F660931177B7C858CE8D2322B423E6EE7B79C7A0F2518ABE8EFAF85AB71878A61B6E57C913277ABF738C19938D3679D74A5913F66FE742352EE5B5D089D49F39A603DA081762A0ABB2DCE9746E872BA362572CEFFF92E95B4026817F02F80CA171E1A3DD6E8A84214F782D7DB22A669E552AC03AA0CED07329D9E01E51E1AD0C3975E79664A3D4C8E97D47342AC4B1E690C54739496C9E1B84EC0C4920E9700B59D3320633D7CFEBAD55D1BD1E86B1F9FDC68FD9274B62E8118BEB06A23353F5EADBCDD26C209510A88CF69D84F997F9A5D8F6B880685A7D7F269FC56BB1CA0A400B3B66FE9875B8D37A6C7539EC87DA86F94F2447D41F9B7B49C10C659ED18EDBF8CDA87218C1AAAB1BD2670722A0C0F046C2E46A8E4BF0E50A9C12686760CB5DEB14DB629985A13D398C2D44D7E05453B58DDDBEBBA719FA02EDA0388A0632021174EE6E879A6A151E4355EC2CBF48698CCE4C3148F24DC2D62A9A40C000D830FDDAE9005772916612A125411085FFE3DE674043A9B1BF75BA1A08D8",
        },
        TestVector{
            a: "601FEB7A09CFEF8581DDC8AEE3FE502D2D78EFAE3B241B4B7E5595083755C54C2CFD855C387573D0FA528B7CA3690AD40BDA73B02086A2364508EE0ACCD91F4A7A0DC96FE79E03E10553638967734C8B7672C73471DBE5CD4F9E1086A7DC75570616EA355170E86DCAFEE7DDF74B86EF362A7140735238388A7DA00F41B4510899C06C39E893D30AC16D6FF7DF626B3CD6CA4EF53E125842AADB4958C05C8BF24A89A219E7E7A06C73209529FC2D584658A9DE65888C0299469156F7E7975431FD8E207B3DA67576AE9718AA4381F720B9F5365F5C1ACBE07D8EA71B683EEA6E0BA7523155723E4BE701BA87E35BA464615DC93C0E06CD87C6495442437020664A261AB12FA6945321E59C9CA0BD424499EB5086EB40221E43BF11CDB44A9FC5F7CD49CD43622D24C72D595144191C91579D57483DCE8B29059CB1120B6D3C03BD50D01BEA25DB1499CD37FC539DC2D0AF0264BB4EF822D8FD83F97D54EF26F21E5F05B51868ED031EF55E797BE190EC04119B6DECAC1A855AFDF38EB232B6C8FE52C680550C159406A19DD2305E2628CECCE01623D7DEC87DDC1A102289C4A96EF60A923C2E67557C258DD14C7F2E457665B3FDCD1639E9AA381F2D815FE9B18A6024D311AC66DC0AE367D9E2AF9E9462B84F087781E5118B75465FC87A9D6071A24BC264DC4FBE331A919995970484DCB306F04DB2265DA34D327BCB330EAC",
            m: "9156D6ABA03240203789AC606E2038FB58501EB34906B0277F88AC76E77D14B5858D5E7A7AC36D9DC1CDA3F6E110C02C74CEF24495AB26991BF7C2711067615C16A422720262A114C91D79807F8BB90114A863B560196C60443BC5453F4897C4C043C62B621A5D3FAD611347DED2840390C06BFC79637372C2BB1C3ACA415EC708342AFEB57A4FEE4B9189D6C3F39BB3D3D5218C47E7DB0190CAE4F764069F7C92A67F602863CDAA7B3BA572A085CF551F4E341C1C60C30A1E070F54BD9EF16AC3818A2A4491307089C66EB27061EDF8299C4A174781AD8548A7E056063DA816F9990EAE23ECCD6D0694B6236CCAEC6E09EF21838A4B45D35155028D6BC77A57F17E7C10998B8DE9904F2A167268DA46CF9F15823BA34C1286635327C235A1704B3E8340E9493D6E59DA1A72E3FBDC5E61CF349B2E7ACBE47101F2F14A13420881E3F68217C069E469DFFB0660E598F60278471AA95F7473BF0B21E316E2F4E1D694DE07A0C8D2643B3D274F2B2A77A411CF93C837DE002939DA99E0063909E6A1D7CB7C4DE3D7AEAC02FB4025A733057A0826EA5AB46EFECD6163351B55FC327314A539E307A29E0D3BB1349C2B71E805B6E053474A56B12A15536AFEEBE6DDEEB0C96B7EA5DF3B1127734E932A774E3390FF0EC23C503CFFC0CE2B0BF24B160DD3FE058208E4967D4739309953F3A9CE7D4C1972A9185467950D005E5D15E3",
            expected: "601FEB7A09CFEF8581DDC8AEE3FE502D2D78EFAE3B241B4B7E5595083755C54C2CFD855C387573D0FA528B7CA3690AD40BDA73B02086A2364508EE0ACCD91F4A7A0DC96FE79E03E10553638967734C8B7672C73471DBE5CD4F9E1086A7DC75570616EA355170E86DCAFEE7DDF74B86EF362A7140735238388A7DA00F41B4510899C06C39E893D30AC16D6FF7DF626B3CD6CA4EF53E125842AADB4958C05C8BF24A89A219E7E7A06C73209529FC2D584658A9DE65888C0299469156F7E7975431FD8E207B3DA67576AE9718AA4381F720B9F5365F5C1ACBE07D8EA71B683EEA6E0BA7523155723E4BE701BA87E35BA464615DC93C0E06CD87C6495442437020664A261AB12FA6945321E59C9CA0BD424499EB5086EB40221E43BF11CDB44A9FC5F7CD49CD43622D24C72D595144191C91579D57483DCE8B29059CB1120B6D3C03BD50D01BEA25DB1499CD37FC539DC2D0AF0264BB4EF822D8FD83F97D54EF26F21E5F05B51868ED031EF55E797BE190EC04119B6DECAC1A855AFDF38EB232B6C8FE52C680550C159406A19DD2305E2628CECCE01623D7DEC87DDC1A102289C4A96EF60A923C2E67557C258DD14C7F2E457665B3FDCD1639E9AA381F2D815FE9B18A6024D311AC66DC0AE367D9E2AF9E9462B84F087781E5118B75465FC87A9D6071A24BC264DC4FBE331A919995970484DCB306F04DB2265DA34D327BCB330EAC",
        },
        TestVector{
            a: "82271BD5A2FA9AA18BC070B507136528F1DE0B5F1EB39DBD2E5C4BFE02DE161412A47FF347159BC060D1F584A0679017822763AA9FABF41253AF16829DAC274A9F506661E6911BCED62DAB99BD881BB1514C5B24D4D94E792BEA46692391357F811975D037B5CD524E40E49D58590217A20DE5691DE1594EB9CA193446C64A1F8D58041BB8B421AD2AE7A499AF839DC2643ECA5D857046C68720129E3BABEFB9BA18FD8FB9DEEB7D80AF5998BD035E0AF741C9609ADC382E15F2064F7589C3B6A33F5DAEAB0E19D026AEA38DEFB22820899768E3470F122292E4FF20ECD52206B8792B415503836160D0D76C78CC3032DA2A119D9AAFFE8C2D7A441F62C59068628DAA515BFA299F93205194303281DD097A91F2C9A3FD736F96CA5DFE262D4DD501E2974D52E1000E97CB35CBC6C105FE2BD510FE38D4F09E1DF712F84AE0977555892AA2FB31462DDC9F28976C8BD6711B83DBB471CD3C7026F294D84713AD225D2451D09C23454E7D5F8B78CE978D20731585B9FABCE215CA301A90182088FA23BF1093E2BD2699EAEC17B2EF5BEF68D98FAECE7BEBECD60BDBD4DB4441BDE19AC6DA8AC712D63A9BB1CF91F784E384A2E2652FB183AFFBE6B08C9D4F0E68C2118B4DBB980C5828C02A68C37AEE5AAC6E873773C5FD9BBA9A632A770246F01754CF1654700BD4A7C898A51D99D7DA030C8563B0953C089E044EFE05575B7F",
            m: "3A5A72A840B8A0139BE3C58544EC8839B7969F9BEABF14AC0AC9ABA16ABFD33516ED2FA42D44FB67E2D6C27345E422F4DAB5DA398D56799C3011F37E295E62A8F519C4153335E4C4BE6B830865B312104BDE94FF6E0071FDEE05DD5349559DED3149069BCB51970CB333E0802437D7E96C1CB8D1262E673072E36F0605A207C53D91C3A891F363AA4434B8AE75D7ACB55CC11C78E418FC68E82CB1B88A6190C37EB2B67CD8CFE70068DAB82C8F35BD33DB0464FEEB1D73CB568281BE277D7C6C87DAB7426262E7AA47DBB39FB8E671863854FEC8208E7BA5327FCDCAF1016B09342091C2D7982DBFFA006B573BC976B8A44CABAC90BBFC5E17C566BED58075B261695DC8FC16AC18432CC8B3BC01AB8275FB139F18C9348377907FCFFD4D5E5F703982A7229C3770E15272C0D8B4CFBE17D25D2BF00F9879478F54C6A9C5257DD225E1AAAAE0D4ED4BF86783F0A567B6563B79B2BB610F053C7A1C33D1E00CEF301D4D8B7FE49C1DC0B4ED500079511656602C8E355FECDA625F5175978289A5FB0F7ACE8FCDEEC05E55E12E000759A8147A189521326A4CEFA8E79B40D519F09D10CF302897811856800F1E2BC2FB6D6E82DDA8D3C1548EC67700BA01BC8D67789B4C250748A07D228C894F9D64FB3184A5B9FC7BC490F2458F6191F3022A0CB2E8CE5D2A5E86321D72847FA6A391F78FFFF410D619830F649949641681437F",
            expected: "0D72368521895A7A53F8E5AA7D3A54B582B0CC274935746518C8F4BB2D5E6FA9E4CA20AAEC8BA4F09B24709E149F4A2DCCBBAF3784FF00D9F38B2F864AEF61F8B51CDE37802552455956A588F221F790B98F3125F8D86A7D4FDE8BC290E5F9A51E876898A1129F38E7D9239D0FE95244C9D473C6D1848AEDD4033B283B823A9512347CCA94CD5A58A27E333CC3D44457AABC916BBD3E4DF4B6C6AF2D26E8CE32BCB39096083F1D7CAEF9E93F9E97E3A34138FF62C4A1509768ED02D3268ECADD9389EF29E6484A7B96F73C4E7DE5451418ED6B5305F21AD82DE5638B0AD24BF4503807BBA5D327E16CD000BE013942C19190BA44793805CFFDEF76A1B7C4A5039FBAEEBF63CCD16F0CC6C02CB82F2AD81D846AB49811946C8075CABE038B708EF48EDD49081A721E4BF2E5B41A5D2189CE871AB91E19A3FE0EFF4D85A4C0959BD109C5D54D39876B95EBD020B621BC69C4A490763DAFAF31F732BA2D3486F9CEC222893AD0D2EB09CD1384EB77DBF56073B2BC694F3AE32D510B8D2F61130D3D0404C9737446DFA5DD3F29BBB2E0A89F3FE55E848C171752F6BA0C9E599A0DDCA779287A399810A58D9B93933A718E08A79D2713882EDA926EF8AF1899D5F399D0DAF303AD06CB5DE3A717C988B0F7F7A323133E7C3CDBB72F7BA00690FDF2D6B183325BFFB2FF706CE38FA5D052B3EAE30C9D42046235E9D4D1BC35D854D481",
        },
        TestVector{
            a: "A43F990C7E217B3E9F17613FA7DC6B8985A1BD2335D46C13DF91CE10655A9D61052B867F2DDD2ED6C4E8CBABA3EAB1E047F3A9E79A64FC20E9AA0F632A7B00412B2FE9D0BCA6F84BD81BC465D52F287ACF3B0A4F73DF28A908DDB16762E9CA2D0C82602F392563B64F4F8A44466C181A1CBC9763DE3D915CBD7F01DFEE6E9AAEBEF350575EB7F9538B1E6A111D9DFF0D3F9B5FBD4A0B06F83BE0B5FBC629CCE81DC8473D527D1B15F34414D964CE9576DCB97DAF701AEB663835D6818D63D2A5E281123A6B1209329DAEE810965EDC7A3BBC4E7843883CEDA477E44FA4D67DCA0E9E6A46C0BD28D69A6C2D457F19B99B5DF617A981E8E024A0ABC50700F452A6D9E51C7D50AD0B45F96C6853FCACB2B209F3AC83F9FE8A2FF54D7FA7E27B977FFC8B475790EE1E2502BE9547B86CB8C7922E60E44F19F33574186E2863290D1013D075EE9ED00D6DAD9FB9803E039D261223E2D3F736C841BD3C0ABFBAFCAF2FC3CE376938CC86C2735B07C77C31AA87723D0AA6A1D5A83610860D336ACC5ED67597728638651225B1D1980F22B2829C5001BB58B04C58A5669388D953F57FFB19B54226F0BCB6FCBA3822D84F4BF4CC2ED16C5974785F40472B9A37A9B7D049B1A2AF6648585C05A52EBE46D764F4D1597ECC16C0594551D361083828C6D7F14C2429C569E8F54DE34C75D0EE323193CC7FB1A51607786B935B3F491D848198",
            m: "999C92F418F636B023C7295D8619FC23DBCFBD206DCD1A3B08078BAEFF64E5814F71ACF35C7B724B9105D17DED3AE60ED24CBCCC636C870A2C5DCDD6F4F97A9ED93A878BCAF2DFD706C8B8C736C2666FCADB740CF21E0C6ED24496D61E5BB962400992DDE63ADD090BB1AC14B7A0EBDE12990C3FEA8572A683607C0D6BC95E9BEB4D857C1A33F13688E773904EEA85862EDC9620F47AA569F2D3657416970C89E483D7115FB1883257FAA8A2F8A906294634E352ACED39674C16E66D6C7A69F2563376FC638942CE4A6F9291B97BDBBA93E75FD4A5A5A782211B06E6E331E9309046D75753CBD6A5DAFF45E9DB62876B9C42EDC852C5ACCBFA7BD5286654775741FE2CADD3F7D378860092D9E3CA2CF3559060B952BC7294DB314179C1F5E739AEDF6424D91D968C1FC8D42AD249FD6EDE8795B8230817BBB74AAF72ABB0F6D3772EE6C0B2911300B99344E221DE6715181527ACA8CC3C9909B6D815D7207257A2B2D838E9D2F0537F52C1DDFD3ED7A3B10175409FE2CD18B100F5D843286A80B73116356A75F56662E495CA0EC955031EB9348B48FBCF52A65387B7F9E3D578F613FD22DBFE4C0CE042FE562B9274566D08BD8F52BE134D959D686DEABD2D429173F4C26B6DC0F4F3FE8CEB71E6FC371E9AEB7767BA076D0510410D28CAF5453D832659CF9BAA5061FE8868544AADFDD2532E47CFD95819BD725BDD23801083",
            expected: "0AA30618652B448E7B5037E221C26F65A9D20002C80751D8D78A426165F5B7DFB5B9D98BD161BC8B33E2FA2DB6AFCBD175A6ED1B36F87516BD4C418C358185A251F56244F1B41874D1530B9E9E6CC20B045F964281C11C3A36991A91448E10CACC78CD5152EA86AD439DDE2F8ECB2C3C0A238B23F3B81EB63A1E85D282A53C12D3A5CADB4484081D0236F680CEB3798710BEC99C5590618E490D5087AF92C05E3944702BF2CB92E39B496C366C258F4D96849A5CC32DB1FEEC1EF01420E968B38C4D9B3E0788C664533F557EDCE300BFA7D4EEA39DE2956B835CDD68C1A494997E5792EF6CF15230BF6CE75BA3B7322FC1B329E12F233358A62FEFDE9A9FDB4F97E6EFCF7CB537CD736BD57A18E285BEB4634BCAA742179B1A1C3E2E2085B0464DABE332B7D08798E2F5C11CE622BB58B3A6CB2C2C11DB79BCCDBEB5B778163C9CA18F2DEC3EFA6CF40C749E1C253610FA0EBB274E6A8BA8B38532A9E3DC3CD8211B5F304EF9966EF40845E97EF2D2E3C13B956601F2DB1D5F85175B27A3F455BE665C50CDEF1CBF4EED024513E92D99314886CD67508952C04001215A11AA8223A1450414BE6AEFD9F5248223B98075C1C8AECA21BA4BF2B18E31C9BEFAA307202EBAA3DCEA9B10B130315B657DF89A3AE3E09F589F3DE4CE50C72AFFFBE2AC0EA1036B9A4D4AFD814DED6899E78395FA2C835D462E2051D5E8E36BFA047115",
        },
        TestVector{
            a: "751BEBAB6B7F1828953449195430736C0961458D322BD21CC9EEBC724400069E1BAAE8B16C687AF4E8307FB2C5FECA5DC580C785A2AEAFB6F2CDC626CEA3EA01D3B87AD9BD5FED8F031B1053E0D10BAA69B551CBDAD468DBAE14CA8551AFB43C30FF86E3DD850071C09E894DD46A8CFD17F46EFC85698B51895B60E86FE629C8B1CB4C345EA776EF65BB8A2A0B0C0B39AF8E1CB5668D3770B2847B9933CBA471B4B54C50E1FE9284039445C48A0C158463E4E5E23A121FF5FF7417763CB56F2185A1032F7CD5DB7D44CF3BB15CDEC86D52BA2276EBBE4E3DAA55CD06B442CDB04B2CDC741E699F9515068BC4FBF88647750D9ABFC4B41AE210D4C929B6A9893CE70BBE03AF2E7363368673E5A2640C64F4127D4D7CCB567E4F832BEC6381B545A27EBB1BF35A6CE4624A82E6BF5ED200CB616FBE1F24A54F51ECDF90D6E7C765A96472B4C1036559D4D2FC6E10EC6716A0E6832CF228AAE285CE01C2963D64DB74997C374ABCFF5613FFDE88B28A703BECEE752A75E8C36EBBF896C932503ED8D2F378C67275BA13C2F60DF4E53ACE017FF12187723D34233A99D78BCB3862C5E6A971357306F14D7710360B8ECFD49EDE48A3358FF51C5F67E5D851296EE0CFF7D2B8A430669E59A4AC4774E10F681BF5BF3D1418018FADE0181CA18AEE9195BC729E23AA4711239D726ECCD30DC4A43956C553185F82FC172DE15045F35F31",
            m: "18D128A4C4BF844651C18433713E07AFB5EE26E0964CB8576AEB43BB6BCB7F3DF18DA342BE8B6FEEC2E07ED72AEAF03568F80CA49B31348465C83D791764FA52884209F8C5C8F883E628D5C6A2974E4178820E768B6E8347833BA1C17B7B788FBC4239A3B8526A0FE48D4408AAA8723D34F840BB74CCAB360C3D601FC87D864E3F80E68642550D52911C4631DEB8C8BEC46B658190031E2072BA976AF477F0D3B5480A9B18842746EDD25C133BC444352FDA1124E394FC872C00F893B8EB70AAB36765D7AD889B808FAEE4B5D26433EB3D523568CB253E8329D15EAAB5A1CFF717192F013121A665F518CA432C5B6B874B40F8C803ADAE15A246F62B101BEED66B1E3072C29D7D5C446E0BCC31C10ED3B2F6A89347EFADE5B0022FCC9EDCD28B4F8741EE772915078B64E8FA338E1E3D0F7998A570E11878BFE035B5057641BEA234B265002D313204EC1C1D8C5D736E2519914E6F268F9BEC96FF52C32EDC57A357F901A283AA107C85D5545A9EAB157804054831811C09430E1F014A8B7A0F30B30F24077F173B214A354A25AF4F94E302E377CCC3D019231D9620F8687080EB22C3DC9A2B28A0D6E88E712F75ADDE02FF94C68B91D05D4316ADE2E51158D8941755ADC04AA059288989CCD3D92448E79015D82E827E2D2603DFABD40CC9A982183F3F62EF8A333E26A61D82577A27A656B155324CE8821BD70959D19036EF",
            expected: "11D749185881070F4E2E384B8F3854AD31A8AA0AD8F8F0BF1E41AD8494D209A655745BA6723ABB39DCAE84561A53098821A094F335E9DDA55BACD042711000B7B2B052F6A63C0B7F6A77B9395673D2A487AD17F1AD1A5BBDA126437F63C1D1FD3FF6A054FC3B58322E69792B29C8C40844136C0EB236DE795865E0694DF0108FB3C7B21B555341A5214A71629028E83E9DE086AF2680BEEEE79A1DED61EBE122DF9521E47FEDF5684C4AD5779AFB04AFA47CA14EABBE2DD94F7035275907AC76B8036BD0C6B36D7B0613A8DA134DF8C05D714CD3BF2954310310525BDDBB8DD3EEC8206F59E305FD40A362B84A8AD82A4809B79FB5FD628B87B8F07D7639CDE33A92FC38A4B87DF224CE44B4DB5FD1162837DB005D0C9EE78F7A6CB9E80E6B186461B36216B618C634B6DEFDF126590C8D7B0D285BA0436C526C08BCC10EC06B2091A920C04EA091C1228BF7DF76995E0C803DF3358E6C72D37204778981F37CE7399830C0AE571421E88937480FC3E60CDE6009AFE45349AFC01AC40822569C10273C3654795D273DCD38CC4E7D8FADF3E593A83F2DF3BEAE237F07E996A0C23A1E61C30A5A4ECA1B6DFC46D0F91D26D24A501B61ADDAEA5B8B20C595297D6DA77561ED2F3C1CF50286204191AAD6F8577EE5B35DF796F948089DF23ABB6AEFB411A1261E88E856A4D7D656C9AFDC059FFBFFFE4F2BE0F3A7D1BBE8FFB28375",
        },
        TestVector{
            a: "1A81A93424478C8266DE29CCCE9080C2A07412AE2D4F7B8F4AAF90AE3664091D278A6F5DBF03C7294561B8BE700E8898D05A2CD2B89A75469773DB5F554E86D68EF520F6E929CB0239EA7A4FE62A1E8D2EF24F227980A7D5159A44569AAA786D8574711FD8DF1E5EE77F3036C435D0F1D6806252631C63602BF2F1D1BFA31EEF59C8A31B60849F9C9AF6E47B12D158C9458AE99D03BA45375814083922A63DCEE4A4AC7445A634F837777922AE2FDD5A9EFDC04102E0CD1E77E210FEAA7C172BE8911380C8B64C23872C47104CB4DD48465B74D292F85FCACB4204906CBDD3E793D126394CD9390B2143BABC8EA9EC197935BDEF9F0C7DA20009E96B224CD2BA43FD7A1710B52BA8284B6F47D9624869343E0168D310638A68465F2A2DF51B5F2CB6B41AEDA8FDB990E312A050E3E3DF7F2DA1EA5F7E7FC3ADF0B61A24A1FF840CE0FE12F925D59B76EE46C4ECB6CD4897DB1C36738A29D968D40535E5D9900206CA6118B07B88DBB405FA16FC88724A4711CC91A1808A97153842D19DC560155FC652B59B3A143D390C0ABBC98001D527F629E18C3C58DC65F4A99D460D74D5E270FC6D167FF0DAC974171E1D7F79EC7ED619469D018AA4F1A446B624F9C8498697EEB1ABCEAEDF81E17A9C460A22AECAAEAC0FCA97EAF8851C74E634FDC713B92F2C82FA3096AA6D5862542228F12D03A4F4656ABB1719310F2295EBF2573F",
            m: "EA622DABFB1D3A5F6142737840143FA6A8AFA792FA99666BF85AD72FE310E9B7790383A7EFC07C36B9DD5DC8BDAE30F5B11C5A944EBF257C5196EE5D84B75A45E336518495B5E6AAB20FB563CA7E0DB1DA7D58F23CBB35CEAF95F3767B778695C1B86584AFC84B9138433469BDAE63D62EAEF2A720632F2C4AE21F904F8843FD31F5B30A14643BF7E9983F5EFFDDBC20F75B9B9DD92F2219959F1C05B7FAA59F779E34B0979921CF81057D7D4E2BBB5992E1476A41D8E0EDF58801948DB06B736B6D651CDD79BC85665362B99BFE267789CB17564F8AC634110A9BA5291F54F0F444A11AE24EF14E8CA9D4B21AEABB3E0123E7380E251231AAAB55B4FE1FCB7E553C647F11E0D8BD81B400AE57A263D2EC43ACD37F71944FCC200714C604BF31AF50FAEE61993035E3D99DE6C96E73D3426C8FECD586A98525E6F5EC8E2D212F4B98279AB68D54C8D1D670B2693F38790D2E685CDB1FE82636672E9A07BDF9248A23835880A8ACE5623F052F6571119EF4F9C664E9367CCB3A81EE9FD5C0DD575BAA83389E829E233719443FE66A7BC5BD1A93286EBC9287416E63AAF7CBA04DCE200B236157A414FD1AF4CC42EDB22198A6B7E31D94E09CF5A723BAB5072B707BBCAF8EE2622DE336009C2E98BBBA14881E12E1B637A7D52B69A0BEFEF6D35061C517BDD7B641D7429A3B240F24EEA701996F2DA71B567D838E1D22342D64E3",
            expected: "1A81A93424478C8266DE29CCCE9080C2A07412AE2D4F7B8F4AAF90AE3664091D278A6F5DBF03C7294561B8BE700E8898D05A2CD2B89A75469773DB5F554E86D68EF520F6E929CB0239EA7A4FE62A1E8D2EF24F227980A7D5159A44569AAA786D8574711FD8DF1E5EE77F3036C435D0F1D6806252631C63602BF2F1D1BFA31EEF59C8A31B60849F9C9AF6E47B12D158C9458AE99D03BA45375814083922A63DCEE4A4AC7445A634F837777922AE2FDD5A9EFDC04102E0CD1E77E210FEAA7C172BE8911380C8B64C23872C47104CB4DD48465B74D292F85FCACB4204906CBDD3E793D126394CD9390B2143BABC8EA9EC197935BDEF9F0C7DA20009E96B224CD2BA43FD7A1710B52BA8284B6F47D9624869343E0168D310638A68465F2A2DF51B5F2CB6B41AEDA8FDB990E312A050E3E3DF7F2DA1EA5F7E7FC3ADF0B61A24A1FF840CE0FE12F925D59B76EE46C4ECB6CD4897DB1C36738A29D968D40535E5D9900206CA6118B07B88DBB405FA16FC88724A4711CC91A1808A97153842D19DC560155FC652B59B3A143D390C0ABBC98001D527F629E18C3C58DC65F4A99D460D74D5E270FC6D167FF0DAC974171E1D7F79EC7ED619469D018AA4F1A446B624F9C8498697EEB1ABCEAEDF81E17A9C460A22AECAAEAC0FCA97EAF8851C74E634FDC713B92F2C82FA3096AA6D5862542228F12D03A4F4656ABB1719310F2295EBF2573F",
        },
        TestVector{
            a: "5ADFCD98B198F8E3280D9475AB4E2B2FF7C9CB008C197D58F72C89096646A73F170972644871D9329C32EE1931F1F016F4A6E6A490CB175CBAFEBBCEA5E2A982B678A88AA4E3910136663283B1F550A87F84F6AA722F34E24264ACBA1542160BCCABC8831BD2DA0A4E3EAD8464069646957D33BFF8DD31C0582E3EC47D39AC1E4DB6C10627B4EF670A429EE457E93A41E7C64122F71226ED8C7DADC7ABF4418530F1034B4A81FC739CDDA0524EE16DBCE100FA519D97834DF70270981B5C8C42C88891E73BF3B534C631F87CE0598D100F3AD3246E9ED7B2F6C4D3BD8B342E1FBDA8021AF555D01B2D26F9DE8864B96B01ECF6BB8F789B7C749ECD9635EC1FA903D1ED4DD289C63131BDFF8AEE0A89756B8017EE567E00BAF7FF22A83351BA332DDCABDAD7D8300913DE361F9411C8744536A04B0829765540F3DB77C7E0C397BEFB72F9292B2A83A01642EED02B5A9115AF3558E8D4D72D64A298F6C958FC930C663217D09BA55059901F0F624117204841590851606F39674089688313EB90100645404F2ED012A9D8EC74875316B57ABF492B3DBD781618A4A90E16AF0A4ABD64FD04DCC5BC8C65D70B4C685DC6048FF7149E6DB1275F1692E9856538B2EDFB9CA9B392911B47D00E052FB573F2565EC33957376635B78E0206E8DB3CDD3E0E7A928D570ED766FAE2248FC000C75D24F594CA781C264E0250E3CCBD7589B8",
            m: "890810D24C0FEBBA57460C8530E409ADF39C1A1A8BA19F945ADF909624E2B5C595B1D1F10394AAF41AB68A76F65B5639A9BFC55C317857F301E6F47AAF4CEC5025891D0F45A99E78DD2E536A0EA15F2F22192CD16BD41050D51F6424E1A48D5AC0D0B6A312F9374239488C0F6960CD40B214A9EDB32998B0F502B27DDA035C89A03C3734E5A3DB99184E28227559728021AD64F083CCAB343E4209830AFB4DA053C16DB1304F9A3D0575E09C1D84E9228838656E03C712E847B843C4A995A9BC69EF74179ADAE56E9CB23C7B5CDB843F0D2DDEAAB5667F12C36EDBFA07E225728401D145E0C368FAEF58CF55EA696C237E1B2493214962B37A223B35583A785FF794911CB114711AB16DEF408D74213FCD4615717931CE95579C9B988AF2987371ABC496763C109A0ACF6CA933478D2C901A1FC12287B176BD2CF4341E23581BC7C145B3F637953C4FC7D7FB9DBB1D7B56EC4F3A3B4F21B7DE83F621490F10479D85D284CD319D037D611AF479F43332505F091A6D5229327E7950C2DCF19AEAABC640FA08101847AB57FC16716F563CAD0AD7489423D7A7FB51FD47FF41BEE8E7E57B1559F4B0E93828FA37BF49C07D5918E8AB2CE3933D2BC6657441B1753A8B4EDA60718744D3C33323B3FAE06BB633A1969133CBE5737081136144609264BEB8E454C5B286B80E88F9408188F2AE603A609535854B5DF1AA1BFD2746124D",
            expected: "5ADFCD98B198F8E3280D9475AB4E2B2FF7C9CB008C197D58F72C89096646A73F170972644871D9329C32EE1931F1F016F4A6E6A490CB175CBAFEBBCEA5E2A982B678A88AA4E3910136663283B1F550A87F84F6AA722F34E24264ACBA1542160BCCABC8831BD2DA0A4E3EAD8464069646957D33BFF8DD31C0582E3EC47D39AC1E4DB6C10627B4EF670A429EE457E93A41E7C64122F71226ED8C7DADC7ABF4418530F1034B4A81FC739CDDA0524EE16DBCE100FA519D97834DF70270981B5C8C42C88891E73BF3B534C631F87CE0598D100F3AD3246E9ED7B2F6C4D3BD8B342E1FBDA8021AF555D01B2D26F9DE8864B96B01ECF6BB8F789B7C749ECD9635EC1FA903D1ED4DD289C63131BDFF8AEE0A89756B8017EE567E00BAF7FF22A83351BA332DDCABDAD7D8300913DE361F9411C8744536A04B0829765540F3DB77C7E0C397BEFB72F9292B2A83A01642EED02B5A9115AF3558E8D4D72D64A298F6C958FC930C663217D09BA55059901F0F624117204841590851606F39674089688313EB90100645404F2ED012A9D8EC74875316B57ABF492B3DBD781618A4A90E16AF0A4ABD64FD04DCC5BC8C65D70B4C685DC6048FF7149E6DB1275F1692E9856538B2EDFB9CA9B392911B47D00E052FB573F2565EC33957376635B78E0206E8DB3CDD3E0E7A928D570ED766FAE2248FC000C75D24F594CA781C264E0250E3CCBD7589B8",
        },
        TestVector{
            a: "C57757A58611C20535639A9D16C49E07220210F5250BEAAEF836E8B30954270F837414A50ADF9AF081338EEC0CE3DD10CED051CDBC754FC84C351DAB70E99B23315168234E86FE4BF07A49F501AF1F40E3E595D7C1C101EBB60FFF279F4C5D92BDFB973DC3AE89C529664F37C3979340494DC1F1F72FCF77CB2D2AD7C036BF1400CDA6B29F5612D6EBDE7F779FE28B047BFB5C87B62565E5D8B4B664F854F8E9F4DD7D2FFBFF6F5DA2D478E77BA3B22F2528EC2B8D3C900C19604B7620F4678AA28BC50CECBDB161F9BFFF7759BC0FE1BB8B6ABF505FE08F4E6E73B38C3E7B9CD82FB7CE7BF4ACE2569AF65DF6C04AF8C8F22CC66CC482EE9F260445B96DA19CA9F77C9A07A717EABEEDB0E3FA9351CDCE80E3363DCC589FDAAF294B388173939A4A5585A3814BCA3C44F48A35341FE9C213D3789B84F7C93D738C2C13990956290756D266468969833EEE188B29C9E543222BFF9D95B32F614940040BA273EF26D051255D8315AF08FFB788DDAB9E0CCA9FB644AAB189B52DF04F256488BF9BB919AD8B9F48A862D83655D3A2FAADFF2819371152C2E11EF5D6165DE017107C3A007BC374720D57B5722A2550C1324FE187526CE519BCCA2C06F8E3AE61C2064F1EAE452BF01694BC496DD144F1E0BA07F3191F55D09C63744663B27D10AF06780F6C4CD6E446567B8D3BE75C6F925AC44412323702C3A8B026A6B971F8819E",
            m: "7BC9C33B36FA3B80974420CD3B928DC8E753F5D7B96E76BBC02DC59144A9205791CC9D44C727E6CA87F0FF71344B7F7E4D8429745B73E63F63CD5ED2AFF672648F13EC28048D1D610D2CB5B6D1E0EB64824A16BF331BE6FABB6E16B53012AF6CCE28E3C2BECAD72F41190CB5EEEC6DAD8A6C51777718A6EE1CECBBBDDEA140A0B2539C57C4C9802BDD2A26FD4F8EF5E6C70371AA7092422F5539DECB14A0B8278E2E2960F2C9CF9BDAD00945A3D4D3455A3264ECE4CE4430244D5F69F35F8FA656BBE67C76CEB37C002E9AA1718A3ED50F5CCC6E4A7ED8777D037BF833BDF5FFA0A0A56F0B693A250120C7DD1165972F4ECC504A6586C35E7C69FEC633EE3BA50778CA635C95842A44A6DADDE190E08034B1705E0C186576B291ED8776B3D9E44A128B12AA46F0782858B68ACD5C731F8EC4800E627612065072B1E980497B3797E54E0DB54137EE2F1B795FE75BD9735E14477D049088C067F814E561F73C84E769C84CF565F6D9AB5BA4B4F07AC42E5B721EFDCA7CB2605A0ACCB44D7C0578A84D853915096F44935E3C254015F6A30E25FAB82EFFAC2F71E5091493BC4A86AA9B663523BEF79B93E793DE5C6FE18AC8BD149C8E8237538B311C9CF279AFBDDC07F2C98F65A383D113A90BB0324FEA2DCFC4B3319124060590D5BC36B6F57BC1C953A8701378F87AD2567B3145190754A3E78E06CFF62947D5D91343530129",
            expected: "49AD946A4F1786849E1F79CFDB32103E3AAE1B1D6B9D73F338092321C4AB06B7F1A7776043B7B425F9428F7AD8985D92814C285961016988E867BED8C0F328BEA23D7BFB49F9E0EAE34D943E2FCE33DC619B7F188EA51AF0FAA1E8726F39AE25EFD2B37B04E3B295E84D4281D4AB2592BEE1707A80172889AE406F19E1957E734E7A0A5ADA8C92AB0EB4587A5053951DB4F7EADD459323B6837AD799E3B440C266AF53CF09359FC1C8046FA1D7CEDEE9CAF6873EA86E4BDBF512EC0C2D94D7E44BCFDE9075EEFDE5F99164D5E831D10CAC2E9E5105E10817D16AF7BB5880859D378F125F708B72BD557A2E80E55AB3C97A25DC7C073DBF9022BC057F857F65F7A27EB236AB1193C07A46D6061902714D99CF72D831B3F329281D3BC3C1CD99AF5037CA72F93A5B5213EC3DFF67D7ACCA334F536A390EE5C2ED00DA42934F8E1E912208C4B105517B542374B8A3CDF071E50DE48299052A6EF9512B1EA9AB376A3F6688D8681D1ED55DA412D3ED30D9DE6F2D9746E034D754D3E58271170CBA2310CC28528A3F391E44D819AE62E4B75C19F33C5923C334EF83F10D494C5AC5F58F65158E50B315BC218A9646F45150C518CA3DD056978576A0D5DC46BBE812487316BB7B9C8A7310EB35C4C594BF90CFDA23546C243F785D6EB58DF64659B98AB64618A466D0CD5E00BAE56C2B2A79536FA02AA43032CD7F6850CDA62EA58075",
        },
    ];

    for (i, t) in tests.iter().enumerate() {
        let mut a = BigUInt::from_hex(t.a).unwrap();
        let mut modulus = BigUInt::from_hex(t.m).unwrap();
        let expected = BigUInt::from_hex(t.expected).unwrap();

        let result = a.mod_reduce(&mut modulus).expect("mod_reduce() failed");

        // we need to get the hex version of the result incase we need to report
        // it in a test failure.
        let res_hex = result.to_hex();
        assert!(
            result == expected,
            "Test {}. Expected {}...{}. Got {}...{}",
            i,
            &t.expected[0..9],
            &t.expected[(&t.expected.len() - 10)..],
            &res_hex[0..9],
            &res_hex[(&res_hex.len() - 10)..],
        );
    }
}
