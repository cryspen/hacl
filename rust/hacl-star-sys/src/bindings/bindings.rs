/* automatically generated by rust-bindgen 0.63.0 */

pub const Spec_Hash_Definitions_SHA2_224: u32 = 0;
pub const Spec_Hash_Definitions_SHA2_256: u32 = 1;
pub const Spec_Hash_Definitions_SHA2_384: u32 = 2;
pub const Spec_Hash_Definitions_SHA2_512: u32 = 3;
pub const Spec_Hash_Definitions_SHA1: u32 = 4;
pub const Spec_Hash_Definitions_MD5: u32 = 5;
pub const Spec_Hash_Definitions_Blake2S: u32 = 6;
pub const Spec_Hash_Definitions_Blake2B: u32 = 7;
pub const Spec_Hash_Definitions_SHA3_256: u32 = 8;
pub const Spec_FFDHE_FFDHE2048: u32 = 0;
pub const Spec_FFDHE_FFDHE3072: u32 = 1;
pub const Spec_FFDHE_FFDHE4096: u32 = 2;
pub const Spec_FFDHE_FFDHE6144: u32 = 3;
pub const Spec_FFDHE_FFDHE8192: u32 = 4;
pub const Spec_Agile_AEAD_AES128_GCM: u32 = 0;
pub const Spec_Agile_AEAD_AES256_GCM: u32 = 1;
pub const Spec_Agile_AEAD_CHACHA20_POLY1305: u32 = 2;
pub const Spec_Agile_AEAD_AES128_CCM: u32 = 3;
pub const Spec_Agile_AEAD_AES256_CCM: u32 = 4;
pub const Spec_Agile_AEAD_AES128_CCM8: u32 = 5;
pub const Spec_Agile_AEAD_AES256_CCM8: u32 = 6;
pub const EverCrypt_Error_Success: u32 = 0;
pub const EverCrypt_Error_UnsupportedAlgorithm: u32 = 1;
pub const EverCrypt_Error_InvalidKey: u32 = 2;
pub const EverCrypt_Error_AuthenticationFailure: u32 = 3;
pub const EverCrypt_Error_InvalidIVLength: u32 = 4;
pub const EverCrypt_Error_DecodeError: u32 = 5;
pub const EverCrypt_Error_MaximumLengthExceeded: u32 = 6;
pub type Spec_Hash_Definitions_hash_alg = u8;
pub type Spec_FFDHE_ffdhe_alg = u8;
pub type Spec_Agile_AEAD_alg = u8;
pub type EverCrypt_Error_error_code = u8;
extern "C" {
    #[doc = "Encrypt a message `m` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the message.\n@param m Pointer to `mlen` bytes of memory where the message is read from.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is written to.\n@param mac Pointer to 16 bytes of memory where the mac is written to."]
    pub fn Hacl_Chacha20Poly1305_32_aead_encrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    );
}
extern "C" {
    #[doc = "Decrypt a ciphertext `cipher` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\nIf decryption succeeds, the resulting plaintext is stored in `m` and the function returns the success code 0.\nIf decryption fails, the array `m` remains unchanged and the function returns the error code 1.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the ciphertext.\n@param m Pointer to `mlen` bytes of memory where the message is written to.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is read from.\n@param mac Pointer to 16 bytes of memory where the mac is read from.\n\n@returns 0 on succeess; 1 on failure."]
    pub fn Hacl_Chacha20Poly1305_32_aead_decrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    ) -> u32;
}
pub type uint32x4_t = [u32; 4usize];
pub type Lib_IntVector_Intrinsics_vec128 = uint32x4_t;
extern "C" {
    #[doc = "Encrypt a message `m` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the message.\n@param m Pointer to `mlen` bytes of memory where the message is read from.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is written to.\n@param mac Pointer to 16 bytes of memory where the mac is written to."]
    pub fn Hacl_Chacha20Poly1305_256_aead_encrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    );
}
extern "C" {
    #[doc = "Decrypt a ciphertext `cipher` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\nIf decryption succeeds, the resulting plaintext is stored in `m` and the function returns the success code 0.\nIf decryption fails, the array `m` remains unchanged and the function returns the error code 1.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the ciphertext.\n@param m Pointer to `mlen` bytes of memory where the message is written to.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is read from.\n@param mac Pointer to 16 bytes of memory where the mac is read from.\n\n@returns 0 on succeess; 1 on failure."]
    pub fn Hacl_Chacha20Poly1305_256_aead_decrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    ) -> u32;
}
extern "C" {
    #[doc = "Encrypt a message `m` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the message.\n@param m Pointer to `mlen` bytes of memory where the message is read from.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is written to.\n@param mac Pointer to 16 bytes of memory where the mac is written to."]
    pub fn Hacl_Chacha20Poly1305_128_aead_encrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    );
}
extern "C" {
    #[doc = "Decrypt a ciphertext `cipher` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\nIf decryption succeeds, the resulting plaintext is stored in `m` and the function returns the success code 0.\nIf decryption fails, the array `m` remains unchanged and the function returns the error code 1.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the ciphertext.\n@param m Pointer to `mlen` bytes of memory where the message is written to.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is read from.\n@param mac Pointer to 16 bytes of memory where the mac is read from.\n\n@returns 0 on succeess; 1 on failure."]
    pub fn Hacl_Chacha20Poly1305_128_aead_decrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_shaext() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_aesni() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_pclmulqdq() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_bmi2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_adx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_sse() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_movbe() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_rdrand() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx512() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_recall();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_init();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_bmi2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_adx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_shaext();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_aesni();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_pclmulqdq();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_sse();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_movbe();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_rdrand();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx512();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_vec128() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_vec256() -> bool;
}
extern "C" {
    pub fn EverCrypt_AEAD_uu___is_Ek(
        a: Spec_Agile_AEAD_alg,
        projectee: EverCrypt_AEAD_state_s,
    ) -> bool;
}
extern "C" {
    #[doc = "Return the algorithm used in the AEAD state.\n\n@param s State of the AEAD algorithm.\n\n@return Algorithm used in the AEAD state."]
    pub fn EverCrypt_AEAD_alg_of_state(s: *mut EverCrypt_AEAD_state_s) -> Spec_Agile_AEAD_alg;
}
extern "C" {
    #[doc = "Create the required AEAD state for the algorithm.\n\nNote: The caller must free the AEAD state by calling `EverCrypt_AEAD_free`.\n\n@param a The argument `a` must be either of:\n `Spec_Agile_AEAD_AES128_GCM` (KEY_LEN=16),\n `Spec_Agile_AEAD_AES256_GCM` (KEY_LEN=32), or\n `Spec_Agile_AEAD_CHACHA20_POLY1305` (KEY_LEN=32).\n@param dst Pointer to a pointer where the address of the allocated AEAD state will be written to.\n@param k Pointer to `KEY_LEN` bytes of memory where the key is read from. The size depends on the used algorithm, see above.\n\n@return The function returns `EverCrypt_Error_Success` on success or\n`EverCrypt_Error_UnsupportedAlgorithm` in case of a bad algorithm identifier.\n(See `EverCrypt_Error.h`.)"]
    pub fn EverCrypt_AEAD_create_in(
        a: Spec_Agile_AEAD_alg,
        dst: *mut *mut EverCrypt_AEAD_state_s,
        k: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Encrypt and authenticate a message (`plain`) with associated data (`ad`).\n\n@param s Pointer to the The AEAD state created by `EverCrypt_AEAD_create_in`. It already contains the encryption key.\n@param iv Pointer to `iv_len` bytes of memory where the nonce is read from.\n@param iv_len Length of the nonce. Note: ChaCha20Poly1305 requires a 12 byte nonce.\n@param ad Pointer to `ad_len` bytes of memory where the associated data is read from.\n@param ad_len Length of the associated data.\n@param plain Pointer to `plain_len` bytes of memory where the to-be-encrypted plaintext is read from.\n@param plain_len Length of the to-be-encrypted plaintext.\n@param cipher Pointer to `plain_len` bytes of memory where the ciphertext is written to.\n@param tag Pointer to `TAG_LEN` bytes of memory where the tag is written to.\nThe length of the `tag` must be of a suitable length for the chosen algorithm:\n `Spec_Agile_AEAD_AES128_GCM` (TAG_LEN=16)\n `Spec_Agile_AEAD_AES256_GCM` (TAG_LEN=16)\n `Spec_Agile_AEAD_CHACHA20_POLY1305` (TAG_LEN=16)\n\n@return `EverCrypt_AEAD_encrypt` may return either `EverCrypt_Error_Success` or `EverCrypt_Error_InvalidKey` (`EverCrypt_error.h`). The latter is returned if and only if the `s` parameter is `NULL`."]
    pub fn EverCrypt_AEAD_encrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic\nhardware check. You MUST make sure your hardware supports the\nimplementation of AESGCM. Besides, this function was not designed\nfor cross-compilation: if you compile it on a system which doesn't\nsupport Vale, it will compile it to a function which makes the\nprogram exit."]
    pub fn EverCrypt_AEAD_encrypt_expand_aes128_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic\nhardware check. You MUST make sure your hardware supports the\nimplementation of AESGCM. Besides, this function was not designed\nfor cross-compilation: if you compile it on a system which doesn't\nsupport Vale, it will compile it to a function which makes the\nprogram exit."]
    pub fn EverCrypt_AEAD_encrypt_expand_aes256_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_aes128_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_aes256_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand_chacha20_poly1305(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt_expand(
        a: Spec_Agile_AEAD_alg,
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Verify the authenticity of `ad` || `cipher` and decrypt `cipher` into `dst`.\n\n@param s Pointer to the The AEAD state created by `EverCrypt_AEAD_create_in`. It already contains the encryption key.\n@param iv Pointer to `iv_len` bytes of memory where the nonce is read from.\n@param iv_len Length of the nonce. Note: ChaCha20Poly1305 requires a 12 byte nonce.\n@param ad Pointer to `ad_len` bytes of memory where the associated data is read from.\n@param ad_len Length of the associated data.\n@param cipher Pointer to `cipher_len` bytes of memory where the ciphertext is read from.\n@param cipher_len Length of the ciphertext.\n@param tag Pointer to `TAG_LEN` bytes of memory where the tag is read from.\nThe length of the `tag` must be of a suitable length for the chosen algorithm:\n `Spec_Agile_AEAD_AES128_GCM` (TAG_LEN=16)\n `Spec_Agile_AEAD_AES256_GCM` (TAG_LEN=16)\n `Spec_Agile_AEAD_CHACHA20_POLY1305` (TAG_LEN=16)\n@param dst Pointer to `cipher_len` bytes of memory where the decrypted plaintext will be written to.\n\n@return `EverCrypt_AEAD_decrypt` returns ...\n\n `EverCrypt_Error_Success`\n\n... on success and either of ...\n\n `EverCrypt_Error_InvalidKey` (returned if and only if the `s` parameter is `NULL`),\n `EverCrypt_Error_InvalidIVLength` (see note about requirements on IV size above), or\n `EverCrypt_Error_AuthenticationFailure` (in case the ciphertext could not be authenticated, e.g., due to modifications)\n\n... on failure (`EverCrypt_error.h`).\n\nUpon success, the plaintext will be written into `dst`."]
    pub fn EverCrypt_AEAD_decrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic\nhardware check. You MUST make sure your hardware supports the\nimplementation of AESGCM. Besides, this function was not designed\nfor cross-compilation: if you compile it on a system which doesn't\nsupport Vale, it will compile it to a function which makes the\nprogram exit."]
    pub fn EverCrypt_AEAD_decrypt_expand_aes128_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "WARNING: this function doesn't perform any dynamic\nhardware check. You MUST make sure your hardware supports the\nimplementation of AESGCM. Besides, this function was not designed\nfor cross-compilation: if you compile it on a system which doesn't\nsupport Vale, it will compile it to a function which makes the\nprogram exit."]
    pub fn EverCrypt_AEAD_decrypt_expand_aes256_gcm_no_check(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_aes128_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_aes256_gcm(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand_chacha20_poly1305(
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt_expand(
        a: Spec_Agile_AEAD_alg,
        k: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Cleanup and free the AEAD state.\n\n@param s State of the AEAD algorithm."]
    pub fn EverCrypt_AEAD_free(s: *mut EverCrypt_AEAD_state_s);
}
extern "C" {
    #[doc = "Compute the scalar multiple of a point.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where the public point is read from."]
    pub fn Hacl_Curve25519_64_scalarmult(out: *mut u8, priv_: *mut u8, pub_: *mut u8);
}
extern "C" {
    #[doc = "Calculate a public point from a secret/private key.\n\nThis computes a scalar multiplication of the secret/private key with the curve's basepoint.\n\n@param pub Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    pub fn Hacl_Curve25519_64_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    #[doc = "Execute the diffie-hellmann key exchange.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where **our** secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where **their** public point is read from."]
    pub fn Hacl_Curve25519_64_ecdh(out: *mut u8, priv_: *mut u8, pub_: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Compute the scalar multiple of a point.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where the public point is read from."]
    pub fn Hacl_Curve25519_51_scalarmult(out: *mut u8, priv_: *mut u8, pub_: *mut u8);
}
extern "C" {
    #[doc = "Calculate a public point from a secret/private key.\n\nThis computes a scalar multiplication of the secret/private key with the curve's basepoint.\n\n@param pub Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    pub fn Hacl_Curve25519_51_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    #[doc = "Execute the diffie-hellmann key exchange.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where **our** secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where **their** public point is read from."]
    pub fn Hacl_Curve25519_51_ecdh(out: *mut u8, priv_: *mut u8, pub_: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Calculate a public point from a secret/private key.\n\nThis computes a scalar multiplication of the secret/private key with the curve's basepoint.\n\n@param pub Pointer to 32 bytes of memory where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    pub fn EverCrypt_Curve25519_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    #[doc = "Compute the scalar multiple of a point.\n\n@param shared Pointer to 32 bytes of memory where the resulting point is written to.\n@param my_priv Pointer to 32 bytes of memory where the secret/private key is read from.\n@param their_pub Pointer to 32 bytes of memory where the public point is read from."]
    pub fn EverCrypt_Curve25519_scalarmult(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8);
}
extern "C" {
    #[doc = "Execute the diffie-hellmann key exchange.\n\n@param shared Pointer to 32 bytes of memory where the resulting point is written to.\n@param my_priv Pointer to 32 bytes of memory where **our** secret/private key is read from.\n@param their_pub Pointer to 32 bytes of memory where **their** public point is read from."]
    pub fn EverCrypt_Curve25519_ecdh(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8)
        -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_Streaming_SHA2_state_sha2_224_s {
    pub block_state: *mut u32,
    pub buf: *mut u8,
    pub total_len: u64,
}
pub type Hacl_Streaming_SHA2_state_sha2_224 = Hacl_Streaming_SHA2_state_sha2_224_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_Streaming_SHA2_state_sha2_384_s {
    pub block_state: *mut u64,
    pub buf: *mut u8,
    pub total_len: u64,
}
pub type Hacl_Streaming_SHA2_state_sha2_384 = Hacl_Streaming_SHA2_state_sha2_384_s;
extern "C" {
    #[doc = "Allocate initial state for the SHA2_256 hash. The state is to be freed by\ncalling `free_256`."]
    pub fn Hacl_Streaming_SHA2_create_in_256() -> *mut Hacl_Streaming_SHA2_state_sha2_224;
}
extern "C" {
    #[doc = "Copies the state passed as argument into a newly allocated state (deep copy).\nThe state is to be freed by calling `free_256`. Cloning the state this way is\nuseful, for instance, if your control-flow diverges and you need to feed\nmore (different) data into the hash in each branch."]
    pub fn Hacl_Streaming_SHA2_copy_256(
        s0: *mut Hacl_Streaming_SHA2_state_sha2_224,
    ) -> *mut Hacl_Streaming_SHA2_state_sha2_224;
}
extern "C" {
    #[doc = "Reset an existing state to the initial hash state with empty data."]
    pub fn Hacl_Streaming_SHA2_init_256(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    #[doc = "Feed an arbitrary amount of data into the hash. This function returns 0 for\nsuccess, or 1 if the combined length of all of the data passed to `update_256`\n(since the last call to `init_256`) exceeds 2^61-1 bytes.\n\nThis function is identical to the update function for SHA2_224."]
    pub fn Hacl_Streaming_SHA2_update_256(
        p: *mut Hacl_Streaming_SHA2_state_sha2_224,
        input: *mut u8,
        input_len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "Write the resulting hash into `dst`, an array of 32 bytes. The state remains\nvalid after a call to `finish_256`, meaning the user may feed more data into\nthe hash via `update_256`. (The finish_256 function operates on an internal copy of\nthe state and therefore does not invalidate the client-held state `p`.)"]
    pub fn Hacl_Streaming_SHA2_finish_256(p: *mut Hacl_Streaming_SHA2_state_sha2_224, dst: *mut u8);
}
extern "C" {
    #[doc = "Free a state allocated with `create_in_256`.\n\nThis function is identical to the free function for SHA2_224."]
    pub fn Hacl_Streaming_SHA2_free_256(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    #[doc = "Hash `input`, of len `input_len`, into `dst`, an array of 32 bytes."]
    pub fn Hacl_Streaming_SHA2_sha256(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_224() -> *mut Hacl_Streaming_SHA2_state_sha2_224;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_224(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_update_224(
        p: *mut Hacl_Streaming_SHA2_state_sha2_224,
        input: *mut u8,
        input_len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "Write the resulting hash into `dst`, an array of 28 bytes. The state remains\nvalid after a call to `finish_224`, meaning the user may feed more data into\nthe hash via `update_224`."]
    pub fn Hacl_Streaming_SHA2_finish_224(p: *mut Hacl_Streaming_SHA2_state_sha2_224, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_224(p: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    #[doc = "Hash `input`, of len `input_len`, into `dst`, an array of 28 bytes."]
    pub fn Hacl_Streaming_SHA2_sha224(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_512() -> *mut Hacl_Streaming_SHA2_state_sha2_384;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_512(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "Feed an arbitrary amount of data into the hash. This function returns 0 for\nsuccess, or 1 if the combined length of all of the data passed to `update_512`\n(since the last call to `init_512`) exceeds 2^125-1 bytes.\n\nThis function is identical to the update function for SHA2_384."]
    pub fn Hacl_Streaming_SHA2_update_512(
        p: *mut Hacl_Streaming_SHA2_state_sha2_384,
        input: *mut u8,
        input_len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "Write the resulting hash into `dst`, an array of 64 bytes. The state remains\nvalid after a call to `finish_512`, meaning the user may feed more data into\nthe hash via `update_512`. (The finish_512 function operates on an internal copy of\nthe state and therefore does not invalidate the client-held state `p`.)"]
    pub fn Hacl_Streaming_SHA2_finish_512(p: *mut Hacl_Streaming_SHA2_state_sha2_384, dst: *mut u8);
}
extern "C" {
    #[doc = "Free a state allocated with `create_in_512`.\n\nThis function is identical to the free function for SHA2_384."]
    pub fn Hacl_Streaming_SHA2_free_512(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "Hash `input`, of len `input_len`, into `dst`, an array of 64 bytes."]
    pub fn Hacl_Streaming_SHA2_sha512(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_384() -> *mut Hacl_Streaming_SHA2_state_sha2_384;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_384(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_update_384(
        p: *mut Hacl_Streaming_SHA2_state_sha2_384,
        input: *mut u8,
        input_len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "Write the resulting hash into `dst`, an array of 48 bytes. The state remains\nvalid after a call to `finish_384`, meaning the user may feed more data into\nthe hash via `update_384`."]
    pub fn Hacl_Streaming_SHA2_finish_384(p: *mut Hacl_Streaming_SHA2_state_sha2_384, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_384(p: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "Hash `input`, of len `input_len`, into `dst`, an array of 48 bytes."]
    pub fn Hacl_Streaming_SHA2_sha384(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_224(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_256(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_384(s: *mut u64, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_512(s: *mut u64, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_last_224(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_last_256(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_224(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_256(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_384(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_512(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_secret_to_public(public_key: *mut u8, private_key: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_expand_keys(expanded_keys: *mut u8, private_key: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign_expanded(
        signature: *mut u8,
        expanded_keys: *mut u8,
        msg_len: u32,
        msg: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign(
        signature: *mut u8,
        private_key: *mut u8,
        msg_len: u32,
        msg: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Ed25519_verify(
        public_key: *mut u8,
        msg_len: u32,
        msg: *mut u8,
        signature: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Expand pseudorandom key to desired length.\n\n@param a Hash function to use. Usually, the same as used in `EverCrypt_HKDF_extract`.\n@param okm Pointer to `len` bytes of memory where output keying material is written to.\n@param prk Pointer to at least `HashLen` bytes of memory where pseudorandom key is read from. Usually, this points to the output from the extract step.\n@param prklen Length of pseudorandom key.\n@param info Pointer to `infolen` bytes of memory where context and application specific information is read from.\n@param infolen Length of context and application specific information. Can be 0.\n@param len Length of output keying material."]
    pub fn EverCrypt_HKDF_expand(
        a: Spec_Hash_Definitions_hash_alg,
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    #[doc = "Extract a fixed-length pseudorandom key from input keying material.\n\n@param a Hash function to use. The allowed values are:\n `Spec_Hash_Definitions_Blake2B` (`HashLen` = 64),\n `Spec_Hash_Definitions_Blake2S` (`HashLen` = 32),\n `Spec_Hash_Definitions_SHA2_256` (`HashLen` = 32),\n `Spec_Hash_Definitions_SHA2_384` (`HashLen` = 48),\n `Spec_Hash_Definitions_SHA2_512` (`HashLen` = 64), and\n `Spec_Hash_Definitions_SHA1` (`HashLen` = 20).\n@param prk Pointer to `HashLen` bytes of memory where pseudorandom key is written to.\n`HashLen` depends on the used algorithm `a`. See above.\n@param salt Pointer to `saltlen` bytes of memory where salt value is read from.\n@param saltlen Length of salt value.\n@param ikm Pointer to `ikmlen` bytes of memory where input keying material is read from.\n@param ikmlen Length of input keying material."]
    pub fn EverCrypt_HKDF_extract(
        a: Spec_Hash_Definitions_hash_alg,
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn Hacl_SHA3_shake128_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_shake256_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_sha3_224(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_256(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_384(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_512(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA1_legacy_update_multi(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA1_legacy_update_last(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_SHA1_legacy_hash(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_MD5_legacy_update_multi(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_MD5_legacy_update_last(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_MD5_legacy_hash(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_init(
        hash: *mut Lib_IntVector_Intrinsics_vec128,
        kk: u32,
        nn: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_update_key(
        wv: *mut Lib_IntVector_Intrinsics_vec128,
        hash: *mut Lib_IntVector_Intrinsics_vec128,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_update_multi(
        len: u32,
        wv: *mut Lib_IntVector_Intrinsics_vec128,
        hash: *mut Lib_IntVector_Intrinsics_vec128,
        prev: u64,
        blocks: *mut u8,
        nb: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_update_last(
        len: u32,
        wv: *mut Lib_IntVector_Intrinsics_vec128,
        hash: *mut Lib_IntVector_Intrinsics_vec128,
        prev: u64,
        rem: u32,
        d: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_finish(
        nn: u32,
        output: *mut u8,
        hash: *mut Lib_IntVector_Intrinsics_vec128,
    );
}
extern "C" {
    #[doc = "Write the BLAKE2s digest of message `d` using key `k` into `output`.\n\n@param nn Length of to-be-generated digest with 1 <= `nn` <= 32.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2s_128_blake2s(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_store_state128s_to_state32(
        st32: *mut u32,
        st: *mut Lib_IntVector_Intrinsics_vec128,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_load_state128s_from_state32(
        st: *mut Lib_IntVector_Intrinsics_vec128,
        st32: *mut u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_128_blake2s_malloc() -> *mut Lib_IntVector_Intrinsics_vec128;
}
extern "C" {
    pub fn Hacl_Blake2b_256_blake2b_init(hash: *mut *mut ::std::os::raw::c_void, kk: u32, nn: u32);
}
extern "C" {
    pub fn Hacl_Blake2b_256_blake2b_update_key(
        wv: *mut *mut ::std::os::raw::c_void,
        hash: *mut *mut ::std::os::raw::c_void,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_256_blake2b_finish(
        nn: u32,
        output: *mut u8,
        hash: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Write the BLAKE2b digest of message `d` using key `k` into `output`.\n\n@param nn Length of the to-be-generated digest with 1 <= `nn` <= 64.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2b_256_blake2b(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_256_load_state256b_from_state32(
        st: *mut *mut ::std::os::raw::c_void,
        st32: *mut u64,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_256_store_state256b_to_state32(
        st32: *mut u64,
        st: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_256_blake2b_malloc() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_init(hash: *mut u64, kk: u32, nn: u32);
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_update_key(
        wv: *mut u64,
        hash: *mut u64,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_finish(nn: u32, output: *mut u8, hash: *mut u64);
}
extern "C" {
    #[doc = "Write the BLAKE2b digest of message `d` using key `k` into `output`.\n\n@param nn Length of the to-be-generated digest with 1 <= `nn` <= 64.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2b_32_blake2b(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_malloc() -> *mut u64;
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_init(hash: *mut u32, kk: u32, nn: u32);
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_key(
        wv: *mut u32,
        hash: *mut u32,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_multi(
        len: u32,
        wv: *mut u32,
        hash: *mut u32,
        prev: u64,
        blocks: *mut u8,
        nb: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_last(
        len: u32,
        wv: *mut u32,
        hash: *mut u32,
        prev: u64,
        rem: u32,
        d: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_finish(nn: u32, output: *mut u8, hash: *mut u32);
}
extern "C" {
    #[doc = "Write the BLAKE2s digest of message `d` using key `k` into `output`.\n\n@param nn Length of to-be-generated digest with 1 <= `nn` <= 32.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2s_32_blake2s(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_malloc() -> *mut u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_Hash_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_Hash_state_s = EverCrypt_Hash_state_s_s;
extern "C" {
    pub fn EverCrypt_Hash_Incremental_hash_len(a: Spec_Hash_Definitions_hash_alg) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_Hash_Incremental_hash_state_s {
    pub block_state: *mut EverCrypt_Hash_state_s,
    pub buf: *mut u8,
    pub total_len: u64,
}
pub type EverCrypt_Hash_Incremental_hash_state = EverCrypt_Hash_Incremental_hash_state_s;
extern "C" {
    #[doc = "Allocate initial state for the agile hash. The argument `a` stands for the\nchoice of algorithm (see Hacl_Spec.h). This API will automatically pick the most\nefficient implementation, provided you have called EverCrypt_AutoConfig2_init()\nbefore. The state is to be freed by calling `free`."]
    pub fn EverCrypt_Hash_Incremental_create_in(
        a: Spec_Hash_Definitions_hash_alg,
    ) -> *mut EverCrypt_Hash_Incremental_hash_state;
}
extern "C" {
    #[doc = "Reset an existing state to the initial hash state with empty data."]
    pub fn EverCrypt_Hash_Incremental_init(s: *mut EverCrypt_Hash_Incremental_hash_state);
}
extern "C" {
    #[doc = "Feed an arbitrary amount of data into the hash. This function returns\nEverCrypt_Error_Success for success, or EverCrypt_Error_MaximumLengthExceeded if\nthe combined length of all of the data passed to `update` (since the last call\nto `init`) exceeds 2^61-1 bytes or 2^64-1 bytes, depending on the choice of\nalgorithm. Both limits are unlikely to be attained in practice."]
    pub fn EverCrypt_Hash_Incremental_update(
        s: *mut EverCrypt_Hash_Incremental_hash_state,
        data: *mut u8,
        len: u32,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    #[doc = "Perform a run-time test to determine which algorithm was chosen for the given piece of state."]
    pub fn EverCrypt_Hash_Incremental_alg_of_state(
        s: *mut EverCrypt_Hash_Incremental_hash_state,
    ) -> Spec_Hash_Definitions_hash_alg;
}
extern "C" {
    #[doc = "Write the resulting hash into `dst`, an array whose length is\nalgorithm-specific. You can use the macros defined earlier in this file to\nallocate a destination buffer of the right length. The state remains valid after\na call to `finish`, meaning the user may feed more data into the hash via\n`update`. (The finish function operates on an internal copy of the state and\ntherefore does not invalidate the client-held state.)"]
    pub fn EverCrypt_Hash_Incremental_finish(
        s: *mut EverCrypt_Hash_Incremental_hash_state,
        dst: *mut u8,
    );
}
extern "C" {
    #[doc = "Free a state previously allocated with `create_in`."]
    pub fn EverCrypt_Hash_Incremental_free(s: *mut EverCrypt_Hash_Incremental_hash_state);
}
extern "C" {
    #[doc = "Hash `input`, of len `len`, into `dst`, an array whose length is determined by\nyour choice of algorithm `a` (see Hacl_Spec.h). You can use the macros defined\nearlier in this file to allocate a destination buffer of the right length. This\nAPI will automatically pick the most efficient implementation, provided you have\ncalled EverCrypt_AutoConfig2_init() before."]
    pub fn EverCrypt_Hash_Incremental_hash(
        a: Spec_Hash_Definitions_hash_alg,
        dst: *mut u8,
        input: *mut u8,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_is_supported_alg(uu___: Spec_Hash_Definitions_hash_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_HMAC_compute(
        a: Spec_Hash_Definitions_hash_alg,
        mac: *mut u8,
        key: *mut u8,
        keylen: u32,
        data: *mut u8,
        datalen: u32,
    );
}
extern "C" {
    #[doc = "Hash the message with SHA2-256, then sign the resulting digest with the P256 signature function.\n\nInput: result buffer: uint8[64],\nm buffer: uint8 [mLen],\npriv(ate)Key: uint8[32],\nk (nonce): uint32[32].\n\nOutput: bool, where True stands for the correct signature generation. False value means that an error has occurred.\n\nThe private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha2(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Hash the message with SHA2-384, then sign the resulting digest with the P256 signature function.\n\nInput: result buffer: uint8[64],\nm buffer: uint8 [mLen],\npriv(ate)Key: uint8[32],\nk (nonce): uint32[32].\n\nOutput: bool, where True stands for the correct signature generation. False value means that an error has occurred.\n\nThe private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha384(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Hash the message with SHA2-512, then sign the resulting digest with the P256 signature function.\n\nInput: result buffer: uint8[64],\nm buffer: uint8 [mLen],\npriv(ate)Key: uint8[32],\nk (nonce): uint32[32].\n\nOutput: bool, where True stands for the correct signature generation. False value means that an error has occurred.\n\nThe private key and the nonce are expected to be more than 0 and less than the curve order."]
    pub fn Hacl_P256_ecdsa_sign_p256_sha512(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "P256 signature WITHOUT hashing first.\n\nThis function is intended to receive a hash of the input. For convenience, we\nrecommend using one of the hash-and-sign combined functions above.\n\nThe argument `m` MUST be at least 32 bytes (i.e. `mLen >= 32`).\n\nNOTE: The equivalent functions in OpenSSL and Fiat-Crypto both accept inputs\nsmaller than 32 bytes. These libraries left-pad the input with enough zeroes to\nreach the minimum 32 byte size. Clients who need behavior identical to OpenSSL\nneed to perform the left-padding themselves.\n\nInput: result buffer: uint8[64],\nm buffer: uint8 [mLen],\npriv(ate)Key: uint8[32],\nk (nonce): uint32[32].\n\nOutput: bool, where True stands for the correct signature generation. False value means that an error has occurred.\n\nThe private key and the nonce are expected to be more than 0 and less than the curve order.\n\nThe message m is expected to be hashed by a strong hash function, the lenght of the message is expected to be 32 bytes and more."]
    pub fn Hacl_P256_ecdsa_sign_p256_without_hash(
        result: *mut u8,
        mLen: u32,
        m: *mut u8,
        privKey: *mut u8,
        k: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,\nthus this code is not secret independent with respect to the operations done over the input.\n\nInput: m buffer: uint8 [mLen],\npub(lic)Key: uint8[64],\nr: uint8[32],\ns: uint8[32].\n\nOutput: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha2(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,\nthus this code is not secret independent with respect to the operations done over the input.\n\nInput: m buffer: uint8 [mLen],\npub(lic)Key: uint8[64],\nr: uint8[32],\ns: uint8[32].\n\nOutput: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha384(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,\nthus this code is not secret independent with respect to the operations done over the input.\n\nInput: m buffer: uint8 [mLen],\npub(lic)Key: uint8[64],\nr: uint8[32],\ns: uint8[32].\n\nOutput: bool, where true stands for the correct signature verification."]
    pub fn Hacl_P256_ecdsa_verif_p256_sha512(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The input of the function is considered to be public,\nthus this code is not secret independent with respect to the operations done over the input.\n\nInput: m buffer: uint8 [mLen],\npub(lic)Key: uint8[64],\nr: uint8[32],\ns: uint8[32].\n\nOutput: bool, where true stands for the correct signature verification.\n\nThe message m is expected to be hashed by a strong hash function, the lenght of the message is expected to be 32 bytes and more."]
    pub fn Hacl_P256_ecdsa_verif_without_hash(
        mLen: u32,
        m: *mut u8,
        pubKey: *mut u8,
        r: *mut u8,
        s: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Validate a public key.\n\nInput: pub(lic)Key: uint8[64].\nOutput: bool, where 0 stands for the public key to be correct with respect to SP 800-56A:\n• Verify that the public key is not the “point at infinity”, represented as O.\n• Verify that the affine x and y coordinates of the point represented by the public key are in the range [0, p – 1] where p is the prime defining the finite field.\n• Verify that y^2 = x^3 + ax + b where a and b are the coefficients of the curve equation.\nThe last extract is taken from : https://neilmadden.blog/2017/05/17/so-how-do-you-validate-nist-ecdh-public-keys/"]
    pub fn Hacl_P256_validate_public_key(pubKey: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Validate a private key, e.g. prior to signing.\n\nInput: scalar: uint8[32].\n\nOutput: bool, where true stands for the scalar to be more than 0 and less than order."]
    pub fn Hacl_P256_validate_private_key(x: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert 65-byte uncompressed to raw.\n\nThe function errors out if the first byte is incorrect, or if the resulting point is invalid.\n\n\n\nInput: a point in not compressed form (uint8[65]),\nresult: uint8[64] (internal point representation).\n\nOutput: bool, where true stands for the correct decompression."]
    pub fn Hacl_P256_uncompressed_to_raw(b: *mut u8, result: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert 33-byte compressed to raw.\n\nThe function errors out if the first byte is incorrect, or if the resulting point is invalid.\n\nInput: a point in compressed form (uint8[33]),\nresult: uint8[64] (internal point representation).\n\nOutput: bool, where true stands for the correct decompression."]
    pub fn Hacl_P256_compressed_to_raw(b: *mut u8, result: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert raw to 65-byte uncompressed.\n\nThis function effectively prepends a 0x04 byte.\n\nInput: a point buffer (internal representation: uint8[64]),\nresult: a point in not compressed form (uint8[65])."]
    pub fn Hacl_P256_raw_to_uncompressed(b: *mut u8, result: *mut u8);
}
extern "C" {
    #[doc = "Convert raw to 33-byte compressed.\n\nInput: `b`, the pointer buffer in internal representation, of type `uint8[64]`\nOutput: `result`, a point in compressed form, of type `uint8[33]`"]
    pub fn Hacl_P256_raw_to_compressed(b: *mut u8, result: *mut u8);
}
extern "C" {
    #[doc = "Convert a private key into a raw public key.\n\nThis function performs no key validation.\n\nInput: `scalar`, the private key, of type `uint8[32]`.\nOutput: `result`, the public key, of type `uint8[64]`.\nReturns:\n- `true`, for success, meaning the public key is not a point at infinity\n- `false`, otherwise.\n\n`scalar` and `result` MUST NOT overlap."]
    pub fn Hacl_P256_dh_initiator(result: *mut u8, scalar: *mut u8) -> bool;
}
extern "C" {
    #[doc = "ECDH key agreement.\n\nThis function takes a 32-byte secret key, another party's 64-byte raw public\nkey, and computeds the 64-byte ECDH shared key.\n\nThis function ONLY validates the public key.\n\nThe pub(lic)_key input of the function is considered to be public,\nthus this code is not secret independent with respect to the operations done over this variable.\n\nInput: result: uint8[64],\npub(lic)Key: uint8[64],\nscalar: uint8[32].\n\nOutput: bool, where True stands for the correct key generation. False value means that an error has occurred (possibly the provided public key was incorrect or the result represents point at infinity)."]
    pub fn Hacl_P256_dh_responder(result: *mut u8, pubKey: *mut u8, scalar: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Sign a message `msg` and write the signature to `sgnt`.\n\n@param a Hash algorithm to use. Allowed values for `a` are ...\n Spec_Hash_Definitions_SHA2_256,\n Spec_Hash_Definitions_SHA2_384, and\n Spec_Hash_Definitions_SHA2_512.\n@param modBits Count of bits in the modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param dBits Count of bits in `d` value.\n@param skey Pointer to secret key created by `Hacl_RSAPSS_new_rsapss_load_skey`.\n@param saltLen Length of salt.\n@param salt Pointer to `saltLen` bytes where the salt is read from.\n@param msgLen Length of message.\n@param msg Pointer to `msgLen` bytes where the message is read from.\n@param sgnt Pointer to `ceil(modBits / 8)` bytes where the signature is written to.\n\n@return Returns true if and only if signing was successful."]
    pub fn Hacl_RSAPSS_rsapss_sign(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        dBits: u32,
        skey: *mut u64,
        saltLen: u32,
        salt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
        sgnt: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Verify the signature `sgnt` of a message `msg`.\n\n@param a Hash algorithm to use.\n@param modBits Count of bits in the modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param pkey Pointer to public key created by `Hacl_RSAPSS_new_rsapss_load_pkey`.\n@param saltLen Length of salt.\n@param sgntLen Length of signature.\n@param sgnt Pointer to `sgntLen` bytes where the signature is read from.\n@param msgLen Length of message.\n@param msg Pointer to `msgLen` bytes where the message is read from.\n\n@return Returns true if and only if the signature is valid."]
    pub fn Hacl_RSAPSS_rsapss_verify(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        pkey: *mut u64,
        saltLen: u32,
        sgntLen: u32,
        sgnt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Load a public key from key parts.\n\n@param modBits Count of bits in modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from.\n@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from.\n\n@return Returns an allocated public key. Note: caller must take care to `free()` the created key."]
    pub fn Hacl_RSAPSS_new_rsapss_load_pkey(
        modBits: u32,
        eBits: u32,
        nb: *mut u8,
        eb: *mut u8,
    ) -> *mut u64;
}
extern "C" {
    #[doc = "Load a secret key from key parts.\n\n@param modBits Count of bits in modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param dBits Count of bits in `d` value.\n@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from.\n@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from.\n@param db Pointer to `ceil(modBits / 8)` bytes where the `d` value is read from.\n\n@return Returns an allocated secret key. Note: caller must take care to `free()` the created key."]
    pub fn Hacl_RSAPSS_new_rsapss_load_skey(
        modBits: u32,
        eBits: u32,
        dBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        db: *mut u8,
    ) -> *mut u64;
}
extern "C" {
    #[doc = "Sign a message `msg` and write the signature to `sgnt`.\n\n@param a Hash algorithm to use.\n@param modBits Count of bits in the modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param dBits Count of bits in `d` value.\n@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from.\n@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from.\n@param db Pointer to `ceil(modBits / 8)` bytes where the `d` value is read from.\n@param saltLen Length of salt.\n@param salt Pointer to `saltLen` bytes where the salt is read from.\n@param msgLen Length of message.\n@param msg Pointer to `msgLen` bytes where the message is read from.\n@param sgnt Pointer to `ceil(modBits / 8)` bytes where the signature is written to.\n\n@return Returns true if and only if signing was successful."]
    pub fn Hacl_RSAPSS_rsapss_skey_sign(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        dBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        db: *mut u8,
        saltLen: u32,
        salt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
        sgnt: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Verify the signature `sgnt` of a message `msg`.\n\n@param a Hash algorithm to use.\n@param modBits Count of bits in the modulus (`n`).\n@param eBits Count of bits in `e` value.\n@param nb Pointer to `ceil(modBits / 8)` bytes where the modulus (`n`) is read from.\n@param eb Pointer to `ceil(modBits / 8)` bytes where the `e` value is read from.\n@param saltLen Length of salt.\n@param sgntLen Length of signature.\n@param sgnt Pointer to `sgntLen` bytes where the signature is read from.\n@param msgLen Length of message.\n@param msg Pointer to `msgLen` bytes where the message is read from.\n\n@return Returns true if and only if the signature is valid."]
    pub fn Hacl_RSAPSS_rsapss_pkey_verify(
        a: Spec_Hash_Definitions_hash_alg,
        modBits: u32,
        eBits: u32,
        nb: *mut u8,
        eb: *mut u8,
        saltLen: u32,
        sgntLen: u32,
        sgnt: *mut u8,
        msgLen: u32,
        msg: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = "The mask generation function defined in the Public Key Cryptography Standard #1\n(https://www.ietf.org/rfc/rfc2437.txt Section 10.2.1)"]
    pub fn Hacl_RSAPSS_mgf_hash(
        a: Spec_Hash_Definitions_hash_alg,
        len: u32,
        mgfseed: *mut u8,
        maskLen: u32,
        res: *mut u8,
    );
}
