#!/usr/bin/env python3
#
# The mach driver for HACL.


import subprocess
import re
import sys
import os
import shutil
from tools.configure import Config

from tools.utils import subcommand, argument, json_config, dep_config, cmake_config, cli, subparsers, mprint as print, check_cmd
from tools.test import run_tests

# === SUBCOMMANDS === #


def _install(prefix=None, config=None):
    configuration = "Debug"
    if config:
        configuration = config
    cmake_cmd = ['cmake', '--install', 'build', '--config', configuration]
    if prefix:
        cmake_cmd.extend(['--prefix', prefix])
    subprocess.run(cmake_cmd, check=True)


@subcommand([argument("-p", "--prefix",
                      help="The path prefix to install into.", type=str),
             argument("-c", "--config",
                      help="The config to install, i.e. Debug or Release.", type=str)])
def install(args):
    _install(prefix=args.prefix, config=args.config)


@subcommand([argument("-c", "--clean", help="Clean before building.", action='store_true'),
             argument("--tests", help="Build tests.", action='store_true'),
             argument("--test", help="Build and run tests.",
                      action='store_true'),
             argument("-r", "--release", help="Build in release mode.",
                      action='store_true'),
             argument("-a", "--algorithms",
                      help="A list of algorithms to enable. Defaults to all.", type=str),
             argument(
                 "-p", "--target", help="Define compile target for cross compilation.", type=str),
             argument(
                 "-d", "--disable", help="Disable (hardware) features even if available.", type=str),
             argument(
                 "-s", "--sanitizer", help="Enable sanitizers.", type=str),
             argument(
                 "-e", "--edition", help="Choose a different HACL* edition.", type=str),
             argument(
                 "-l", "--language", help="Build language bindings for the given language.", type=str),
             argument("-v", "--verbose", help="Make builds verbose.", action='store_true')])
def build(args):
    """Main entry point for building HACL

    For convenience it is possible to run tests right after building using --test.

    Supported cross compilation targets:
        - x64-macos
        - s390x

    Features that can be disabled (TBD):
        - vec128 (avx/neon)
        - vec256 (avx2)
        - vale (x64 assembly)

    Supported sanitizers:
        - asan
        - ubsan

    Use an edition if you want a different build. Note that this build will
    use the MSVC version by default on Windows.
    Supported editions:
        - c89

    HACL can be built for another language than C.
    Note that bindings will always require the full C library such that the
    algorithm flag will be ignored.
        - rust
        - ocaml (TBD)
        - wasm (TBD)

    üí°  Windows builds are limited. The following arguments are not supported:
        - algorithms
        - sanitizer
        - edition
        - disable
    """
    cmake_args = []
    # Verbosity
    verbose = False
    if args.verbose:
        verbose = True

        def vprint(*args, **kwargs):
            print(args, kwargs)
    else:
        vprint = lambda *a, **k: None
    # Set config
    build_config = "Debug"
    if args.release:
        build_config = "Release"

    # Clean if requested
    if args.clean:
        print("Cleaning ...")
        try:
            shutil.rmtree("build")
            os.remove(cmake_config())
        except:
            pass  # We don't really care
    try:
        os.mkdir("build")
    except:
        pass  # We ignore the error if the directory exists already

    bindings = False
    if args.language == "rust":
        bindings = True
        language = "Rust"

    # Our default compiler is clang.
    compiler = os.getenv('CC', 'clang')
    windows = False

    # Select the source folder to use (regular, c89, msvc)
    source_dir = "src"
    include_dir = "include"
    if args.edition == "c89":
        source_dir = os.path.join(source_dir, "c89")
        include_dir = os.path.join(include_dir, "c89")
        cmake_args.append("-DCMAKE_C_STANDARD=90")
    # Set MSVC if detecting Windows.
    if sys.platform == "win32":
        windows = True
        source_dir = os.path.join(source_dir, "msvc")
        include_dir = os.path.join(include_dir, "msvc")
        # get msvc in the path (only x64 for now)
        vswhere_cmd = ['tools\\vcbuild.cmd']
        subprocess.run(vswhere_cmd, check=True)

    # Set target toolchain if cross compiling
    if args.target:
        if windows:
            print("‚ö†Ô∏è  Cross-compilation is not supporte on Windows.")
            exit(1)
        if args.target == "x64-macos":
            cmake_args.extend(
                ["-DCMAKE_TOOLCHAIN_FILE=config/x64-darwin.cmake"])
        elif args.target == "s390x":
            cmake_args.extend(
                ["-DCMAKE_TOOLCHAIN_FILE=config/s390x.cmake", "-DCMAKE_C_COMPILER=s390x-linux-gnu-gcc-10", "-DCMAKE_CXX_COMPILER=s390x-linux-gnu-g++-10"])
        else:
            print("‚ö†Ô∏è  Unknown cross-compilation target \"%s\"" % args.target)
            print("   Available targets: x64-macos, s390x")
            exit(1)
    if args.disable:
        if windows:
            print("‚ö†Ô∏è  Disabling features is not supporte on Windows.")
            exit(1)
        features_to_disable = list(
            map(lambda f: "-DDISABLE_"+f.upper()+"=ON", re.split(r"\W+", args.disable)))
        cmake_args.extend(features_to_disable)
    if args.tests or args.test:
        cmake_args.append("-DENABLE_TESTS=ON")
    if args.sanitizer:
        if windows:
            print("‚ö†Ô∏è  Sanitizers are not supporte on Windows.")
            exit(1)
        sanitizers = list(
            map(lambda f: "-DENABLE_"+f.upper()+"=ON", re.split(r"\W+", args.sanitizer)))
        cmake_args.extend(sanitizers)

    # if verbose:
    #     cmake_args.extend(["--debug-output", "--trace"])

    # There must be a config.cmake already that contains some useful information.
    # We have to generate config.h before we can generate the configuration
    # properly. ü•öüêì
    # First run a dummy config for all algorithms.
    config = Config(json_config(), source_dir, include_dir, compiler=compiler)
    config.write_cmake_config(cmake_config())
    config.write_dep_config(dep_config())
    # '--debug-trycompile'
    cmake_cmd = ['cmake', '-B', 'build']
    cmake_cmd.extend(cmake_args)
    vprint(str(cmake_cmd))
    subprocess.run(cmake_cmd, check=True)

    # Generate config.cmake using the algorithms argument if any given
    algorithms = []
    if args.algorithms and not bindings:
        algorithms = re.split(r"\W+", args.algorithms)
    config = Config(json_config(), source_dir,
                    include_dir, algorithms=algorithms)
    config.write_cmake_config(cmake_config())
    config.write_dep_config(dep_config())

    # Set ninja arguments
    ninja_args = []
    if verbose:
        ninja_args.append('-v')

    # build C library
    ninja_cmd = ['ninja', '-f', 'build-%s.ninja' % build_config, '-C', 'build']
    ninja_cmd.extend(ninja_args)
    vprint(str(ninja_cmd))
    subprocess.run(ninja_cmd, check=True)

    # build bindings if requested
    if bindings:
        check_cmd('cargo')
        _install(prefix='build/installed', config=build_config)
        cargo_cmd = ['cargo', 'build', '--manifest-path',
                     'rust/evercrypt-rs/Cargo.toml']
        subprocess.run(cargo_cmd, check=True)

    print("Build finished.")

    # test if requested
    if args.test:
        run_tests(config.tests)


@subcommand()
def clean(args):
    """Remove all build and config artifacts"""
    shutil.rmtree("build")
    os.remove(cmake_config())

# === Boiler plate === #


def main():
    args = cli.parse_args()
    if args.subcommand is None:
        cli.print_help()
    else:
        args.func(args)


if __name__ == '__main__':
    main()
